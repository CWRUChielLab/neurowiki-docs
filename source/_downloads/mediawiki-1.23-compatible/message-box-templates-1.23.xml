<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikipedia</sitename>
    <dbname>enwiki</dbname>
    <base>https://en.wikipedia.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.27.0-wmf.9</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikipedia</namespace>
      <namespace key="5" case="first-letter">Wikipedia talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="100" case="first-letter">Portal</namespace>
      <namespace key="101" case="first-letter">Portal talk</namespace>
      <namespace key="108" case="first-letter">Book</namespace>
      <namespace key="109" case="first-letter">Book talk</namespace>
      <namespace key="118" case="first-letter">Draft</namespace>
      <namespace key="119" case="first-letter">Draft talk</namespace>
      <namespace key="446" case="first-letter">Education Program</namespace>
      <namespace key="447" case="first-letter">Education Program talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
      <namespace key="2600" case="first-letter">Topic</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Module:Arguments</title>
    <ns>828</ns>
    <id>41298065</id>
    <revision>
      <id>604718421</id>
      <parentid>604271882</parentid>
      <timestamp>2014-04-18T10:30:10Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>memoize nils using a separate nilArgs table; this fixes a bug where nil values were being iterated over with pairs()</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="7032">-- This module provides easy processing of arguments passed to Scribunto from
-- #invoke. It is intended for use by other Lua modules, and should not be
-- called from #invoke directly.

local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType

local arguments = {}

-- Generate four different tidyVal functions, so that we don't have to check the
-- options every time we call it.

local function tidyValDefault(key, val)
	if type(val) == 'string' then
		val = val:match('^%s*(.-)%s*$')
		if val == '' then
			return nil
		else
			return val
		end
	else
		return val
	end
end

local function tidyValTrimOnly(key, val)
	if type(val) == 'string' then
		return val:match('^%s*(.-)%s*$')
	else
		return val
	end
end

local function tidyValRemoveBlanksOnly(key, val)
	if type(val) == 'string' then
		if val:find('%S') then
			return val
		else
			return nil
		end
	else
		return val
	end
end

local function tidyValNoChange(key, val)
	return val
end

function arguments.getArgs(frame, options)
	checkType('getArgs', 1, frame, 'table', true)
	checkType('getArgs', 2, options, 'table', true)
	frame = frame or {}
	options = options or {}

	--[[
	-- Get the arguments from the frame object if available. If the frame object
	-- is not available, we are being called from another Lua module or from the
	-- debug console, so assign the args to a new variable so we can
	-- differentiate them.
	--]]
	local fargs, pargs, luaArgs
	if type(frame.args) == 'table' and type(frame.getParent) == 'function' then
		if not options.parentOnly then
			fargs = frame.args
		end
		if not options.frameOnly then
			pargs = frame:getParent().args
		end
		if options.parentFirst then
			fargs, pargs = pargs, fargs
		end
	else
		luaArgs = frame
	end
	
	-- Set the order of precedence of the argument tables. If the variables are
	-- nil, nothing will be added to the table, which is how we avoid clashes
	-- between the frame/parent args and the Lua args.	
	local argTables = {fargs}
	argTables[#argTables + 1] = pargs
	argTables[#argTables + 1] = luaArgs

	--[[
	-- Generate the tidyVal function. If it has been specified by the user, we
	-- use that; if not, we choose one of four functions depending on the
	-- options chosen. This is so that we don't have to call the options table
	-- every time the function is called.
	--]]
	local tidyVal = options.valueFunc
	if tidyVal then
		if type(tidyVal) ~= 'function' then
			error(
				&quot;bad value assigned to option 'valueFunc'&quot;
					.. '(function expected, got '
					.. type(tidyVal)
					.. ')',
				2
			)
		end
	elseif options.trim ~= false then
		if options.removeBlanks ~= false then
			tidyVal = tidyValDefault
		else
			tidyVal = tidyValTrimOnly
		end
	else
		if options.removeBlanks ~= false then
			tidyVal = tidyValRemoveBlanksOnly
		else
			tidyVal = tidyValNoChange
		end
	end

	--[[
	-- Set up the args, metaArgs and nilArgs tables. args will be the one
	-- accessed from functions, and metaArgs will hold the actual arguments. Nil
	-- arguments are memoized in nilArgs, and the metatable connects all of them
	-- together.
	--]]
	local args, metaArgs, nilArgs, metatable = {}, {}, {}, {}
	setmetatable(args, metatable)

	local function mergeArgs(iterator, tables)
		--[[
		-- Accepts multiple tables as input and merges their keys and values
		-- into one table using the specified iterator. If a value is already
		-- present it is not overwritten; tables listed earlier have precedence.
		-- We are also memoizing nil values, but those values can be
		-- overwritten.
		--]]
		for _, t in ipairs(tables) do
			for key, val in iterator(t) do
				if metaArgs[key] == nil then
					local tidiedVal = tidyVal(key, val)
					if tidiedVal == nil then
						nilArgs[key] = true
					else
						metaArgs[key] = tidiedVal
					end
				end
			end
		end
	end

	--[[
	-- Define metatable behaviour. Arguments are memoized in the metaArgs table,
	-- and are only fetched from the argument tables once. Fetching arguments
	-- from the argument tables is the most resource-intensive step in this
	-- module, so we try and avoid it where possible. For this reason, nil
	-- arguments are also memoized, in the nilArgs table. Also, we keep a record
	-- in the metatable of when pairs and ipairs have been called, so we do not
	-- run pairs and ipairs on the argument tables more than once. We also do
	-- not run ipairs on fargs and pargs if pairs has already been run, as all
	-- the arguments will already have been copied over.
	--]]

	metatable.__index = function (t, key)
		--[[
		-- Fetches an argument when the args table is indexed. First we check
		-- to see if the value is memoized, and if not we try and fetch it from
		-- the argument tables. When we check memoization, we need to check
		-- metaArgs before nilArgs, as both can be non-nil at the same time.
		-- If the argument is not present in metaArgs, we also check whether
		-- pairs has been run yet. If pairs has already been run, we return nil.
		-- This is because all the arguments will have already been copied into
		-- metaArgs by the mergeArgs function, meaning that any other arguments
		-- must be nil.
		--]]
		local val = metaArgs[key]
		if val ~= nil then
			return val
		elseif metatable.donePairs or nilArgs[key] then
			return nil
		end
		for _, argTable in ipairs(argTables) do
			local argTableVal = tidyVal(key, argTable[key])
			if argTableVal == nil then
				nilArgs[key] = true
			else
				metaArgs[key] = argTableVal
				return argTableVal
			end
		end
		return nil
	end

	metatable.__newindex = function (t, key, val)
		-- This function is called when a module tries to add a new value to the
		-- args table, or tries to change an existing value.
		if options.readOnly then
			error(
				'could not write to argument table key &quot;'
					.. tostring(key)
					.. '&quot;; the table is read-only',
				2
			)
		elseif options.noOverwrite and args[key] ~= nil then
			error(
				'could not write to argument table key &quot;'
					.. tostring(key)
					.. '&quot;; overwriting existing arguments is not permitted',
				2
			)
		elseif val == nil then
			--[[
			-- If the argument is to be overwritten with nil, we need to erase
			-- the value in metaArgs, so that __index, __pairs and __ipairs do
			-- not use a previous existing value, if present; and we also need
			-- to memoize the nil in nilArgs, so that the value isn't looked
			-- up in the argument tables if it is accessed again.
			--]]
			metaArgs[key] = nil
			nilArgs[key] = true -- Memoize nils.
		else
			metaArgs[key] = val
		end
	end

	metatable.__pairs = function ()
		-- Called when pairs is run on the args table.
		if not metatable.donePairs then
			mergeArgs(pairs, argTables)
			metatable.donePairs = true
			metatable.doneIpairs = true
		end
		return pairs(metaArgs)
	end

	metatable.__ipairs = function ()
		-- Called when ipairs is run on the args table.
		if not metatable.doneIpairs then
			mergeArgs(ipairs, argTables)
			metatable.doneIpairs = true
		end
		return ipairs(metaArgs)
	end

	return args
end

return arguments</text>
      <sha1>40uxhi8w4ka6how2vsohizy8ehdfiej</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler</title>
    <ns>828</ns>
    <id>39772274</id>
    <revision>
      <id>577959141</id>
      <parentid>577958700</parentid>
      <timestamp>2013-10-20T10:48:14Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <minor/>
      <comment>Protected Module:Category handler: [[Wikipedia:Lua/Modules|High-risk Lua module]] ([Edit=Protected template] (indefinite) [Move=Protected template] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="13065">----------------------------------------------------------------------------------------------------------
--                                                                                                      --
--                                          CATEGORY HANDLER                                            --
--                                                                                                      --
--      This module implements the {{category handler}} template in Lua, with a few improvements: all   --
--      namespaces and all namespace aliases are supported, and namespace names are detected            --
--      automatically for the local wiki. This module requires [[Module:Namespace detect]] and          --
--      [[Module:Yesno]] to be available on the local wiki. It can be configured for different wikis    --
--      by altering the values in the &quot;cfg&quot; table.                                                      --
--                                                                                                      --
----------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------
--                                          Configuration data                                          --
--                      Language-specific parameter names and values can be set here.                   --
----------------------------------------------------------------------------------------------------------

local cfg = {}

-- The following config values set the names of parameters that suppress categorisation. They are used
-- with Module:Yesno, and work as follows:
--
-- cfg.nocat:
-- Result of yesno(args[cfg.nocat])         Effect
-- true                                     Categorisation is suppressed
-- false                                    Categorisation is allowed, and the blacklist check is skipped
-- nil                                      Categorisation is allowed
--
-- cfg.categories:
-- Result of yesno(args[cfg.categories])    Effect
-- true                                     Categorisation is allowed, and the blacklist check is skipped
-- false                                    Categorisation is suppressed
-- nil                                      Categorisation is allowed
cfg.nocat = 'nocat'    
cfg.categories = 'categories'

-- The parameter name for the legacy &quot;category2&quot; parameter. This skips the blacklist if set to the
-- cfg.category2Yes value, and suppresses categorisation if present but equal to anything other than
-- cfg.category2Yes or cfg.category2Negative.
cfg.category2 = 'category2'
cfg.category2Yes = 'yes'
cfg.category2Negative = '¬'

-- cfg.subpage is the parameter name to specify how to behave on subpages. cfg.subpageNo is the value to
-- specify to not categorise on subpages; cfg.only is the value to specify to only categorise on subpages.
cfg.subpage = 'subpage'
cfg.subpageNo = 'no'
cfg.subpageOnly = 'only'

-- The parameter for data to return in all namespaces.
cfg.all = 'all'

-- The parameter name for data to return if no data is specified for the namespace that is detected. This
-- must be the same as the cfg.other parameter in [[Module:Namespace detect]].
cfg.other = 'other'

-- The parameter name used to specify a page other than the current page; used for testing and
-- demonstration. This must be the same as the cfg.page parameter in [[Module:Namespace detect]].
cfg.page = 'page'

-- The categorisation blacklist. Pages that match Lua patterns in this list will not be categorised.
-- (However, see the explanation of cfg.nocat, cfg.categories and cfg.category2 for some exceptions.)
-- If the namespace name has a space in, it must be written with an underscore, e.g. &quot;Wikipedia_talk&quot;.
-- Other parts of the title can have either underscores or spaces.
cfg.blacklist = {
    '^Main Page$', -- don't categorise the main page.
    
    -- Don't categorise the following pages or their subpages.
    '^Wikipedia:Cascade%-protected items$',
    '^Wikipedia:Cascade%-protected items/.*$',
    '^User:UBX$', -- The userbox &quot;template&quot; space.
    '^User:UBX/.*$',
    '^User_talk:UBX$',
    '^User_talk:UBX/.*$',
    
    -- Don't categorise subpages of these pages, but allow
    -- categorisation of the base page.
    '^Wikipedia:Template messages/.+$',
    
    '/[aA]rchive' -- Don't categorise archives.
}

-- This is a table of namespaces to categorise by default. They should be in the format of parameter
-- names accepted by [[Module:Namespace detect]].
cfg.defaultNamespaces = {
    'main',
    'file',
    'help',
    'category'
}

----------------------------------------------------------------------------------------------------------
--                                          End configuration data                                      --
----------------------------------------------------------------------------------------------------------

-- Get dependent modules
local nsDetect = require('Module:Namespace detect')
local yesno = require('Module:Yesno')

----------------------------------------------------------------------------------------------------------
--                                          Local functions                                             --
--      The following are internal functions, which we do not want to be accessible from other modules. --
----------------------------------------------------------------------------------------------------------

-- Find whether we need to return a category or not.
local function needsCategory(pageObject, args)
    -- Don't categorise if the relevant options are set.
    if yesno(args[cfg.nocat])
        or yesno(args[cfg.categories]) == false
        or (
            args[cfg.category2] 
            and args[cfg.category2] ~= cfg.category2Yes 
            and args[cfg.category2] ~= cfg.category2Negative
        )
    then
        return false
    end
    -- If there is no pageObject available, then that either means that we are over
    -- the expensive function limit or that the title specified was invalid. Invalid
    -- titles will probably only be a problem during testing, so we choose the best
    -- fallback for being over the expensive function limit. The fallback behaviour
    -- of the old template was to assume the page was not a subpage, so we will do
    -- the same here.
    if args[cfg.subpage] == cfg.subpageNo and pageObject and pageObject.isSubpage then
        return false
    end
    if args[cfg.subpage] == cfg.subpageOnly 
        and (not pageObject or (pageObject and not pageObject.isSubpage))
    then
        return false
    end
    return true
end

-- Find whether we need to check the blacklist or not.
local function needsBlacklistCheck(args)
    if yesno(args[cfg.nocat]) == false
        or yesno(args[cfg.categories]) == true
        or args[cfg.category2] == cfg.category2Yes
    then
        return false
    else
        return true
    end
end

-- Find whether any namespace parameters have been specified.
-- Mappings is the table of parameter mappings taken from
-- [[Module:Namespace detect]].
local function nsParamsExist(mappings, args)
    if args[cfg.all] or args[cfg.other] then
        return true
    end
    for ns, params in pairs(mappings) do
        for i, param in ipairs(params) do
            if args[param] then
                return true
            end
        end
    end
    return false
end

----------------------------------------------------------------------------------------------------------
--                                          Global functions                                            --
--      The following functions are global, because we want them to be accessible from #invoke and      --
--      from other Lua modules.                                                                         --
----------------------------------------------------------------------------------------------------------

local p = {}

-- Find if a string matches the blacklist. Returns the match if one is found, or nil otherwise.
-- Input should be a page title with a namespace prefix, e.g. &quot;Wikipedia talk:Articles for deletion&quot;.
function p.matchesBlacklist(page)
    if type(page) ~= 'string' then return end
    for i, pattern in ipairs(cfg.blacklist) do
        local match = mw.ustring.match(page, pattern)
        if match then
            return match
        end
    end
end

-- The main structure of the module. Checks whether we need to categorise,
-- and then passes the relevant arguments to [[Module:Namespace detect]].
function p._main(args)
    -- Get the page object and argument mappings from
    -- [[Module:Namespace detect]], to save us from having to rewrite the
    -- code.
    local pageObject = nsDetect.getPageObject(args[cfg.page])
    local mappings = nsDetect.getParamMappings()
    
    if not needsCategory(pageObject, args) then return end
    
    local ret = ''
    -- Check blacklist if necessary.
    if not needsBlacklistCheck(args) or not p.matchesBlacklist(pageObject.prefixedText) then
        if not nsParamsExist(mappings, args) then
            -- No namespace parameters exist; basic usage. Pass args[1] to
            -- [[Module:Namespace detect]] using the default namespace
            -- parameters, and return the result.
            local ndargs = {}
            for _, ndarg in ipairs(cfg.defaultNamespaces) do
                ndargs[ndarg] = args[1]
            end
            ndargs.page = args.page
            ndargs.demospace = args.demospace
            local ndresult = nsDetect._main(ndargs)
            if ndresult then
                ret = ret .. ndresult
            end
        else
            -- Namespace parameters exist; advanced usage.
            -- If the all parameter is specified, return it.
            local all = args.all
            if type(all) == 'string' then
                ret = ret .. all
            end
            
            -- Get the arguments to pass to [[Module:Namespace detect]].
            local ndargs = {}
            for ns, params in pairs(mappings) do
                for _, param in ipairs(params) do
                    ndargs[param] = args[param] or args[cfg.other] or nil
                end
            end
            ndargs.other = args.other
            ndargs.page = args.page
            ndargs.demospace = args.demospace
            
            local data = nsDetect._main(ndargs)
            
            -- Work out what to return based on the result of the namespace detect call.
            local datanum = tonumber(data)
            if type(datanum) == 'number' then
                -- &quot;data&quot; is a number, so return that positional parameter.
                -- Remove non-positive integer values, as only positive integers
                -- from 1-10 were used with the old template.
                if datanum &gt; 0 and math.floor(datanum) == datanum then
                    local dataArg = args[datanum]
                    if type(dataArg) == 'string' then
                        ret = ret .. dataArg
                    end
                end
            else
                -- &quot;data&quot; is not a number, so return it as it is.
                if type(data) == 'string' then
                    ret = ret .. data
                end
            end
        end
    end
    return ret
end

function p.main(frame)
    -- If called via #invoke, use the args passed into the invoking
    -- template, or the args passed to #invoke if any exist. Otherwise
    -- assume args are being passed directly in.
    local origArgs
    if frame == mw.getCurrentFrame() then
        origArgs = frame:getParent().args
        for k, v in pairs(frame.args) do
            origArgs = frame.args
            break
        end
    else
        origArgs = frame
    end

    -- Trim whitespace and remove blank arguments for the following args:
    -- 1, 2, 3 etc., &quot;nocat&quot;, &quot;categories&quot;, &quot;subpage&quot;, and &quot;page&quot;.
    local args = {}
    for k, v in pairs(origArgs) do
        if type(v) == 'string' then
            v = mw.text.trim(v) -- Trim whitespace.
        end
        if type(k) == 'number'
            or k == cfg.nocat
            or k == cfg.categories
            or k == cfg.subpage
            or k == cfg.page
        then
            if v ~= '' then
                args[k] = v
            end
        else
            args[k] = v
        end
    end
    
    -- Lower-case &quot;nocat&quot;, &quot;categories&quot;, &quot;category2&quot;, and &quot;subpage&quot;. These
    -- parameters are put in lower case whenever they appear in the old
    -- template, so we can just do it once here and save ourselves some work.
    local lowercase = {cfg.nocat, cfg.categories, cfg.category2, cfg.subpage}
    for _, v in ipairs(lowercase) do
        local argVal = args[v]
        if type(argVal) == 'string' then
            args[v] = mw.ustring.lower(argVal)
        end
    end
    
    return p._main(args)
end

return p</text>
      <sha1>i2ez8nejriv7clde6mvnuwl3ypo3qj6</sha1>
    </revision>
  </page>
  <page>
    <title>Module:HtmlBuilder</title>
    <ns>828</ns>
    <id>38663961</id>
    <revision>
      <id>573509786</id>
      <parentid>558894130</parentid>
      <timestamp>2013-09-18T15:22:39Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>don't add attributes with no values, plus a couple of minor tweaks</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="4278">-- Module for building complex HTML (e.g. infoboxes, navboxes) using a fluent interface.

local HtmlBuilder = {}

local metatable = {}

metatable.__index = function(t, key)
    local ret = rawget(t, key)
    if ret then
        return ret
    end
    
    ret = metatable[key]
    if type(ret) == 'function' then
        return function(...) 
            return ret(t, ...) 
        end 
    else
        return ret
    end
end

metatable.__tostring = function(t)
    local ret = {}
    t._build(ret)
    return table.concat(ret)
end

metatable._build = function(t, ret)
    if t.tagName then 
        table.insert(ret, '&lt;' .. t.tagName)
        for i, attr in ipairs(t.attributes) do
            table.insert(ret, ' ' .. attr.name .. '=&quot;' .. attr.val .. '&quot;') 
        end
        if #t.styles &gt; 0 then
            table.insert(ret, ' style=&quot;')
            for i, prop in ipairs(t.styles) do
                if type(prop) == 'string' then -- added with cssText()
                    table.insert(ret, prop .. ';')
                else -- added with css()
                    table.insert(ret, prop.name .. ':' .. prop.val .. ';')
                end
            end
            table.insert(ret, '&quot;')
        end
        if t.selfClosing then
            table.insert(ret, ' /')
        end
        table.insert(ret, '&gt;') 
    end
    for i, node in ipairs(t.nodes) do
        if node then
            if type(node) == 'table' then
                node._build(ret)
            else
                table.insert(ret, tostring(node))
            end
        end
    end
    if t.tagName and not t.unclosed and not t.selfClosing then
        table.insert(ret, '&lt;/' .. t.tagName .. '&gt;')
    end
end

metatable.node = function(t, builder)
    if builder then
        table.insert(t.nodes, builder)
    end
    return t
end

metatable.wikitext = function(t, ...) 
    local vals = {...}
    for i = 1, #vals do
        if vals[i] then
            table.insert(t.nodes, vals[i])
        end
    end
    return t
end

metatable.newline = function(t)
    table.insert(t.nodes, '\n')
    return t
end

metatable.tag = function(t, tagName, args)
    args = args or {}
    args.parent = t
    local builder = HtmlBuilder.create(tagName, args)
    table.insert(t.nodes, builder)
    return builder
end

local function getAttr(t, name)
    for i, attr in ipairs(t.attributes) do
        if attr.name == name then
            return attr
        end
    end
end

metatable.attr = function(t, name, val)
    if type(val) == 'string' or type(val) == 'number' then
        -- if caller sets the style attribute explicitly, then replace all styles previously added with css() and cssText()
        if name == 'style' then
            t.styles = {val}
            return t
        end
        
        local attr = getAttr(t, name)
        if attr then
            attr.val = val
        else
            table.insert(t.attributes, {name = name, val = val})
        end
    end
    
    return t
end

metatable.addClass = function(t, class)
    if class then
        local attr = getAttr(t, 'class')
        if attr then
            attr.val = attr.val .. ' ' .. class
        else
            t.attr('class', class)
        end
    end
    
    return t
end

metatable.css = function(t, name, val)
    if type(val) == 'string' or type(val) == 'number' then
        for i, prop in ipairs(t.styles) do
            if prop.name == name then
                prop.val = val
                return t
            end
        end
        
        table.insert(t.styles, {name = name, val = val})
    end
    
    return t
end

metatable.cssText = function(t, css)
    if css then
        table.insert(t.styles, css)
    end
    return t
end

metatable.done = function(t)
    return t.parent or t
end

metatable.allDone = function(t)
    while t.parent do
        t = t.parent
    end
    return t
end

function HtmlBuilder.create(tagName, args)
    args = args or {}
    local builder = {}
    setmetatable(builder, metatable)
    builder.nodes = {}
    builder.attributes = {}
    builder.styles = {}
    builder.tagName = tagName
    builder.parent = args.parent
    builder.unclosed = args.unclosed or false
    builder.selfClosing = args.selfClosing or false
    return builder
end

return HtmlBuilder</text>
      <sha1>ait58gp3hn4i3oyevj1ucebrzvyok1o</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Message box</title>
    <ns>828</ns>
    <id>40574910</id>
    <revision>
      <id>603256010</id>
      <parentid>596626111</parentid>
      <timestamp>2014-04-08T04:39:12Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>Allow passing attributes per protected edit request by [[User:Jackmcbarn]]. Also remove undocumented &quot;hidden&quot; parameter and format the module so it mostly fits within 80 chars.</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="17898">-- This is a meta-module for producing message box templates, including
-- {{mbox}}, {{ambox}}, {{imbox}}, {{tmbox}}, {{ombox}}, {{cmbox}} and {{fmbox}}.

-- Require necessary modules.
local getArgs = require('Module:Arguments').getArgs
local htmlBuilder = require('Module:HtmlBuilder')
local categoryHandler = require('Module:Category handler').main
local yesno = require('Module:Yesno')

-- Load the configuration page.
local cfgTables = mw.loadData('Module:Message box/configuration')

-- Get a language object for formatDate and ucfirst.
local lang = mw.language.getContentLanguage()

-- Set aliases for often-used functions to reduce table lookups.
local format = mw.ustring.format
local tinsert = table.insert
local tconcat = table.concat
local trim = mw.text.trim

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function getTitleObject(page, ...)
	if type(page) == 'string' then
		-- Get the title object, passing the function through pcall 
		-- in case we are over the expensive function count limit.
		local success, title = pcall(mw.title.new, page, ...)
		if success then
			return title
		end
	end
end

local function union(t1, t2)
	-- Returns the union of two arrays.
	local vals = {}
	for i, v in ipairs(t1) do
		vals[v] = true
	end
	for i, v in ipairs(t2) do
		vals[v] = true
	end
	local ret = {}
	for k in pairs(vals) do
		tinsert(ret, k)
	end
	table.sort(ret)
	return ret
end

local function getArgNums(args, prefix)
	local nums = {}
	for k, v in pairs(args) do
		local num = mw.ustring.match(tostring(k), '^' .. prefix .. '([1-9]%d*)$')
		if num then
			tinsert(nums, tonumber(num))
		end
	end
	table.sort(nums)
	return nums
end

--------------------------------------------------------------------------------
-- Box class definition
--------------------------------------------------------------------------------

local box = {}
box.__index = box

function box.new()
	local obj = {}
	setmetatable(obj, box)
	return obj
end

function box.getNamespaceId(ns)
	if not ns then return end
	if type(ns) == 'string' then
		ns = lang:ucfirst(mw.ustring.lower(ns))
		if ns == 'Main' then
			ns = 0
		end
	end
	local nsTable = mw.site.namespaces[ns]
	if nsTable then
		return nsTable.id
	end
end

function box.getMboxType(nsid)
	-- Gets the mbox type from a namespace number.
	if nsid == 0 then
		return 'ambox' -- main namespace
	elseif nsid == 6 then
		return 'imbox' -- file namespace
	elseif nsid == 14 then
		return 'cmbox' -- category namespace
	else
		local nsTable = mw.site.namespaces[nsid]
		if nsTable and nsTable.isTalk then
			return 'tmbox' -- any talk namespace
		else
			return 'ombox' -- other namespaces or invalid input
		end
	end
end

function box:addCat(ns, cat, sort)
	if type(cat) ~= 'string' then return end
	local nsVals = {'main', 'template', 'all'}
	local tname
	for i, val in ipairs(nsVals) do
		if ns == val then
			tname = ns .. 'Cats'
		end
	end
	if not tname then
		for i, val in ipairs(nsVals) do
			nsVals[i] = format('&quot;%s&quot;', val)
		end
		error(
			'invalid ns parameter passed to box:addCat; valid values are '
			.. mw.text.listToText(nsVals, nil, ' or ')
		)
	end
	self[tname] = self[tname] or {}
	if type(sort) == 'string' then
		tinsert(self[tname], format('[[Category:%s|%s]]', cat, sort))
	else
		tinsert(self[tname], format('[[Category:%s]]', cat))
	end
end

function box:addClass(class)
	if type(class) ~= 'string' then return end
	self.classes = self.classes or {}
	tinsert(self.classes, class)
end

function box:addAttr(attr, val)
	if type(attr) ~= 'string' or type(val) ~= 'string' then return end
	self.attrs = self.attrs or {}
	tinsert(self.attrs, attr)
end

function box:setTitle(args)
	-- Get the title object and the namespace.
	self.pageTitle = getTitleObject(args.page ~= '' and args.page)
	self.title = self.pageTitle or mw.title.getCurrentTitle()
	self.demospace = args.demospace ~= '' and args.demospace or nil
	self.nsid = box.getNamespaceId(self.demospace) or self.title.namespace
end

function box:getConfig(boxType)
	-- Get the box config data from the data page.
	if boxType == 'mbox' then
		boxType = box.getMboxType(self.nsid)
	end
	local cfg = cfgTables[boxType]
	if not cfg then
		local boxTypes = {}
		for k, v in pairs(dataTables) do
			tinsert(boxTypes, format('&quot;%s&quot;', k))
		end
		tinsert(boxTypes, '&quot;mbox&quot;')
		error(format(
			'invalid message box type &quot;%s&quot;; valid types are %s',
			tostring(boxType),
			mw.text.listToText(boxTypes)
		), 2)
	end
	return cfg
end

function box:removeBlankArgs(cfg, args)
	-- Only allow blank arguments for the parameter names listed in
	-- cfg.allowBlankParams.
	local newArgs = {}
	for k, v in pairs(args) do
		if v ~= '' then
			newArgs[k] = v
		end
	end
	for i, param in ipairs(cfg.allowBlankParams or {}) do
		newArgs[param] = args[param]
	end
	return newArgs
end

function box:setBoxParameters(cfg, args)
	-- Get type data.
	self.type = args.type
	local typeData = cfg.types[self.type]
	self.invalidTypeError = cfg.showInvalidTypeError
		and self.type
		and not typeData
		and true
		or false
	typeData = typeData or cfg.types[cfg.default]
	self.typeClass = typeData.class
	self.typeImage = typeData.image

	-- Find if the box has been wrongly substituted.
	if cfg.substCheck and args.subst == 'SUBST' then
		self.isSubstituted = true
	end

	-- Find whether we are using a small message box.
	if cfg.allowSmall and (
		cfg.smallParam and args.small == cfg.smallParam
		or not cfg.smallParam and yesno(args.small)
	)
	then
		self.isSmall = true
	else
		self.isSmall = false
	end

	-- Add attributes, classes and styles.
	if cfg.allowId then
		self.id = args.id
	end
	self:addClass(
		cfg.usePlainlinksParam and yesno(args.plainlinks or true) and 'plainlinks'
	)
	for _, class in ipairs(cfg.classes or {}) do
		self:addClass(class)
	end
	if self.isSmall then
		self:addClass(cfg.smallClass or 'mbox-small')
	end
	self:addClass(self.typeClass)
	self:addClass(args.class)
	self.style = args.style
	self.attrs = args.attrs

	-- Set text style.
	self.textstyle = args.textstyle

	-- Find if we are on the template page or not. This functionality is only
	-- used if useCollapsibleTextFields is set, or if both cfg.templateCategory
	-- and cfg.templateCategoryRequireName are set.
	self.useCollapsibleTextFields = cfg.useCollapsibleTextFields
	if self.useCollapsibleTextFields
		or cfg.templateCategory
		and cfg.templateCategoryRequireName
	then
		self.name = args.name
		if self.name then
			local templateName = mw.ustring.match(
				self.name,
				'^[tT][eE][mM][pP][lL][aA][tT][eE][%s_]*:[%s_]*(.*)$'
			) or self.name
			templateName = 'Template:' .. templateName
			self.templateTitle = getTitleObject(templateName)
		end
		self.isTemplatePage = self.templateTitle
			and mw.title.equals(self.title, self.templateTitle)
			or false
	end

	-- Process data for collapsible text fields. At the moment these are only
	-- used in {{ambox}}.
	if self.useCollapsibleTextFields then
		-- Get the self.issue value.
		if self.isSmall and args.smalltext then
			self.issue = args.smalltext
		else
			local sect
			if args.sect == '' then
				sect = 'This ' .. (cfg.sectionDefault or 'page')
			elseif type(args.sect) == 'string' then
				sect = 'This ' .. args.sect
			end
			local issue = args.issue
			issue = type(issue) == 'string' and issue ~= '' and issue or nil
			local text = args.text
			text = type(text) == 'string' and text or nil
			local issues = {}
			tinsert(issues, sect)
			tinsert(issues, issue)
			tinsert(issues, text)
			self.issue = tconcat(issues, ' ')
		end

		-- Get the self.talk value.
		local talk = args.talk
		-- Show talk links on the template page or template subpages if the talk
		-- parameter is blank.
		if talk == ''
			and self.templateTitle 
			and (
				mw.title.equals(self.templateTitle, self.title)
				or self.title:isSubpageOf(self.templateTitle)
			)
		then
			talk = '#'
		elseif talk == '' then
			talk = nil
		end
		if talk then
			-- If the talk value is a talk page, make a link to that page. Else
			-- assume that it's a section heading, and make a link to the talk
			-- page of the current page with that section heading.
			local talkTitle = getTitleObject(talk)
			local talkArgIsTalkPage = true
			if not talkTitle or not talkTitle.isTalkPage then
				talkArgIsTalkPage = false
				talkTitle = getTitleObject(
					self.title.text,
					mw.site.namespaces[self.title.namespace].talk.id
				)
			end
			if talkTitle and talkTitle.exists then
				local talkText = 'Relevant discussion may be found on'
				if talkArgIsTalkPage then
					talkText = format(
						'%s [[%s|%s]].',
						talkText,
						talk,
						talkTitle.prefixedText
					)
				else
					talkText = format(
						'%s the [[%s#%s|talk page]].',
						talkText,
						talkTitle.prefixedText,
						talk
					)
				end
				self.talk = talkText
			end
		end

		-- Get other values.
		self.fix = args.fix ~= '' and args.fix or nil
		local date
		if args.date and args.date ~= '' then
			date = args.date
		elseif args.date == '' and self.isTemplatePage then
			date = lang:formatDate('F Y')
		end
		if date then
			self.date = format(&quot; &lt;small&gt;''(%s)''&lt;/small&gt;&quot;, date)
		end
		self.info = args.info
	end

	-- Set the non-collapsible text field. At the moment this is used by all box
	-- types other than ambox, and also by ambox when small=yes.
	if self.isSmall then
		self.text = args.smalltext or args.text
	else
		self.text = args.text
	end

	-- Set the below row.
	self.below = cfg.below and args.below

	-- General image settings.
	self.imageCellDiv = not self.isSmall and cfg.imageCellDiv and true or false
	self.imageEmptyCell = cfg.imageEmptyCell
	if cfg.imageEmptyCellStyle then
		self.imageEmptyCellStyle = 'border:none;padding:0px;width:1px'
	end

	-- Left image settings.
	local imageLeft = self.isSmall and args.smallimage or args.image
	if cfg.imageCheckBlank and imageLeft ~= 'blank' and imageLeft ~= 'none'
		or not cfg.imageCheckBlank and imageLeft ~= 'none'
	then
		self.imageLeft = imageLeft
		if not imageLeft then
			local imageSize = self.isSmall
				and (cfg.imageSmallSize or '30x30px')
				or '40x40px'
			self.imageLeft = format('[[File:%s|%s|link=|alt=]]', self.typeImage
				or 'Imbox notice.png', imageSize)
		end
	end

	-- Right image settings.
	local imageRight = self.isSmall and args.smallimageright or args.imageright
	if not (cfg.imageRightNone and imageRight == 'none') then
		self.imageRight = imageRight
	end

	-- Add mainspace categories. At the moment these are only used in {{ambox}}.
	if cfg.allowMainspaceCategories then
		if args.cat then
			args.cat1 = args.cat
		end
		self.catNums = getArgNums(args, 'cat')
		if args.category then
			args.category1 = args.category
		end
		self.categoryNums = getArgNums(args, 'category')
		if args.all then
			args.all1 = args.all
		end
		self.allNums = getArgNums(args, 'all')
		self.categoryParamNums = union(self.catNums, self.categoryNums)
		self.categoryParamNums = union(self.categoryParamNums, self.allNums)
		-- The following is roughly equivalent to the old {{Ambox/category}}.
		local date = args.date
		date = type(date) == 'string' and date
		local preposition = 'from'
		for _, num in ipairs(self.categoryParamNums) do
			local mainCat = args['cat' .. tostring(num)]
				or args['category' .. tostring(num)]
			local allCat = args['all' .. tostring(num)]
			mainCat = type(mainCat) == 'string' and mainCat
			allCat = type(allCat) == 'string' and allCat
			if mainCat and date and date ~= '' then
				local catTitle = format('%s %s %s', mainCat, preposition, date)
				self:addCat('main', catTitle)
				catTitle = getTitleObject('Category:' .. catTitle)
				if not catTitle or not catTitle.exists then
					self:addCat(
						'main',
						'Articles with invalid date parameter in template'
					)
				end
			elseif mainCat and (not date or date == '') then
				self:addCat('main', mainCat)
			end
			if allCat then
				self:addCat('main', allCat)
			end
		end
	end

	-- Add template-namespace categories.
	if cfg.templateCategory then
		if cfg.templateCategoryRequireName then
			if self.isTemplatePage then
				self:addCat('template', cfg.templateCategory)
			end
		elseif not self.title.isSubpage then
			self:addCat('template', cfg.templateCategory)
		end
	end

	-- Add template error category.
	if cfg.templateErrorCategory then
		local templateErrorCategory = cfg.templateErrorCategory
		local templateCat, templateSort
		if not self.name and not self.title.isSubpage then
			templateCat = templateErrorCategory
		elseif self.isTemplatePage then
			local paramsToCheck = cfg.templateErrorParamsToCheck or {}
			local count = 0
			for i, param in ipairs(paramsToCheck) do
				if not args[param] then
					count = count + 1
				end
			end
			if count &gt; 0 then
				templateCat = templateErrorCategory
				templateSort = tostring(count)
			end
			if self.categoryNums and #self.categoryNums &gt; 0 then
				templateCat = templateErrorCategory
				templateSort = 'C'
			end
		end
		self:addCat('template', templateCat, templateSort)
	end

	-- Categories for all namespaces.
	if self.invalidTypeError then
		local allSort = (self.nsid == 0 and 'Main:' or '') .. self.title.prefixedText
		self:addCat('all', 'Wikipedia message box parameter needs fixing', allSort)
	end
	if self.isSubstituted then
		self:addCat('all', 'Pages with incorrectly substituted templates')
	end

	-- Convert category tables to strings and pass them through
	-- [[Module:Category handler]].
	self.categories = categoryHandler{
		main = tconcat(self.mainCats or {}),
		template = tconcat(self.templateCats or {}),
		all = tconcat(self.allCats or {}),
		nocat = args.nocat,
		demospace = self.demospace,
		page = self.pageTitle and self.pageTitle.prefixedText or nil
	}
end

function box:export()
	local root = htmlBuilder.create()

	-- Add the subst check error.
	if self.isSubstituted and self.name then
		root
			.tag('b')
				.addClass('error')
				.wikitext(format(
					'Template &lt;code&gt;%s[[Template:%s|%s]]%s&lt;/code&gt; has been incorrectly substituted.',
					mw.text.nowiki('{{'), self.name, self.name, mw.text.nowiki('}}')
				))
	end

	-- Create the box table.
	local boxTable = root.tag('table')
	boxTable
		.attr('id', self.id)
	for i, class in ipairs(self.classes or {}) do
		boxTable
			.addClass(class)
	end
	boxTable
		.cssText(self.style)
		.attr('role', 'presentation')
	for attr, val in pairs(self.attrs or {}) do
		boxTable
			.attr(attr, val)
	end

	-- Add the left-hand image.
	local row = boxTable.tag('tr')
	if self.imageLeft then
		local imageLeftCell = row.tag('td').addClass('mbox-image')
		if self.imageCellDiv then
			-- If we are using a div, redefine imageLeftCell so that the image
			-- is inside it. Divs use style=&quot;width: 52px;&quot;, which limits the
			-- image width to 52px. If any images in a div are wider than that,
			-- they may overlap with the text or cause other display problems.
			imageLeftCell = imageLeftCell.tag('div').css('width', '52px') 
		end
		imageLeftCell
			.wikitext(self.imageLeft)
	elseif self.imageEmptyCell then
		-- Some message boxes define an empty cell if no image is specified, and
		-- some don't. The old template code in templates where empty cells are
		-- specified gives the following hint: &quot;No image. Cell with some width
		-- or padding necessary for text cell to have 100% width.&quot;
		row.tag('td')
			.addClass('mbox-empty-cell') 
			.cssText(self.imageEmptyCellStyle)
	end

	-- Add the text.
	local textCell = row.tag('td').addClass('mbox-text')
	if self.useCollapsibleTextFields then
		-- The message box uses advanced text parameters that allow things to be
		-- collapsible. At the moment, only ambox uses this.
		textCell
			.cssText(self.textstyle)
		local textCellSpan = textCell.tag('span')
		textCellSpan
			.addClass('mbox-text-span')
			.wikitext(self.issue)
		if not self.isSmall then
			textCellSpan
				.tag('span')
					.addClass('hide-when-compact')
					.wikitext(self.talk and ' ' .. self.talk)
					.wikitext(self.fix and ' ' .. self.fix)
		end
		textCellSpan
			.wikitext(self.date and ' ' .. self.date)
		if not self.isSmall then
			textCellSpan
				.tag('span')
				.addClass('hide-when-compact')
				.wikitext(self.info and ' ' .. self.info)
		end
	else
		-- Default text formatting - anything goes.
		textCell
			.cssText(self.textstyle)
			.wikitext(self.text)
	end

	-- Add the right-hand image.
	if self.imageRight then
		local imageRightCell = row.tag('td').addClass('mbox-imageright')
		if self.imageCellDiv then
			-- If we are using a div, redefine imageRightCell so that the image
			-- is inside it.
			imageRightCell = imageRightCell.tag('div').css('width', '52px')
		end
		imageRightCell
			.wikitext(self.imageRight)
	end

	-- Add the below row.
	if self.below then
		boxTable.tag('tr')
			.tag('td')
				.attr('colspan', self.imageRight and '3' or '2')
				.addClass('mbox-text')
				.cssText(self.textstyle)
				.wikitext(self.below)
	end

	-- Add error message for invalid type parameters.
	if self.invalidTypeError then
		root
			.tag('div')
				.css('text-align', 'center')
				.wikitext(format(
					'This message box is using an invalid &quot;type=%s&quot; parameter and needs fixing.',
					self.type or ''
				))
	end

	-- Add categories.
	root
		.wikitext(self.categories)

	return tostring(root)
end

local function main(boxType, args)
	local outputBox = box.new()
	outputBox:setTitle(args)
	local cfg = outputBox:getConfig(boxType)
	args = outputBox:removeBlankArgs(cfg, args)
	outputBox:setBoxParameters(cfg, args)
	return outputBox:export()
end

local function makeWrapper(boxType)
	return function (frame)
		local args = getArgs(frame, {trim = false, removeBlanks = false})
		return main(boxType, args)
	end
end

local p = {
	main = main,
	mbox = makeWrapper('mbox')
}

for boxType in pairs(cfgTables) do
	p[boxType] = makeWrapper(boxType)
end

return p</text>
      <sha1>pfxm5hq7an9zemrjcn2d276uu0xlvky</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Message box/configuration</title>
    <ns>828</ns>
    <id>40627038</id>
    <revision>
      <id>592562529</id>
      <parentid>577968366</parentid>
      <timestamp>2014-01-27T01:07:32Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>allow the hidden arg to be blank, and allow tmbox to have an id attribute, per protected edit request by [[User:Technical 13]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="5405">local ambox = {
	types = {
		speedy = {
			class = 'ambox-speedy',
			image = 'Ambox speedy deletion.png'
		},
		delete = {
			class = 'ambox-delete',
			image = 'Ambox deletion.png'
		},
		content = {
			class = 'ambox-content',
			image = 'Ambox content.png'
		},
		style = {
			class = 'ambox-style',
			image = 'Edit-clear.svg'
		},
		move = {
			class = 'ambox-move',
			image = 'Ambox move.png'
		},
		protection = {
			class = 'ambox-protection',
			image = 'Ambox protection.png'
		},
		notice = {
			class = 'ambox-notice',
			image = 'Ambox notice.png'
		}
	},
	default                     = 'notice',
	allowBlankParams            = {'talk', 'sect', 'date', 'issue', 'fix', 'subst', 'hidden'},
	allowSmall                  = true,
	smallParam                  = 'left',
	smallClass                  = 'mbox-small-left',
	substCheck                  = true,
	classes                     = {'metadata', 'plainlinks', 'ambox'},
	imageEmptyCell              = true,
	imageCheckBlank             = true,
	imageSmallSize              = '20x20px',
	imageCellDiv                = true,
	useCollapsibleTextFields    = true,
	imageRightNone              = true,
	sectionDefault              = 'article',
	allowMainspaceCategories    = true,
	templateCategory            = 'Article message templates',
        templateCategoryRequireName = true,
	templateErrorCategory       = 'Article message templates with missing parameters',
	templateErrorParamsToCheck  = {'issue', 'fix', 'subst'}
}

local cmbox = {
	types = {
		speedy = {
			class = 'cmbox-speedy',
			image = 'Cmbox deletion.png'
		},
		delete = {
			class = 'cmbox-delete',
			image = 'Cmbox deletion.png'
		},
		content = {
			class = 'cmbox-content',
			image = 'Cmbox content.png'
		},
		style = {
			class = 'cmbox-style',
			image = 'Edit-clear.svg'
		},
		move = {
			class = 'cmbox-move',
			image = 'Cmbox move.png'
		},
		protection = {
			class = 'cmbox-protection',
			image = 'Cmbox protection.png'
		},
		notice = {
			class = 'cmbox-notice',
			image = 'Cmbox notice.png'
		}
	},
	default              = 'notice',
	showInvalidTypeError = true,
	classes              = {'plainlinks', 'cmbox'},
	imageEmptyCell       = true
}

local fmbox = {
	types = {
		warning = {
			class = 'fmbox-warning',
			image = 'Cmbox deletion.png'
		},
		editnotice = {
			class = 'fmbox-editnotice',
			image = 'Imbox notice.png'
		},
		system = {
			class = 'fmbox-system',
			image = 'Imbox notice.png'
		}
	},
	default              = 'system',
	showInvalidTypeError = true,
	allowId                = true,
	classes              = {'plainlinks', 'fmbox'},
	imageEmptyCell       = false,
	imageRightNone       = false
}

local imbox = {
	types = {
		speedy = {
			class = 'imbox-speedy',
			image = 'Imbox speedy deletion.png'
		},
		delete = {
			class = 'imbox-delete',
			image = 'Imbox deletion.png'
		},
		content = {
			class = 'imbox-content',
			image = 'Imbox content.png'
		},
		style = {
			class = 'imbox-style',
			image = 'Edit-clear.svg'
		},
		move = {
			class = 'imbox-move',
			image = 'Imbox move.png'
		},
		protection = {
			class = 'imbox-protection',
			image = 'Imbox protection.png'
		},
		license = {
			class = 'imbox-license',
			image = 'Imbox license.png'
		},
		featured = {
			class = 'imbox-featured',
			image = 'Imbox featured.png'
		},
		notice = {
			class = 'imbox-notice',
			image = 'Imbox notice.png'
		}
	},
	default              = 'notice',
	showInvalidTypeError = true,
	classes              = {'imbox'},
	usePlainlinksParam   = true,
	imageEmptyCell       = true,
	below                = true,
	templateCategory     = 'File message boxes'
}

local ombox = {
	types = {
		speedy = {
			class = 'ombox-speedy',
			image = 'Imbox speedy deletion.png'
		},
		delete = {
			class = 'ombox-delete',
			image = 'Imbox deletion.png'
		},
		content = {
			class = 'ombox-content',
			image = 'Imbox content.png'
		},
		style = {
			class = 'ombox-style',
			image = 'Edit-clear.svg'
		},
		move = {
			class = 'ombox-move',
			image = 'Imbox move.png'
		},
		protection = {
			class = 'ombox-protection',
			image = 'Imbox protection.png'
		},
		notice = {
			class = 'ombox-notice',
			image = 'Imbox notice.png'
		}
	},
	default              = 'notice',
	showInvalidTypeError = true,
	classes              = {'plainlinks', 'ombox'},
	allowSmall           = true,
	imageEmptyCell       = true,
	imageRightNone       = true
}

local tmbox = {
	types = {
		speedy = {
			class = 'tmbox-speedy',
			image = 'Imbox speedy deletion.png'
		},
		delete = {
			class = 'tmbox-delete',
			image = 'Imbox deletion.png'
		},
		content = {
			class = 'tmbox-content',
			image = 'Imbox content.png'
		},
		style = {
			class = 'tmbox-style',
			image = 'Edit-clear.svg '
		},
		move = {
			class = 'tmbox-move',
			image = 'Imbox move.png'
		},
		protection = {
			class = 'tmbox-protection',
			image = 'Imbox protection.png'
		},
		notice = {
			class = 'tmbox-notice',
			image = 'Imbox notice.png'
		}
	},
	default              = 'notice',
	showInvalidTypeError = true,
	classes              = {'plainlinks', 'tmbox'},
	allowId              = true,
	allowSmall           = true,
	imageRightNone       = true,
	imageEmptyCell       = true,
	imageEmptyCellStyle  = true,
	templateCategory     = 'Talk message boxes'
}

return {
	ambox = ambox,
	cmbox = cmbox,
	fmbox = fmbox,
	imbox = imbox,
	ombox = ombox,
	tmbox = tmbox
}</text>
      <sha1>hw6xn0k5hxmx22jmgmith42r5ccwspz</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect</title>
    <ns>828</ns>
    <id>39762919</id>
    <revision>
      <id>602886406</id>
      <parentid>601020017</parentid>
      <timestamp>2014-04-05T17:01:23Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>use demopage instead of page as the main &quot;page&quot; parameter</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="5992">--[[
--------------------------------------------------------------------------------
--                                                                            --
--                            NAMESPACE DETECT                                --
--                                                                            --
-- This module implements the {{namespace detect}} template in Lua, with a    --
-- few improvements: all namespaces and all namespace aliases are supported,  --
-- and namespace names are detected automatically for the local wiki. The     --
-- module can also use the corresponding subject namespace value if it is     --
-- used on a talk page. Parameter names can be configured for different wikis --
-- by altering the values in the &quot;cfg&quot; table in                               --
-- Module:Namespace detect/config.                                            --
--                                                                            --
--------------------------------------------------------------------------------
--]]

local data = mw.loadData('Module:Namespace detect/data')
local argKeys = data.argKeys
local cfg = data.cfg
local mappings = data.mappings

local yesno = require('Module:Yesno')
local mArguments -- Lazily initialise Module:Arguments
local mTableTools -- Lazily initilalise Module:TableTools
local ustringLower = mw.ustring.lower

local p = {}

local function fetchValue(t1, t2)
	-- Fetches a value from the table t1 for the first key in array t2 where
	-- a non-nil value of t1 exists.
	for i, key in ipairs(t2) do
		local value = t1[key]
		if value ~= nil then
			return value
		end
	end
	return nil
end

local function equalsArrayValue(t, value)
	-- Returns true if value equals a value in the array t. Otherwise
	-- returns false.
	for i, arrayValue in ipairs(t) do
		if value == arrayValue then
			return true
		end
	end
	return false
end

function p.getPageObject(page)
	-- Get the page object, passing the function through pcall in case of
	-- errors, e.g. being over the expensive function count limit.
	if page then
		local success, pageObject = pcall(mw.title.new, page)
		if success then
			return pageObject
		else
			return nil
		end
	else
		return mw.title.getCurrentTitle()
	end
end

-- Provided for backward compatibility with other modules
function p.getParamMappings()
	return mappings
end

local function getNamespace(args)
	-- This function gets the namespace name from the page object.
	local page = fetchValue(args, argKeys.demopage)
	if page == '' then
		page = nil
	end
	local demospace = fetchValue(args, argKeys.demospace)
	if demospace == '' then
		demospace = nil
	end
	local subjectns = fetchValue(args, argKeys.subjectns)
	local ret
	if demospace then
		-- Handle &quot;demospace = main&quot; properly.
		if equalsArrayValue(argKeys.main, ustringLower(demospace)) then
			ret = mw.site.namespaces[0].name
		else
			ret = demospace
		end
	else
		local pageObject = p.getPageObject(page)
		if pageObject then
			if pageObject.isTalkPage then
				-- Get the subject namespace if the option is set,
				-- otherwise use &quot;talk&quot;.
				if yesno(subjectns) then
					ret = mw.site.namespaces[pageObject.namespace].subject.name
				else
					ret = 'talk'
				end
			else
				ret = pageObject.nsText
			end
		else
			return nil -- return nil if the page object doesn't exist.
		end
	end
	ret = ret:gsub('_', ' ')
	return ustringLower(ret)
end

function p._main(args)
	-- Check the parameters stored in the mappings table for any matches.
	local namespace = getNamespace(args) or 'other' -- &quot;other&quot; avoids nil table keys
	local params = mappings[namespace] or {}
	local ret = fetchValue(args, params)
	--[[
	-- If there were no matches, return parameters for other namespaces.
	-- This happens if there was no text specified for the namespace that
	-- was detected or if the demospace parameter is not a valid
	-- namespace. Note that the parameter for the detected namespace must be
	-- completely absent for this to happen, not merely blank.
	--]]
	if ret == nil then
		ret = fetchValue(args, argKeys.other)
	end
	return ret
end

function p.main(frame)
	mArguments = require('Module:Arguments')
	local args = mArguments.getArgs(frame, {removeBlanks = false})
	local ret = p._main(args)
	return ret or ''
end

function p.table(frame)
	--[[
	-- Create a wikitable of all subject namespace parameters, for
	-- documentation purposes. The talk parameter is optional, in case it
	-- needs to be excluded in the documentation.
	--]]
	
	-- Load modules and initialise variables.
	mTableTools = require('Module:TableTools')
	local namespaces = mw.site.namespaces
	local cfg = data.cfg
	local useTalk = type(frame) == 'table' 
		and type(frame.args) == 'table' 
		and yesno(frame.args.talk) -- Whether to use the talk parameter.
	
	-- Get the header names.
	local function checkValue(value, default)
		if type(value) == 'string' then
			return value
		else
			return default
		end
	end
	local nsHeader = checkValue(cfg.wikitableNamespaceHeader, 'Namespace')
	local aliasesHeader = checkValue(cfg.wikitableAliasesHeader, 'Aliases')

	-- Put the namespaces in order.
	local mappingsOrdered = {}
	for nsname, params in pairs(mappings) do
		if useTalk or nsname ~= 'talk' then
			local nsid = namespaces[nsname].id
			-- Add 1, as the array must start with 1; nsid 0 would be lost otherwise.
			nsid = nsid + 1 
			mappingsOrdered[nsid] = params
		end
	end
	mappingsOrdered = mTableTools.compressSparseArray(mappingsOrdered)

	-- Build the table.
	local ret = '{| class=&quot;wikitable&quot;'
		.. '\n|-'
		.. '\n! ' .. nsHeader
		.. '\n! ' .. aliasesHeader
	for i, params in ipairs(mappingsOrdered) do
		for j, param in ipairs(params) do
			if j == 1 then
				ret = ret .. '\n|-'
					.. '\n| &lt;code&gt;' .. param .. '&lt;/code&gt;'
					.. '\n| '
			elseif j == 2 then
				ret = ret .. '&lt;code&gt;' .. param .. '&lt;/code&gt;'
			else
				ret = ret .. ', &lt;code&gt;' .. param .. '&lt;/code&gt;'
			end
		end
	end
	ret = ret .. '\n|-'
		.. '\n|}'
	return ret
end

return p</text>
      <sha1>j7kygz1y56jpz4doq0m2c6x1td5d8ar</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect/config</title>
    <ns>828</ns>
    <id>42256703</id>
    <revision>
      <id>602886681</id>
      <parentid>602823531</parentid>
      <timestamp>2014-04-05T17:03:49Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>use cfg.demopage rather than cfg.page now that the default parameter has been changed on the /data page</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="3545">--------------------------------------------------------------------------------
--                    Namespace detect configuration data                     --
--                                                                            --
-- This module stores configuration data for Module:Namespace detect. Here    --
-- you can localise the module to your wiki's language.                       --
--                                                                            --
-- To activate a configuration item, you need to uncomment it. This means     --
-- that you need to remove the text &quot;-- &quot; at the start of the line.           --
--------------------------------------------------------------------------------

local cfg = {} -- Don't edit this line.

--------------------------------------------------------------------------------
--                              Parameter names                               --
-- These configuration items specify custom parameter names. Values added     --
-- here will work in addition to the default English parameter names.         --
-- To add one extra name, you can use this format:                            --
--                                                                            --
-- cfg.foo = 'parameter name'                                                 --
--                                                                            --
-- To add multiple names, you can use this format:                            --
--                                                                            --
-- cfg.foo = {'parameter name 1', 'parameter name 2', 'parameter name 3'}     --
--------------------------------------------------------------------------------

---- This parameter displays content for the main namespace:
-- cfg.main = 'main'

---- This parameter displays in talk namespaces:
-- cfg.talk = 'talk'

---- This parameter displays content for &quot;other&quot; namespaces (namespaces for which
---- parameters have not been specified):
-- cfg.other = 'other'

---- This parameter makes talk pages behave as though they are the corresponding
---- subject namespace. Note that this parameter is used with [[Module:Yesno]].
---- Edit that module to change the default values of &quot;yes&quot;, &quot;no&quot;, etc.
-- cfg.subjectns = 'subjectns'

---- This parameter sets a demonstration namespace:
-- cfg.demospace = 'demospace'

---- This parameter sets a specific page to compare:
cfg.demopage = 'page'

--------------------------------------------------------------------------------
--                           Table configuration                              --
-- These configuration items allow customisation of the &quot;table&quot; function,     --
-- used to generate a table of possible parameters in the module              --
-- documentation.                                                             --
--------------------------------------------------------------------------------

---- The header for the namespace column in the wikitable containing the list of
---- possible subject-space parameters.
-- cfg.wikitableNamespaceHeader = 'Namespace'

---- The header for the wikitable containing the list of possible subject-space
---- parameters.
-- cfg.wikitableAliasesHeader = 'Aliases'

--------------------------------------------------------------------------------
--                        End of configuration data                           --
--------------------------------------------------------------------------------

return cfg -- Don't edit this line.</text>
      <sha1>1o6ozz56i8q0xgyl6xa41n2v7kelhli</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect/data</title>
    <ns>828</ns>
    <id>42257476</id>
    <revision>
      <id>602886511</id>
      <parentid>602823622</parentid>
      <timestamp>2014-04-05T17:02:16Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>bug fix - use the demospace parameter as both key and value in the argKeys table</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="2569">--------------------------------------------------------------------------------
--                          Namespace detect data                             --
-- This module holds data for [[Module:Namespace detect]] to be loaded per    --
-- page, rather than per #invoke, for performance reasons.                    --
--------------------------------------------------------------------------------

local cfg = require('Module:Namespace detect/config')

local function addKey(t, key, defaultKey)
	if key ~= defaultKey then
		t[#t + 1] = key
	end
end

-- Get a table of parameters to query for each default parameter name.
-- This allows wikis to customise parameter names in the cfg table while
-- ensuring that default parameter names will always work. The cfg table
-- values can be added as a string, or as an array of strings.

local defaultKeys = {
	'main',
	'talk',
	'other',
	'subjectns',
	'demospace',
	'demopage'
}

local argKeys = {}
for i, defaultKey in ipairs(defaultKeys) do
	argKeys[defaultKey] = {defaultKey}
end

for defaultKey, t in pairs(argKeys) do
	local cfgValue = cfg[defaultKey]
	local cfgValueType = type(cfgValue)
	if cfgValueType == 'string' then
		addKey(t, cfgValue, defaultKey)
	elseif cfgValueType == 'table' then
		for i, key in ipairs(cfgValue) do
			addKey(t, key, defaultKey)
		end
	end
	cfg[defaultKey] = nil -- Free the cfg value as we don't need it any more.
end

local function getParamMappings()
	--[[
	-- Returns a table of how parameter names map to namespace names. The keys
	-- are the actual namespace names, in lower case, and the values are the
	-- possible parameter names for that namespace, also in lower case. The
	-- table entries are structured like this:
	-- {
	--   [''] = {'main'},
	--   ['wikipedia'] = {'wikipedia', 'project', 'wp'},
	--   ...
	-- }
	--]]
	local mappings = {}
	local mainNsName = mw.site.subjectNamespaces[0].name
	mainNsName = mw.ustring.lower(mainNsName)
	mappings[mainNsName] = mw.clone(argKeys.main)
	mappings['talk'] = mw.clone(argKeys.talk)
	for nsid, ns in pairs(mw.site.subjectNamespaces) do
		if nsid ~= 0 then -- Exclude main namespace.
			local nsname = mw.ustring.lower(ns.name)
			local canonicalName = mw.ustring.lower(ns.canonicalName)
			mappings[nsname] = {nsname}
			if canonicalName ~= nsname then
				table.insert(mappings[nsname], canonicalName)
			end
			for _, alias in ipairs(ns.aliases) do
				table.insert(mappings[nsname], mw.ustring.lower(alias))
			end
		end
	end
	return mappings
end

return {
	argKeys = argKeys,
	cfg = cfg,
	mappings = getParamMappings()
}</text>
      <sha1>ojp6d3pc8mql5nufaqdg576c9so3479</sha1>
    </revision>
  </page>
  <page>
    <title>Module:TableTools</title>
    <ns>828</ns>
    <id>41371028</id>
    <revision>
      <id>610073853</id>
      <parentid>587870113</parentid>
      <timestamp>2014-05-25T14:11:02Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>fix cleanPattern function - some of the character classes were still being magic even when they were inside the set, so escape them all</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="8030">--[[
------------------------------------------------------------------------------------
--                               TableTools                                       --
--                                                                                --
-- This module includes a number of functions for dealing with Lua tables.        --
-- It is a meta-module, meant to be called from other Lua modules, and should     --
-- not be called directly from #invoke.                                           --
------------------------------------------------------------------------------------
--]]

local libraryUtil = require('libraryUtil')

local p = {}

-- Define often-used variables and functions.
local floor = math.floor
local infinity = math.huge
local checkType = libraryUtil.checkType

--[[
------------------------------------------------------------------------------------
-- isPositiveInteger
--
-- This function returns true if the given value is a positive integer, and false
-- if not. Although it doesn't operate on tables, it is included here as it is
-- useful for determining whether a given table key is in the array part or the
-- hash part of a table.
------------------------------------------------------------------------------------
--]]
function p.isPositiveInteger(v)
	if type(v) == 'number' and v &gt;= 1 and floor(v) == v and v &lt; infinity then
		return true
	else
		return false
	end
end

--[[
------------------------------------------------------------------------------------
-- isNan
--
-- This function returns true if the given number is a NaN value, and false
-- if not. Although it doesn't operate on tables, it is included here as it is
-- useful for determining whether a value can be a valid table key. Lua will
-- generate an error if a NaN is used as a table key.
------------------------------------------------------------------------------------
--]]
function p.isNan(v)
	if type(v) == 'number' and tostring(v) == '-nan' then
		return true
	else
		return false
	end
end

--[[
------------------------------------------------------------------------------------
-- shallowClone
--
-- This returns a clone of a table. The value returned is a new table, but all
-- subtables and functions are shared. Metamethods are respected, but the returned
-- table will have no metatable of its own.
------------------------------------------------------------------------------------
--]]
function p.shallowClone(t)
	local ret = {}
	for k, v in pairs(t) do
		ret[k] = v
	end
	return ret
end

--[[
------------------------------------------------------------------------------------
-- removeDuplicates
--
-- This removes duplicate values from an array. Non-positive-integer keys are
-- ignored. The earliest value is kept, and all subsequent duplicate values are
-- removed, but otherwise the array order is unchanged.
------------------------------------------------------------------------------------
--]]
function p.removeDuplicates(t)
	checkType('removeDuplicates', 1, t, 'table')
	local isNan = p.isNan
	local ret, exists = {}, {}
	for i, v in ipairs(t) do
		if isNan(v) then
			-- NaNs can't be table keys, and they are also unique, so we don't need to check existence.
			ret[#ret + 1] = v
		else
			if not exists[v] then
				ret[#ret + 1] = v
				exists[v] = true
			end
		end	
	end
	return ret
end			

--[[
------------------------------------------------------------------------------------
-- numKeys
--
-- This takes a table and returns an array containing the numbers of any numerical
-- keys that have non-nil values, sorted in numerical order.
------------------------------------------------------------------------------------
--]]
function p.numKeys(t)
	checkType('numKeys', 1, t, 'table')
	local isPositiveInteger = p.isPositiveInteger
	local nums = {}
	for k, v in pairs(t) do
		if isPositiveInteger(k) then
			nums[#nums + 1] = k
		end
	end
	table.sort(nums)
	return nums
end

--[[
------------------------------------------------------------------------------------
-- affixNums
--
-- This takes a table and returns an array containing the numbers of keys with the
-- specified prefix and suffix. For example, for the table
-- {a1 = 'foo', a3 = 'bar', a6 = 'baz'} and the prefix &quot;a&quot;, affixNums will
-- return {1, 3, 6}.
------------------------------------------------------------------------------------
--]]
function p.affixNums(t, prefix, suffix)
	checkType('affixNums', 1, t, 'table')
	checkType('affixNums', 2, prefix, 'string', true)
	checkType('affixNums', 3, suffix, 'string', true)

	local function cleanPattern(s)
		-- Cleans a pattern so that the magic characters ()%.[]*+-?^$ are interpreted literally.
		s = s:gsub('([%(%)%%%.%[%]%*%+%-%?%^%$])', '%%%1')
		return s
	end

	prefix = prefix or ''
	suffix = suffix or ''
	prefix = cleanPattern(prefix)
	suffix = cleanPattern(suffix)
	local pattern = '^' .. prefix .. '([1-9]%d*)' .. suffix .. '$'

	local nums = {}
	for k, v in pairs(t) do
		if type(k) == 'string' then			
			local num = mw.ustring.match(k, pattern)
			if num then
				nums[#nums + 1] = tonumber(num)
			end
		end
	end
	table.sort(nums)
	return nums
end

--[[
------------------------------------------------------------------------------------
-- numData
--
-- Given a table with keys like (&quot;foo1&quot;, &quot;bar1&quot;, &quot;foo2&quot;, &quot;baz2&quot;), returns a table
-- of subtables in the format 
-- { [1] = {foo = 'text', bar = 'text'}, [2] = {foo = 'text', baz = 'text'} }
-- Keys that don't end with an integer are stored in a subtable named &quot;other&quot;.
-- The compress option compresses the table so that it can be iterated over with
-- ipairs.
------------------------------------------------------------------------------------
--]]
function p.numData(t, compress)
	checkType('numData', 1, t, 'table')
	checkType('numData', 2, compress, 'boolean', true)
	local ret = {}
	for k, v in pairs(t) do
		local prefix, num = mw.ustring.match(tostring(k), '^([^0-9]*)([1-9][0-9]*)$')
		if num then
			num = tonumber(num)
			local subtable = ret[num] or {}
			if prefix == '' then
				-- Positional parameters match the blank string; put them at the start of the subtable instead.
				prefix = 1
			end
			subtable[prefix] = v
			ret[num] = subtable
		else
			local subtable = ret.other or {}
			subtable[k] = v
			ret.other = subtable
		end
	end
	if compress then
		local other = ret.other
		ret = p.compressSparseArray(ret)
		ret.other = other
	end
	return ret
end

--[[
------------------------------------------------------------------------------------
-- compressSparseArray
--
-- This takes an array with one or more nil values, and removes the nil values
-- while preserving the order, so that the array can be safely traversed with
-- ipairs.
------------------------------------------------------------------------------------
--]]
function p.compressSparseArray(t)
	checkType('compressSparseArray', 1, t, 'table')
	local ret = {}
	local nums = p.numKeys(t)
	for _, num in ipairs(nums) do
		ret[#ret + 1] = t[num]
	end
	return ret
end

--[[
------------------------------------------------------------------------------------
-- sparseIpairs
--
-- This is an iterator for sparse arrays. It can be used like ipairs, but can
-- handle nil values.
------------------------------------------------------------------------------------
--]]
function p.sparseIpairs(t)
	checkType('sparseIpairs', 1, t, 'table')
	local nums = p.numKeys(t)
	local i = 0
	local lim = #nums
	return function ()
		i = i + 1
		if i &lt;= lim then
			local key = nums[i]
			return key, t[key]
		else
			return nil, nil
		end
	end
end

--[[
------------------------------------------------------------------------------------
-- size
--
-- This returns the size of a key/value pair table. It will also work on arrays,
-- but for arrays it is more efficient to use the # operator.
------------------------------------------------------------------------------------
--]]
function p.size(t)
	checkType('size', 1, t, 'table')
	local i = 0
	for k in pairs(t) do
		i = i + 1
	end
	return i
end

return p</text>
      <sha1>k1omc17qij757n8hd68yihcqxo4biqi</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Yesno</title>
    <ns>828</ns>
    <id>38665046</id>
    <revision>
      <id>604718900</id>
      <parentid>582180209</parentid>
      <timestamp>2014-04-18T10:35:42Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>use the Lua string.lower function instead of mw.ustring.lower; this makes the function around 25x faster</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="678">-- Function allowing for consistent treatment of boolean-like wikitext input.
-- It works similarly to the template {{yesno}}.

return function (val, default)
	-- If your wiki uses non-ascii characters for any of &quot;yes&quot;, &quot;no&quot;, etc., you
	-- should replace &quot;val:lower()&quot; with &quot;mw.ustring.lower(val)&quot; in the
	-- following line.
	val = type(val) == 'string' and val:lower() or val
	if val == nil then
		return nil
	elseif val == true 
		or val == 'yes'
		or val == 'y'
		or val == 'true'
		or tonumber(val) == 1
	then
		return true
	elseif val == false
		or val == 'no'
		or val == 'n'
		or val == 'false'
		or tonumber(val) == 0
	then
		return false
	else
		return default
	end
end</text>
      <sha1>ew4l88ll7bbgr20npia5rfyblzqhgyg</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ambox</title>
    <ns>10</ns>
    <id>13179742</id>
    <revision>
      <id>578398722</id>
      <parentid>578101879</parentid>
      <timestamp>2013-10-23T12:52:13Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>Undid revision 578101879 by [[Special:Contributions/Mr. Stradivarius|Mr. Stradivarius]] ([[User talk:Mr. Stradivarius|talk]]) problems with module have been fixed - trying again</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="146">{{#invoke:Message box|ambox}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>mbfrv60doj3koropyon4zrq5dhk4lij</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cmbox</title>
    <ns>10</ns>
    <id>17171798</id>
    <revision>
      <id>683948232</id>
      <parentid>577968571</parentid>
      <timestamp>2015-10-03T16:01:17Z</timestamp>
      <contributor>
        <username>NeilN</username>
        <id>409043</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cmbox: per request at [[WP:RFPP]] ([Edit=Allow only administrators] (indefinite) [Move=Allow only administrators] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="146">{{#invoke:Message box|cmbox}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>2wg1g94nws2nefrz0o1pxm105lovzoz</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Fmbox</title>
    <ns>10</ns>
    <id>19236000</id>
    <revision>
      <id>577983257</id>
      <parentid>577968772</parentid>
      <timestamp>2013-10-20T15:03:32Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>it should be [[Module:Message box]], not [[Module:Fmbox]] - the former has deprecated the latter</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="141">{{#invoke:Message box|fmbox}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>q4qfnrd9je1n71bknyj9gdhs02g2rws</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Imbox</title>
    <ns>10</ns>
    <id>17102136</id>
    <revision>
      <id>577968974</id>
      <parentid>577968896</parentid>
      <timestamp>2013-10-20T12:44:20Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Imbox: [[WP:High-risk templates|Highly visible template]]: allow template editors to edit ([Edit=Protected template] (indefinite) [Move=Protected template] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="146">{{#invoke:Message box|imbox}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>90yqkd9klfkh2s7isb6vikemdvm668g</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Mbox</title>
    <ns>10</ns>
    <id>13319244</id>
    <revision>
      <id>577968069</id>
      <parentid>498386332</parentid>
      <timestamp>2013-10-20T12:33:38Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>switch to Lua version</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="145">{{#invoke:Message box|mbox}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>mpflpb6s8l8gaoxaeypyuqyu2w7vc7i</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ombox</title>
    <ns>10</ns>
    <id>17522403</id>
    <revision>
      <id>577969039</id>
      <parentid>463278061</parentid>
      <timestamp>2013-10-20T12:45:08Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>switch to Lua version</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="146">{{#invoke:Message box|ombox}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>1o93yrjvq6v2ylug2k0uaaltljurje2</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Tmbox</title>
    <ns>10</ns>
    <id>14314129</id>
    <revision>
      <id>577969176</id>
      <parentid>388085963</parentid>
      <timestamp>2013-10-20T12:46:44Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>switch to Lua version</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="146">{{#invoke:Message box|tmbox}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>jcav8pdjkvcwg8gc4m0b4gox7yjnxku</sha1>
    </revision>
  </page>
</mediawiki>
