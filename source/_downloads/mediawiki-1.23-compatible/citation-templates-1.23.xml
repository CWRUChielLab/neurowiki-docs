<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikipedia</sitename>
    <dbname>enwiki</dbname>
    <base>https://en.wikipedia.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.27.0-wmf.9</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikipedia</namespace>
      <namespace key="5" case="first-letter">Wikipedia talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="100" case="first-letter">Portal</namespace>
      <namespace key="101" case="first-letter">Portal talk</namespace>
      <namespace key="108" case="first-letter">Book</namespace>
      <namespace key="109" case="first-letter">Book talk</namespace>
      <namespace key="118" case="first-letter">Draft</namespace>
      <namespace key="119" case="first-letter">Draft talk</namespace>
      <namespace key="446" case="first-letter">Education Program</namespace>
      <namespace key="447" case="first-letter">Education Program talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
      <namespace key="2600" case="first-letter">Topic</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Module:Citation/CS1</title>
    <ns>828</ns>
    <id>38573037</id>
    <revision>
      <id>673001028</id>
      <parentid>672305015</parentid>
      <timestamp>2015-07-25T10:24:12Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>Synch from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="145530">
local z = {
	error_categories = {};		-- for categorizing citations that contain errors
	error_ids = {};
	message_tail = {};
	maintenance_cats = {};		-- for categorizing citations that aren't erroneous per se, but could use a little work
	properties_cats = {};		-- for categorizing citations based on certain properties, language of source for instance
}

--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]
local dates, year_date_check	-- functions in Module:Citation/CS1/Date_validation

local cfg = {};					-- table of configuration tables that are defined in Module:Citation/CS1/Configuration
local whitelist = {};			-- table of tables listing valid template parameter names; defined in Module:Citation/CS1/Whitelist

--[[--------------------------&lt; I S _ S E T &gt;------------------------------------------------------------------

Returns true if argument is set; false otherwise. Argument is 'set' when it exists (not nil) or when it is not an empty string.
This function is global because it is called from both this module and from Date validation

]]
function is_set( var )
	return not (var == nil or var == '');
end

--[[--------------------------&lt; F I R S T _ S E T &gt;------------------------------------------------------------

First set variable or nil if none

]]

local function first_set(...)
	local list = {...};
	for _, var in pairs(list) do
		if is_set( var ) then
			return var;
		end
	end
end

--[[--------------------------&lt; I N _ A R R A Y &gt;--------------------------------------------------------------

Whether needle is in haystack

]]

local function in_array( needle, haystack )
	if needle == nil then
		return false;
	end
	for n,v in ipairs( haystack ) do
		if v == needle then
			return n;
		end
	end
	return false;
end

--[[--------------------------&lt; S U B S T I T U T E &gt;----------------------------------------------------------

Populates numbered arguments in a message string using an argument table.

]]

local function substitute( msg, args )
	return args and mw.message.newRawMessage( msg, args ):plain() or msg;
end

--[[--------------------------&lt; E R R O R _ C O M M E N T &gt;----------------------------------------------------

Wraps error messages with css markup according to the state of hidden.

]]
local function error_comment( content, hidden )
	return substitute( hidden and cfg.presentation['hidden-error'] or cfg.presentation['visible-error'], content );
end

--[[--------------------------&lt; S E T _ E R R O R &gt;--------------------------------------------------------------

Sets an error condition and returns the appropriate error message.  The actual placement of the error message in the output is
the responsibility of the calling function.

]]
local function set_error( error_id, arguments, raw, prefix, suffix )
	local error_state = cfg.error_conditions[ error_id ];
	
	prefix = prefix or &quot;&quot;;
	suffix = suffix or &quot;&quot;;
	
	if error_state == nil then
		error( cfg.messages['undefined_error'] );
	elseif is_set( error_state.category ) then
		table.insert( z.error_categories, error_state.category );
	end
	
	local message = substitute( error_state.message, arguments );
	
	message = message .. &quot; ([[&quot; .. cfg.messages['help page link'] .. 
		&quot;#&quot; .. error_state.anchor .. &quot;|&quot; ..
		cfg.messages['help page label'] .. &quot;]])&quot;;
	
	z.error_ids[ error_id ] = true;
	if in_array( error_id, { 'bare_url_missing_title', 'trans_missing_title' } )
			and z.error_ids['citation_missing_title'] then
		return '', false;
	end
	
	message = table.concat({ prefix, message, suffix });
	
	if raw == true then
		return message, error_state.hidden;
	end		
		
	return error_comment( message, error_state.hidden );
end

--[[--------------------------&lt; A D D _ M A I N T _ C A T &gt;------------------------------------------------------

Adds a category to z.maintenance_cats using names from the configuration file with additional text if any.
To prevent duplication, the added_maint_cats table lists the categories by key that have been added to z.maintenance_cats.

]]

local added_maint_cats = {}														-- list of maintenance categories that have been added to z.maintenance_cats
local function add_maint_cat (key, arguments)
	if not added_maint_cats [key] then
		added_maint_cats [key] = true;											-- note that we've added this category
		table.insert( z.maintenance_cats, substitute (cfg.maint_cats [key], arguments));	-- make name then add to table
	end
end

--[[--------------------------&lt; A D D _ P R O P _ C A T &gt;--------------------------------------------------------

Adds a category to z.properties_cats using names from the configuration file with additional text if any.

]]

local added_prop_cats = {}														-- list of property categories that have been added to z.properties_cats
local function add_prop_cat (key, arguments)
	if not added_prop_cats [key] then
		added_prop_cats [key] = true;											-- note that we've added this category
		table.insert( z.properties_cats, substitute (cfg.prop_cats [key], arguments));		-- make name then add to table
	end
end

--[[--------------------------&lt; A D D _ V A N C _ E R R O R &gt;----------------------------------------------------

Adds a single Vancouver system error message to the template's output regardless of how many error actually exist.
To prevent duplication, added_vanc_errs is nil until an error message is emitted.

]]

local added_vanc_errs;															-- flag so we only emit one Vancouver error / category
local function add_vanc_error ()
	if not added_vanc_errs then
		added_vanc_errs = true;													-- note that we've added this category
		table.insert( z.message_tail, { set_error( 'vancouver', {}, true ) } );
	end
end

--[[--------------------------&lt; C H E C K _ U R L &gt;------------------------------------------------------------

Determines whether a URL string is valid.

At present the only check is whether the string appears to be prefixed with a URI scheme.  It is not determined whether 
the URI scheme is valid or whether the URL is otherwise well formed.

]]

local function check_url( url_str )
	return url_str:sub(1,2) == &quot;//&quot; or url_str:match( &quot;^[^/]*:&quot; ) ~= nil;		-- Protocol-relative or URL scheme
end

--[[--------------------------&lt; S A F E _ F O R _ I T A L I C S &gt;----------------------------------------------

Protects a string that will be wrapped in wiki italic markup '' ... ''

Note: We cannot use &lt;i&gt; for italics, as the expected behavior for italics specified by ''...'' in the title is that
they will be inverted (i.e. unitalicized) in the resulting references.  In addition, &lt;i&gt; and '' tend to interact
poorly under Mediawiki's HTML tidy.

]]

local function safe_for_italics( str )
	if not is_set(str) then
		return str;
	else
		if str:sub(1,1) == &quot;'&quot; then str = &quot;&lt;span /&gt;&quot; .. str; end
		if str:sub(-1,-1) == &quot;'&quot; then str = str .. &quot;&lt;span /&gt;&quot;; end
		
		-- Remove newlines as they break italics.
		return str:gsub( '\n', ' ' );
	end
end

--[[--------------------------&lt; S A F E _ F O R _ U R L &gt;------------------------------------------------------

Escape sequences for content that will be used for URL descriptions

]]

local function safe_for_url( str )
	if str:match( &quot;%[%[.-%]%]&quot; ) ~= nil then 
		table.insert( z.message_tail, { set_error( 'wikilink_in_url', {}, true ) } );
	end
	
	return str:gsub( '[%[%]\n]', {	
		['['] = '&amp;#91;',
		[']'] = '&amp;#93;',
		['\n'] = ' ' } );
end

--[[--------------------------&lt; W R A P _ S T Y L E &gt;----------------------------------------------------------

Applies styling to various parameters.  Supplied string is wrapped using a message_list configuration taking one
argument; protects italic styled parameters.  Additional text taken from citation_config.presentation - the reason
this function is similar to but separate from wrap_msg().

]]

local function wrap_style (key, str)
	if not is_set( str ) then
		return &quot;&quot;;
	elseif in_array( key, { 'italic-title', 'trans-italic-title' } ) then
		str = safe_for_italics( str );
	end

	return substitute( cfg.presentation[key], {str} );
end

--[[--------------------------&lt; E X T E R N A L _ L I N K &gt;----------------------------------------------------

Format an external link with error checking

]]

local function external_link( URL, label, source )
	local error_str = &quot;&quot;;
	if not is_set( label ) then
		label = URL;
		if is_set( source ) then
			error_str = set_error( 'bare_url_missing_title', { wrap_style ('parameter', source) }, false, &quot; &quot; );
		else
			error( cfg.messages[&quot;bare_url_no_origin&quot;] );
		end			
	end
	if not check_url( URL ) then
		error_str = set_error( 'bad_url', {}, false, &quot; &quot; ) .. error_str;
	end
	return table.concat({ &quot;[&quot;, URL, &quot; &quot;, safe_for_url( label ), &quot;]&quot;, error_str });
end

--[[--------------------------&lt; E X T E R N A L _ L I N K _ I D &gt;----------------------------------------------

Formats a wiki style external link

]]

local function external_link_id(options)
	local url_string = options.id;
	if options.encode == true or options.encode == nil then
		url_string = mw.uri.encode( url_string );
	end
	return mw.ustring.format( '[[%s|%s]]%s[%s%s%s %s]',
		options.link, options.label, options.separator or &quot;&amp;nbsp;&quot;,
		options.prefix, url_string, options.suffix or &quot;&quot;,
		mw.text.nowiki(options.id)
	);
end

--[[--------------------------&lt; D E P R E C A T E D _ P A R A M E T E R &gt;--------------------------------------

Categorize and emit an error message when the citation contains one or more deprecated parameters.  The function includes the
offending parameter name to the error message.  Only one error message is emitted regardless of the number of deprecated
parameters in the citation.

]]

local page_in_deprecated_cat;													-- sticky flag so that the category is added only once
local function deprecated_parameter(name)
	if not page_in_deprecated_cat then
		page_in_deprecated_cat = true;											-- note that we've added this category
		table.insert( z.message_tail, { set_error( 'deprecated_params', {name}, true ) } );		-- add error message
	end
end

--[[--------------------------&lt; K E R N _ Q U O T E S &gt;--------------------------------------------------------

Apply kerning to open the space between the quote mark provided by the Module and a leading or trailing quote mark contained in a |title= or |chapter= parameter's value.
This function will positive kern either single or double quotes:
	&quot;'Unkerned title with leading and trailing single quote marks'&quot;
	&quot; 'Kerned title with leading and trailing single quote marks' &quot; (in real life the kerning isn't as wide as this example)
Double single quotes (italic or bold wikimarkup) are not kerned.

Call this function for chapter titles, for website titles, etc; not for book titles.

]]

local function kern_quotes (str)
	local cap='';
	local cap2='';
	
	cap, cap2 = str:match (&quot;^([\&quot;\'])([^\'].+)&quot;);								-- match leading double or single quote but not double single quotes
	if is_set (cap) then
		str = substitute (cfg.presentation['kern-left'], {cap, cap2});
	end

	cap, cap2 = str:match (&quot;^(.+[^\'])([\&quot;\'])$&quot;)
	if is_set (cap) then
		str = substitute (cfg.presentation['kern-right'], {cap, cap2});
	end
	return str;
end

--[[--------------------------&lt; F O R M A T _ S C R I P T _ V A L U E &gt;----------------------------------------

|script-title= holds title parameters that are not written in Latin based scripts: Chinese, Japanese, Arabic, Hebrew, etc. These scripts should
not be italicized and may be written right-to-left.  The value supplied by |script-title= is concatenated onto Title after Title has been wrapped
in italic markup.

Regardless of language, all values provided by |script-title= are wrapped in &lt;bdi&gt;...&lt;/bdi&gt; tags to isolate rtl languages from the English left to right.

|script-title= provides a unique feature.  The value in |script-title= may be prefixed with a two-character ISO639-1 language code and a colon:
	|script-title=ja:*** *** (where * represents a Japanese character)
Spaces between the two-character code and the colon and the colon and the first script character are allowed:
	|script-title=ja : *** ***
	|script-title=ja: *** ***
	|script-title=ja :*** ***
Spaces preceding the prefix are allowed: |script-title = ja:*** ***

The prefix is checked for validity.  If it is a valid ISO639-1 language code, the lang attribute (lang=&quot;ja&quot;) is added to the &lt;bdi&gt; tag so that browsers can
know the language the tag contains.  This may help the browser render the script more correctly.  If the prefix is invalid, the lang attribute
is not added.  At this time there is no error message for this condition.

At this writing, only |script-title= is supported.  It is anticipated that additional parameters will be created to use this function.

TODO: error messages when prefix is invalid ISO639-1 code; when script_value has prefix but no script;
]]

local function format_script_value (script_value)
	local lang='';																-- initialize to empty string
	local name;
	if script_value:match('^%l%l%s*:') then										-- if first 3 non-space characters are script language prefix
		lang = script_value:match('^(%l%l)%s*:%s*%S.*');						-- get the language prefix or nil if there is no script
		if not is_set (lang) then
			return '';															-- script_value was just the prefix so return empty string
		end
																				-- if we get this far we have prefix and script
		name = mw.language.fetchLanguageName( lang, &quot;en&quot; );						-- get language name so that we can use it to categorize
		if is_set (name) then													-- is prefix a proper ISO 639-1 language code?
			script_value = script_value:gsub ('^%l%l%s*:%s*', '');				-- strip prefix from script
																				-- is prefix one of these language codes?
			if in_array (lang, {'ar', 'bg', 'bs', 'dv', 'el', 'fa', 'hy', 'ja', 'ka', 'ko', 'ku', 'he', 'ps', 'ru', 'sd', 'sr', 'th', 'uk', 'ug', 'yi', 'zh'}) then
				add_prop_cat ('script_with_name', {name, lang})
			else
				add_prop_cat ('script')
			end
			lang = ' lang=&quot;' .. lang .. '&quot; ';									-- convert prefix into a lang attribute
		else
			lang = '';															-- invalid so set lang to empty string
		end
	end
	script_value = substitute (cfg.presentation['bdi'], {lang, script_value});	-- isolate in case script is rtl

	return script_value;
end

--[[--------------------------&lt; S C R I P T _ C O N C A T E N A T E &gt;------------------------------------------

Initially for |title= and |script-title=, this function concatenates those two parameter values after the script value has been 
wrapped in &lt;bdi&gt; tags.
]]

local function script_concatenate (title, script)
	if is_set (script) then
		script = format_script_value (script);									-- &lt;bdi&gt; tags, lang atribute, categorization, etc; returns empty string on error
		if is_set (script) then
			title = title .. ' ' .. script;										-- concatenate title and script title
		end
	end
	return title;
end


--[[--------------------------&lt; W R A P _ M S G &gt;--------------------------------------------------------------

Applies additional message text to various parameter values. Supplied string is wrapped using a message_list
configuration taking one argument.  Supports lower case text for {{citation}} templates.  Additional text taken
from citation_config.messages - the reason this function is similar to but separate from wrap_style().

]]

local function wrap_msg (key, str, lower)
	if not is_set( str ) then
		return &quot;&quot;;
	end
	if true == lower then
		local msg;
		msg = cfg.messages[key]:lower();										-- set the message to lower case before 
		str = substitute( msg, {str} );											-- including template text
		return str;
	else
		return substitute( cfg.messages[key], {str} );
	end		
end

--[[--------------------------&lt; S E L E C T _ O N E &gt;----------------------------------------------------------

Chooses one matching parameter from a list of parameters to consider
Generates an error if more than one match is present.

]]

local function select_one( args, possible, error_condition, index )
	local value = nil;
	local selected = '';
	local error_list = {};
	
	if index ~= nil then index = tostring(index); end
	
	-- Handle special case of &quot;#&quot; replaced by empty string
	if index == '1' then
		for _, v in ipairs( possible ) do
			v = v:gsub( &quot;#&quot;, &quot;&quot; );
			if is_set(args[v]) then
				if value ~= nil and selected ~= v then
					table.insert( error_list, v );
				else
					value = args[v];
					selected = v;
				end
			end
		end		
	end
	
	for _, v in ipairs( possible ) do
		if index ~= nil then
			v = v:gsub( &quot;#&quot;, index );
		end
		if is_set(args[v]) then
			if value ~= nil and selected ~=  v then
				table.insert( error_list, v );
			else
				value = args[v];
				selected = v;
			end
		end
	end
	
	if #error_list &gt; 0 then
		local error_str = &quot;&quot;;
		for _, k in ipairs( error_list ) do
			if error_str ~= &quot;&quot; then error_str = error_str .. cfg.messages['parameter-separator'] end
			error_str = error_str .. wrap_style ('parameter', k);
		end
		if #error_list &gt; 1 then
			error_str = error_str .. cfg.messages['parameter-final-separator'];
		else
			error_str = error_str .. cfg.messages['parameter-pair-separator'];
		end
		error_str = error_str .. wrap_style ('parameter', selected);
		table.insert( z.message_tail, { set_error( error_condition, {error_str}, true ) } );
	end
	
	return value, selected;
end

--[[--------------------------&lt; F O R M A T _ C H A P T E R _ T I T L E &gt;--------------------------------------

Format the three chapter parameters: |chapter=, |trans-chapter=, and |chapter-url= into a single Chapter meta-
parameter (chapter_url_source used for error messages).

]]

local function format_chapter_title (chapter, transchapter, chapterurl, chapter_url_source)
	local chapter_error = '';
	
	if not is_set (chapter) then
		chapter = '';															-- just to be safe for concatenation
		if is_set (transchapter) then
			chapter = wrap_style ('trans-quoted-title', transchapter);
			chapter_error = &quot; &quot; .. set_error ('trans_missing_chapter');
		end
		if is_set (chapterurl) then
			chapter = external_link (chapterurl, chapter, chapter_url_source);	-- adds bare_url_missing_title error if appropriate
		end
		return chapter .. chapter_error;
	else																		-- here when chapter is set
		chapter = kern_quotes (chapter);										-- if necessary, separate chapter title's leading and trailing quote marks from Module provided quote marks
		chapter = wrap_style ('quoted-title', chapter);
		if is_set (transchapter) then
			transchapter = wrap_style ('trans-quoted-title', transchapter);
			chapter = chapter .. ' ' .. transchapter;
		end
		if is_set (chapterurl) then
			chapter = external_link (chapterurl, chapter);						-- adds bare_url_missing_title error if appropriate
		end
	end
	return chapter;
end

--[[
Argument wrapper.  This function provides support for argument 
mapping defined in the configuration file so that multiple names
can be transparently aliased to single internal variable.
]]

local function argument_wrapper( args )
	local origin = {};
	
	return setmetatable({
		ORIGIN = function( self, k )
			local dummy = self[k]; --force the variable to be loaded.
			return origin[k];
		end
	},
	{
		__index = function ( tbl, k )
			if origin[k] ~= nil then
				return nil;
			end
			
			local args, list, v = args, cfg.aliases[k];
			
			if type( list ) == 'table' then
				v, origin[k] = select_one( args, list, 'redundant_parameters' );
				if origin[k] == nil then
					origin[k] = ''; -- Empty string, not nil
				end
			elseif list ~= nil then
				v, origin[k] = args[list], list;
			else
				-- maybe let through instead of raising an error?
				-- v, origin[k] = args[k], k;
				error( cfg.messages['unknown_argument_map'] );
			end
			
			-- Empty strings, not nil;
			if v == nil then
				v = cfg.defaults[k] or '';
				origin[k] = '';
			end
			
			tbl = rawset( tbl, k, v );
			return v;
		end,
	});
end

--[[
Looks for a parameter's name in the whitelist.

Parameters in the whitelist can have three values:
	true - active, supported parameters
	false - deprecated, supported parameters
	nil - unsupported parameters
]]

local function validate( name )
	local name = tostring( name );
	local state = whitelist.basic_arguments[ name ];
	
	-- Normal arguments
	if true == state then return true; end		-- valid actively supported parameter
	if false == state then
		deprecated_parameter (name);				-- parameter is deprecated but still supported
		return true;
	end
	
	-- Arguments with numbers in them
	name = name:gsub( &quot;%d+&quot;, &quot;#&quot; );				-- replace digit(s) with # (last25 becomes last#
	state = whitelist.numbered_arguments[ name ];
	if true == state then return true; end		-- valid actively supported parameter
	if false == state then
		deprecated_parameter (name);				-- parameter is deprecated but still supported
		return true;
	end
	
	return false;								-- Not supported because not found or name is set to nil
end


-- Formats a wiki style internal link
local function internal_link_id(options)
	return mw.ustring.format( '[[%s|%s]]%s[[%s%s%s|%s]]',
		options.link, options.label, options.separator or &quot;&amp;nbsp;&quot;,
		options.prefix, options.id, options.suffix or &quot;&quot;,
		mw.text.nowiki(options.id)
	);
end


--[[--------------------------&lt; N O W R A P _ D A T E &gt;--------------------------------------------------------

When date is YYYY-MM-DD format wrap in nowrap span: &lt;span ...&gt;YYYY-MM-DD&lt;/span&gt;.  When date is DD MMMM YYYY or is
MMMM DD, YYYY then wrap in nowrap span: &lt;span ...&gt;DD MMMM&lt;/span&gt; YYYY or &lt;span ...&gt;MMMM DD,&lt;/span&gt; YYYY

DOES NOT yet support MMMM YYYY or any of the date ranges.

]]

local function nowrap_date (date)
	local cap='';
	local cap2='';

	if date:match(&quot;^%d%d%d%d%-%d%d%-%d%d$&quot;) then
		date = substitute (cfg.presentation['nowrap1'], date);
	
	elseif date:match(&quot;^%a+%s*%d%d?,%s*%d%d%d%d$&quot;) or date:match (&quot;^%d%d?%s*%a+%s*%d%d%d%d$&quot;) then
		cap, cap2 = string.match (date, &quot;^(.*)%s+(%d%d%d%d)$&quot;);
		date = substitute (cfg.presentation['nowrap2'], {cap, cap2});
	end
	
	return date;
end

--[[--------------------------&lt; IS _ V A L I D _ I S X N &gt;-----------------------------------------------------

ISBN-10 and ISSN validator code calculates checksum across all isbn/issn digits including the check digit. ISBN-13 is checked in check_isbn().
If the number is valid the result will be 0. Before calling this function, issbn/issn must be checked for length and stripped of dashes,
spaces and other non-isxn characters.

]]

local function is_valid_isxn (isxn_str, len)
	local temp = 0;
	isxn_str = { isxn_str:byte(1, len) };	-- make a table of byte values '0' → 0x30 .. '9'  → 0x39, 'X' → 0x58
	len = len+1;							-- adjust to be a loop counter
	for i, v in ipairs( isxn_str ) do		-- loop through all of the bytes and calculate the checksum
		if v == string.byte( &quot;X&quot; ) then		-- if checkdigit is X (compares the byte value of 'X' which is 0x58)
			temp = temp + 10*( len - i );	-- it represents 10 decimal
		else
			temp = temp + tonumber( string.char(v) )*(len-i);
		end
	end
	return temp % 11 == 0;					-- returns true if calculation result is zero
end


--[[--------------------------&lt; IS _ V A L I D _ I S X N  _ 1 3 &gt;----------------------------------------------

ISBN-13 and ISMN validator code calculates checksum across all 13 isbn/ismn digits including the check digit.
If the number is valid, the result will be 0. Before calling this function, isbn-13/ismn must be checked for length
and stripped of dashes, spaces and other non-isxn-13 characters.

]]

local function is_valid_isxn_13 (isxn_str)
	local temp=0;
	
	isxn_str = { isxn_str:byte(1, 13) };										-- make a table of byte values '0' → 0x30 .. '9'  → 0x39
	for i, v in ipairs( isxn_str ) do
		temp = temp + (3 - 2*(i % 2)) * tonumber( string.char(v) );				-- multiply odd index digits by 1, even index digits by 3 and sum; includes check digit
	end
	return temp % 10 == 0;														-- sum modulo 10 is zero when isbn-13/ismn is correct
end

--[[--------------------------&lt; C H E C K _ I S B N &gt;------------------------------------------------------------

Determines whether an ISBN string is valid

]]

local function check_isbn( isbn_str )
	if nil ~= isbn_str:match(&quot;[^%s-0-9X]&quot;) then return false; end		-- fail if isbn_str contains anything but digits, hyphens, or the uppercase X
	isbn_str = isbn_str:gsub( &quot;-&quot;, &quot;&quot; ):gsub( &quot; &quot;, &quot;&quot; );	-- remove hyphens and spaces
	local len = isbn_str:len();
 
	if len ~= 10 and len ~= 13 then
		return false;
	end

	if len == 10 then
		if isbn_str:match( &quot;^%d*X?$&quot; ) == nil then return false; end
		return is_valid_isxn(isbn_str, 10);
	else
		local temp = 0;
		if isbn_str:match( &quot;^97[89]%d*$&quot; ) == nil then return false; end		-- isbn13 begins with 978 or 979; ismn begins with 979
		return is_valid_isxn_13 (isbn_str);
	end
end

--[[--------------------------&lt; C H E C K _ I S M N &gt;------------------------------------------------------------

Determines whether an ISMN string is valid.  Similar to isbn-13, ismn is 13 digits begining 979-0-... and uses the
same check digit calculations.  See http://www.ismn-international.org/download/Web_ISMN_Users_Manual_2008-6.pdf
section 2, pages 9–12.

]]

local function ismn (id)
	local handler = cfg.id_handlers['ISMN'];
	local text;
	local valid_ismn = true;

	id=id:gsub( &quot;[%s-–]&quot;, &quot;&quot; );													-- strip spaces, hyphens, and endashes from the ismn

	if 13 ~= id:len() or id:match( &quot;^9790%d*$&quot; ) == nil then					-- ismn must be 13 digits and begin 9790
		valid_ismn = false;
	else
		valid_ismn=is_valid_isxn_13 (id);										-- validate ismn
	end

--	text = internal_link_id({link = handler.link, label = handler.label,		-- use this (or external version) when there is some place to link to
--		prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode})
 
	text=&quot;[[&quot; .. handler.link .. &quot;|&quot; .. handler.label .. &quot;]]:&quot; .. handler.separator .. id;		-- because no place to link to yet

	if false == valid_ismn then
		text = text .. ' ' .. set_error( 'bad_ismn' )							-- add an error message if the issn is invalid
	end 
	
	return text;
end

--[[--------------------------&lt; I S S N &gt;----------------------------------------------------------------------

Validate and format an issn.  This code fixes the case where an editor has included an ISSN in the citation but has separated the two groups of four
digits with a space.  When that condition occurred, the resulting link looked like this:

	|issn=0819 4327 gives: [http://www.worldcat.org/issn/0819 4327 0819 4327]  -- can't have spaces in an external link
	
This code now prevents that by inserting a hyphen at the issn midpoint.  It also validates the issn for length and makes sure that the checkdigit agrees
with the calculated value.  Incorrect length (8 digits), characters other than 0-9 and X, or checkdigit / calculated value mismatch will all cause a check issn
error message.  The issn is always displayed with a hyphen, even if the issn was given as a single group of 8 digits.

]]

local function issn(id)
	local issn_copy = id;		-- save a copy of unadulterated issn; use this version for display if issn does not validate
	local handler = cfg.id_handlers['ISSN'];
	local text;
	local valid_issn = true;

	id=id:gsub( &quot;[%s-–]&quot;, &quot;&quot; );									-- strip spaces, hyphens, and endashes from the issn

	if 8 ~= id:len() or nil == id:match( &quot;^%d*X?$&quot; ) then		-- validate the issn: 8 digits long, containing only 0-9 or X in the last position
		valid_issn=false;										-- wrong length or improper character
	else
		valid_issn=is_valid_isxn(id, 8);						-- validate issn
	end

	if true == valid_issn then
		id = string.sub( id, 1, 4 ) .. &quot;-&quot; .. string.sub( id, 5 );	-- if valid, display correctly formatted version
	else
		id = issn_copy;											-- if not valid, use the show the invalid issn with error message
	end
	
	text = external_link_id({link = handler.link, label = handler.label,
		prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode})
 
	if false == valid_issn then
		text = text .. ' ' .. set_error( 'bad_issn' )			-- add an error message if the issn is invalid
	end 
	
	return text
end

--[[--------------------------&lt; A M A Z O N &gt;------------------------------------------------------------------

Formats a link to Amazon.  Do simple error checking: asin must be mix of 10 numeric or uppercase alpha
characters.  If a mix, first character must be uppercase alpha; if all numeric, asins must be 10-digit
isbn. If 10-digit isbn, add a maintenance category so a bot or awb script can replace |asin= with |isbn=.
Error message if not 10 characters, if not isbn10, if mixed and first character is a digit.

]]

local function amazon(id, domain)
	local err_cat = &quot;&quot;

	if not id:match(&quot;^[%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u]$&quot;) then
		err_cat =  ' ' .. set_error ('bad_asin');								-- asin is not a mix of 10 uppercase alpha and numeric characters
	else
		if id:match(&quot;^%d%d%d%d%d%d%d%d%d[%dX]$&quot;) then								-- if 10-digit numeric (or 9 digits with terminal X)
			if check_isbn( id ) then												-- see if asin value is isbn10
				add_maint_cat ('ASIN');
			elseif not is_set (err_cat) then
				err_cat =  ' ' .. set_error ('bad_asin');						-- asin is not isbn10
			end
		elseif not id:match(&quot;^%u[%d%u]+$&quot;) then
			err_cat =  ' ' .. set_error ('bad_asin');							-- asin doesn't begin with uppercase alpha
		end
	end
	if not is_set(domain) then 
		domain = &quot;com&quot;;
	elseif in_array (domain, {'jp', 'uk'}) then			-- Japan, United Kingdom
		domain = &quot;co.&quot; .. domain;
	elseif in_array (domain, {'au', 'br', 'mx'}) then	-- Australia, Brazil, Mexico
		domain = &quot;com.&quot; .. domain;
	end
	local handler = cfg.id_handlers['ASIN'];
	return external_link_id({link = handler.link,
		label=handler.label , prefix=&quot;//www.amazon.&quot;..domain..&quot;/dp/&quot;,id=id,
		encode=handler.encode, separator = handler.separator}) .. err_cat;
end

--[[--------------------------&lt; A R X I V &gt;--------------------------------------------------------------------

See: http://arxiv.org/help/arxiv_identifier

format and error check arXiv identifier.  There are three valid forms of the identifier:
the first form, valid only between date codes 9108 and 0703 is:
	arXiv:&lt;archive&gt;.&lt;class&gt;/&lt;date code&gt;&lt;number&gt;&lt;version&gt;
where:
	&lt;archive&gt; is a string of alpha characters - may be hyphenated; no other punctuation
	&lt;class&gt; is a string of alpha characters - may be hyphenated; no other punctuation
	&lt;date code&gt; is four digits in the form YYMM where YY is the last two digits of the four-digit year and MM is the month number January = 01
		first digit of YY for this form can only 9 and 0
	&lt;number&gt; is a three-digit number
	&lt;version&gt; is a 1 or more digit number preceded with a lowercase v; no spaces (undocumented)
	
the second form, valid from April 2007 through December 2014 is:
	arXiv:&lt;date code&gt;.&lt;number&gt;&lt;version&gt;
where:
	&lt;date code&gt; is four digits in the form YYMM where YY is the last two digits of the four-digit year and MM is the month number January = 01
	&lt;number&gt; is a four-digit number
	&lt;version&gt; is a 1 or more digit number preceded with a lowercase v; no spaces

the third form, valid from January 2015 is:
	arXiv:&lt;date code&gt;.&lt;number&gt;&lt;version&gt;
where:
	&lt;date code&gt; and &lt;version&gt; are as defined for 0704-1412
	&lt;number&gt; is a five-digit number
]]

local function arxiv (id, class)
	local handler = cfg.id_handlers['ARXIV'];
	local year, month, version;
	local err_cat = '';
	local text;
	
	if id:match(&quot;^%a[%a%.%-]+/[90]%d[01]%d%d%d%d$&quot;) or id:match(&quot;^%a[%a%.%-]+/[90]%d[01]%d%d%d%dv%d+$&quot;) then	-- test for the 9108-0703 format w/ &amp; w/o version
		year, month = id:match(&quot;^%a[%a%.%-]+/([90]%d)([01]%d)%d%d%d[v%d]*$&quot;);
		year = tonumber(year);
		month = tonumber(month);
		if ((not (90 &lt; year or 8 &gt; year)) or (1 &gt; month or 12 &lt; month)) or		-- if invalid year or invalid month
			((91 == year and 7 &gt; month) or (7 == year and 3 &lt; month)) then		-- if years ok, are starting and ending months ok?
				err_cat = ' ' .. set_error( 'bad_arxiv' );						-- set error message
		end
	elseif id:match(&quot;^%d%d[01]%d%.%d%d%d%d$&quot;) or id:match(&quot;^%d%d[01]%d%.%d%d%d%dv%d+$&quot;) then	-- test for the 0704-1412 w/ &amp; w/o version
		year, month = id:match(&quot;^(%d%d)([01]%d)%.%d%d%d%d[v%d]*$&quot;);
		year = tonumber(year);
		month = tonumber(month);
		if ((7 &gt; year) or (14 &lt; year) or (1 &gt; month or 12 &lt; month)) or			-- is year invalid or is month invalid? (doesn't test for future years)
			((7 == year) and (4 &gt; month)) then --or									-- when year is 07, is month invalid (before April)?
				err_cat = ' ' .. set_error( 'bad_arxiv' );						-- set error message
		end
	elseif id:match(&quot;^%d%d[01]%d%.%d%d%d%d%d$&quot;) or id:match(&quot;^%d%d[01]%d%.%d%d%d%d%dv%d+$&quot;) then	-- test for the 1501- format w/ &amp; w/o version
		year, month = id:match(&quot;^(%d%d)([01]%d)%.%d%d%d%d%d[v%d]*$&quot;);
		year = tonumber(year);
		month = tonumber(month);
		if ((15 &gt; year) or (1 &gt; month or 12 &lt; month)) then						-- is year invalid or is month invalid? (doesn't test for future years)
			err_cat = ' ' .. set_error( 'bad_arxiv' );							-- set error message
		end
	else
		err_cat = ' ' .. set_error( 'bad_arxiv' );								-- arXiv id doesn't match any format
	end

	text = external_link_id({link = handler.link, label = handler.label,
			prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode}) .. err_cat;

	if is_set (class) then
		class = ' [[' .. '//arxiv.org/archive/' .. class .. ' ' .. class .. ']]';	-- external link within square brackets, not wikilink
	else
		class = '';																-- empty string for concatenation
	end
	
	return text .. class;
end

--[[
lccn normalization (http://www.loc.gov/marc/lccn-namespace.html#normalization)
1. Remove all blanks.
2. If there is a forward slash (/) in the string, remove it, and remove all characters to the right of the forward slash.
3. If there is a hyphen in the string:
	a. Remove it.
	b. Inspect the substring following (to the right of) the (removed) hyphen. Then (and assuming that steps 1 and 2 have been carried out):
		1. All these characters should be digits, and there should be six or less. (not done in this function)
		2. If the length of the substring is less than 6, left-fill the substring with zeroes until the length is six.

Returns a normalized lccn for lccn() to validate.  There is no error checking (step 3.b.1) performed in this function.
]]

local function normalize_lccn (lccn)
	lccn = lccn:gsub (&quot;%s&quot;, &quot;&quot;);									-- 1. strip whitespace

	if nil ~= string.find (lccn,'/') then
		lccn = lccn:match (&quot;(.-)/&quot;);								-- 2. remove forward slash and all character to the right of it
	end

	local prefix
	local suffix
	prefix, suffix = lccn:match (&quot;(.+)%-(.+)&quot;);						-- 3.a remove hyphen by splitting the string into prefix and suffix

	if nil ~= suffix then											-- if there was a hyphen
		suffix=string.rep(&quot;0&quot;, 6-string.len (suffix)) .. suffix;	-- 3.b.2 left fill the suffix with 0s if suffix length less than 6
		lccn=prefix..suffix;										-- reassemble the lccn
	end
	
	return lccn;
	end

--[[
Format LCCN link and do simple error checking.  LCCN is a character string 8-12 characters long. The length of the LCCN dictates the character type of the first 1-3 characters; the
rightmost eight are always digits. http://info-uri.info/registry/OAIHandler?verb=GetRecord&amp;metadataPrefix=reg&amp;identifier=info:lccn/

length = 8 then all digits
length = 9 then lccn[1] is lower case alpha
length = 10 then lccn[1] and lccn[2] are both lower case alpha or both digits
length = 11 then lccn[1] is lower case alpha, lccn[2] and lccn[3] are both lower case alpha or both digits
length = 12 then lccn[1] and lccn[2] are both lower case alpha

]]

local function lccn(lccn)
	local handler = cfg.id_handlers['LCCN'];
	local err_cat =  '';								-- presume that LCCN is valid
	local id = lccn;									-- local copy of the lccn

	id = normalize_lccn (id);							-- get canonical form (no whitespace, hyphens, forward slashes)
	local len = id:len();								-- get the length of the lccn

	if 8 == len then
		if id:match(&quot;[^%d]&quot;) then						-- if LCCN has anything but digits (nil if only digits)
			err_cat = ' ' .. set_error( 'bad_lccn' );	-- set an error message
		end
	elseif 9 == len then								-- LCCN should be adddddddd
		if nil == id:match(&quot;%l%d%d%d%d%d%d%d%d&quot;) then			-- does it match our pattern?
			err_cat = ' ' .. set_error( 'bad_lccn' );	-- set an error message
		end
	elseif 10 == len then								-- LCCN should be aadddddddd or dddddddddd
		if id:match(&quot;[^%d]&quot;) then							-- if LCCN has anything but digits (nil if only digits) ...
			if nil == id:match(&quot;^%l%l%d%d%d%d%d%d%d%d&quot;) then	-- ... see if it matches our pattern
				err_cat = ' ' .. set_error( 'bad_lccn' );	-- no match, set an error message
			end
		end
	elseif 11 == len then								-- LCCN should be aaadddddddd or adddddddddd
		if not (id:match(&quot;^%l%l%l%d%d%d%d%d%d%d%d&quot;) or id:match(&quot;^%l%d%d%d%d%d%d%d%d%d%d&quot;)) then	-- see if it matches one of our patterns
			err_cat = ' ' .. set_error( 'bad_lccn' );	-- no match, set an error message
		end
	elseif 12 == len then								-- LCCN should be aadddddddddd
		if not id:match(&quot;^%l%l%d%d%d%d%d%d%d%d%d%d&quot;) then	-- see if it matches our pattern
			err_cat = ' ' .. set_error( 'bad_lccn' );	-- no match, set an error message
		end
	else
		err_cat = ' ' .. set_error( 'bad_lccn' );		-- wrong length, set an error message
	end

	if not is_set (err_cat) and nil ~= lccn:find ('%s') then
		err_cat = ' ' .. set_error( 'bad_lccn' );		-- lccn contains a space, set an error message
	end

	return external_link_id({link = handler.link, label = handler.label,
			prefix=handler.prefix,id=lccn,separator=handler.separator, encode=handler.encode}) .. err_cat;
end

--[[
Format PMID and do simple error checking.  PMIDs are sequential numbers beginning at 1 and counting up.  This code checks the PMID to see that it
contains only digits and is less than test_limit; the value in local variable test_limit will need to be updated periodically as more PMIDs are issued.
]]

local function pmid(id)
	local test_limit = 30000000;						-- update this value as PMIDs approach
	local handler = cfg.id_handlers['PMID'];
	local err_cat =  '';								-- presume that PMID is valid
	
	if id:match(&quot;[^%d]&quot;) then							-- if PMID has anything but digits
		err_cat = ' ' .. set_error( 'bad_pmid' );		-- set an error message
	else												-- PMID is only digits
		local id_num = tonumber(id);					-- convert id to a number for range testing
		if 1 &gt; id_num or test_limit &lt; id_num then		-- if PMID is outside test limit boundaries
			err_cat = ' ' .. set_error( 'bad_pmid' );	-- set an error message
		end
	end
	
	return external_link_id({link = handler.link, label = handler.label,
			prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode}) .. err_cat;
end

--[[--------------------------&lt; I S _ E M B A R G O E D &gt;------------------------------------------------------

Determines if a PMC identifier's online version is embargoed. Compares the date in |embargo= against today's date.  If embargo date is
in the future, returns the content of |embargo=; otherwise, returns and empty string because the embargo has expired or because
|embargo= was not set in this cite.

]]

local function is_embargoed (embargo)
	if is_set (embargo) then
		local lang = mw.getContentLanguage();
		local good1, embargo_date, good2, todays_date;
		good1, embargo_date = pcall( lang.formatDate, lang, 'U', embargo );
		good2, todays_date = pcall( lang.formatDate, lang, 'U' );
	
		if good1 and good2 then													-- if embargo date and today's date are good dates
			if tonumber( embargo_date ) &gt;= tonumber( todays_date ) then			-- is embargo date is in the future?
				return embargo;													-- still embargoed
			else
				add_maint_cat ('embargo')
				return '';														-- unset because embargo has expired
			end
		end
	end
	return '';																	-- |embargo= not set return empty string
end

--[[--------------------------&lt; P M C &gt;------------------------------------------------------------------------

Format a PMC, do simple error checking, and check for embargoed articles.

The embargo parameter takes a date for a value. If the embargo date is in the future the PMC identifier will not
be linked to the article.  If the embargo date is today or in the past, or if it is empty or omitted, then the
PMC identifier is linked to the article through the link at cfg.id_handlers['PMC'].prefix.

PMC embargo date testing is done in function is_embargoed () which is called earlier because when the citation
has |pmc=&lt;value&gt; but does not have a |url= then |title= is linked with the PMC link.  Function is_embargoed ()
returns the embargo date if the PMC article is still embargoed, otherwise it returns an empty string.

PMCs are sequential numbers beginning at 1 and counting up.  This code checks the PMC to see that it contains only digits and is less
than test_limit; the value in local variable test_limit will need to be updated periodically as more PMCs are issued.

]]

local function pmc(id, embargo)
	local test_limit = 5000000;							-- update this value as PMCs approach
	local handler = cfg.id_handlers['PMC'];
	local err_cat =  '';								-- presume that PMC is valid
	
	local text;

	if id:match(&quot;[^%d]&quot;) then							-- if PMC has anything but digits
		err_cat = ' ' .. set_error( 'bad_pmc' );			-- set an error message
	else												-- PMC is only digits
		local id_num = tonumber(id);					-- convert id to a number for range testing
		if 1 &gt; id_num or test_limit &lt; id_num then		-- if PMC is outside test limit boundaries
			err_cat = ' ' .. set_error( 'bad_pmc' );		-- set an error message
		end
	end
	
	if is_set (embargo) then													-- is PMC is still embargoed?
		text=&quot;[[&quot; .. handler.link .. &quot;|&quot; .. handler.label .. &quot;]]:&quot; .. handler.separator .. id .. err_cat;	-- still embargoed so no external link
	else
		text = external_link_id({link = handler.link, label = handler.label,			-- no embargo date or embargo has expired, ok to link to article
			prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode}) .. err_cat;
	end
	return text;
end

-- Formats a DOI and checks for DOI errors.

-- DOI names contain two parts: prefix and suffix separated by a forward slash.
--  Prefix: directory indicator '10.' followed by a registrant code
--  Suffix: character string of any length chosen by the registrant

-- This function checks a DOI name for: prefix/suffix.  If the doi name contains spaces or endashes,
-- or, if it ends with a period or a comma, this function will emit a bad_doi error message.

-- DOI names are case-insensitive and can incorporate any printable Unicode characters so the test for spaces, endash,
-- and terminal punctuation may not be technically correct but it appears, that in practice these characters are rarely if ever used in doi names.

local function doi(id, inactive)
	local cat = &quot;&quot;
	local handler = cfg.id_handlers['DOI'];
	
	local text;
	if is_set(inactive) then
		local inactive_year = inactive:match(&quot;%d%d%d%d&quot;) or '';		-- try to get the year portion from the inactive date
		text = &quot;[[&quot; .. handler.link .. &quot;|&quot; .. handler.label .. &quot;]]:&quot; .. id;
		if is_set(inactive_year) then
			table.insert( z.error_categories, &quot;Pages with DOIs inactive since &quot; .. inactive_year );
		else
			table.insert( z.error_categories, &quot;Pages with inactive DOIs&quot; );	-- when inactive doesn't contain a recognizable year
		end
		inactive = &quot; (&quot; .. cfg.messages['inactive'] .. &quot; &quot; .. inactive .. &quot;)&quot; 
	else 
		text = external_link_id({link = handler.link, label = handler.label,
			prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode})
		inactive = &quot;&quot; 
	end

	if nil == id:match(&quot;^10%.[^%s–]-/[^%s–]-[^%.,]$&quot;) then	-- doi must begin with '10.', must contain a fwd slash, must not contain spaces or endashes, and must not end with period or comma
		cat = ' ' .. set_error( 'bad_doi' );
	end
	return text .. inactive .. cat 
end

-- Formats an OpenLibrary link, and checks for associated errors.
local function openlibrary(id)
	local code = id:match(&quot;^%d+([AMW])$&quot;);					-- only digits followed by 'A', 'M', or 'W'
	local handler = cfg.id_handlers['OL'];

	if ( code == &quot;A&quot; ) then
		return external_link_id({link=handler.link, label=handler.label,
			prefix=&quot;http://openlibrary.org/authors/OL&quot;,id=id, separator=handler.separator,
			encode = handler.encode})
	elseif ( code == &quot;M&quot; ) then
		return external_link_id({link=handler.link, label=handler.label,
			prefix=&quot;http://openlibrary.org/books/OL&quot;,id=id, separator=handler.separator,
			encode = handler.encode})
	elseif ( code == &quot;W&quot; ) then
		return external_link_id({link=handler.link, label=handler.label,
			prefix= &quot;http://openlibrary.org/works/OL&quot;,id=id, separator=handler.separator,
			encode = handler.encode})
	else
		return external_link_id({link=handler.link, label=handler.label,
			prefix= &quot;http://openlibrary.org/OL&quot;,id=id, separator=handler.separator,
			encode = handler.encode}) .. 
			' ' .. set_error( 'bad_ol' );
	end
end


--[[--------------------------&lt; M E S S A G E _ I D &gt;----------------------------------------------------------

Validate and format a usenet message id.  Simple error checking, looks for 'id-left@id-right' not enclosed in
'&lt;' and/or '&gt;' angle brackets.

]]

local function message_id (id)
	local handler = cfg.id_handlers['USENETID'];

	text = external_link_id({link = handler.link, label = handler.label,
		prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode})
 
	if not id:match('^.+@.+$') or not id:match('^[^&lt;].*[^&gt;]$')then				-- doesn't have '@' or has one or first or last character is '&lt; or '&gt;'
		text = text .. ' ' .. set_error( 'bad_message_id' )						-- add an error message if the message id is invalid
	end 
	
	return text
end

--[[--------------------------&lt; S E T _ T I T L E T Y P E &gt;----------------------------------------------------

This function sets default title types (equivalent to the citation including |type=&lt;default value&gt;) for those templates that have defaults.
Also handles the special case where it is desirable to omit the title type from the rendered citation (|type=none).

]]

local function set_titletype (cite_class, title_type)
	if is_set(title_type) then
		if &quot;none&quot; == title_type then
			title_type = &quot;&quot;;													-- if |type=none then type parameter not displayed
		end
		return title_type;														-- if |type= has been set to any other value use that value
	end

	return cfg.title_types [cite_class] or '';									-- set template's default title type; else empty string for concatenation
end

--[[--------------------------&lt; C L E A N _ I S B N &gt;----------------------------------------------------------

Removes irrelevant text and dashes from ISBN number
Similar to that used for Special:BookSources

]]

local function clean_isbn( isbn_str )
	return isbn_str:gsub( &quot;[^-0-9X]&quot;, &quot;&quot; );
end

--[[--------------------------&lt; E S C A P E _ L U A _ M A G I C _ C H A R S &gt;----------------------------------

Returns a string where all of lua's magic characters have been escaped.  This is important because functions like
string.gsub() treat their pattern and replace strings as patterns, not literal strings.
]]
local function escape_lua_magic_chars (argument)
	argument = argument:gsub(&quot;%%&quot;, &quot;%%%%&quot;);										-- replace % with %%
	argument = argument:gsub(&quot;([%^%$%(%)%.%[%]%*%+%-%?])&quot;, &quot;%%%1&quot;);				-- replace all other lua magic pattern characters
	return argument;
end

--[[--------------------------&lt; S T R I P _ A P O S T R O P H E _ M A R K U P &gt;--------------------------------

Strip wiki italic and bold markup from argument so that it doesn't contaminate COinS metadata.
This function strips common patterns of apostrophe markup.  We presume that editors who have taken the time to
markup a title have, as a result, provided valid markup. When they don't, some single apostrophes are left behind.

]]

local function strip_apostrophe_markup (argument)
	if not is_set (argument) then return argument; end

	while true do
		if argument:match (&quot;%'%'%'%'%'&quot;) then									-- bold italic (5)
			argument=argument:gsub(&quot;%'%'%'%'%'&quot;, &quot;&quot;);							-- remove all instances of it
		elseif argument:match (&quot;%'%'%'%'&quot;) then									-- italic start and end without content (4)
			argument=argument:gsub(&quot;%'%'%'%'&quot;, &quot;&quot;);
		elseif argument:match (&quot;%'%'%'&quot;) then									-- bold (3)
			argument=argument:gsub(&quot;%'%'%'&quot;, &quot;&quot;);
		elseif argument:match (&quot;%'%'&quot;) then										-- italic (2)
			argument=argument:gsub(&quot;%'%'&quot;, &quot;&quot;);
		else
			break;
		end
	end
	return argument;															-- done
end

--[[--------------------------&lt; M A K E _ C O I N S _ T I T L E &gt;----------------------------------------------

Makes a title for COinS from Title and / or ScriptTitle (or any other name-script pairs)

Apostrophe markup (bold, italics) is stripped from each value so that the COinS metadata isn't correupted with strings
of %27%27...
]]

local function make_coins_title (title, script)
	if is_set (title) then
		title = strip_apostrophe_markup (title);								-- strip any apostrophe markup
	else
		title='';																-- if not set, make sure title is an empty string
	end
	if is_set (script) then
		script = script:gsub ('^%l%l%s*:%s*', '');								-- remove language prefix if present (script value may now be empty string)
		script = strip_apostrophe_markup (script);								-- strip any apostrophe markup
	else
		script='';																-- if not set, make sure script is an empty string
	end
	if is_set (title) and is_set (script) then
		script = ' ' .. script;													-- add a space before we concatenate
	end
	return title .. script;														-- return the concatenation
end

--[[--------------------------&lt; G E T _ C O I N S _ P A G E S &gt;------------------------------------------------

Extract page numbers from external wikilinks in any of the |page=, |pages=, or |at= parameters for use in COinS.

]]

local function get_coins_pages (pages)
	local pattern;
	if not is_set (pages) then return pages; end								-- if no page numbers then we're done
	
	while true do
		pattern = pages:match(&quot;%[(%w*:?//[^ ]+%s+)[%w%d].*%]&quot;);					-- pattern is the opening bracket, the url and following space(s): &quot;[url &quot;
		if nil == pattern then break; end										-- no more urls
		pattern = escape_lua_magic_chars (pattern);								-- pattern is not a literal string; escape lua's magic pattern characters
		pages = pages:gsub(pattern, &quot;&quot;);										-- remove as many instances of pattern as possible
	end
	pages = pages:gsub(&quot;[%[%]]&quot;, &quot;&quot;);											-- remove the brackets
	pages = pages:gsub(&quot;–&quot;, &quot;-&quot; );							-- replace endashes with hyphens
	pages = pages:gsub(&quot;&amp;%w+;&quot;, &quot;-&quot; );						-- and replace html entities (&amp;ndash; etc.) with hyphens; do we need to replace numerical entities like &amp;#32; and the like?
	return pages;
end

-- Gets the display text for a wikilink like [[A|B]] or [[B]] gives B
local function remove_wiki_link( str )
	return (str:gsub( &quot;%[%[([^%[%]]*)%]%]&quot;, function(l)
		return l:gsub( &quot;^[^|]*|(.*)$&quot;, &quot;%1&quot; ):gsub(&quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;);
	end));
end

-- Converts a hyphen to a dash
local function hyphen_to_dash( str )
	if not is_set(str) or str:match( &quot;[%[%]{}&lt;&gt;]&quot; ) ~= nil then
		return str;
	end	
	return str:gsub( '-', '–' );
end

--[[--------------------------&lt; S A F E _ J O I N &gt;------------------------------------------------------------

Joins a sequence of strings together while checking for duplicate separation characters.

]]

local function safe_join( tbl, duplicate_char )
	--[[
	Note: we use string functions here, rather than ustring functions.
	
	This has considerably faster performance and should work correctly as 
	long as the duplicate_char is strict ASCII.  The strings
	in tbl may be ASCII or UTF8.
	]]
	
	local str = '';																-- the output string
	local comp = '';															-- what does 'comp' mean?
	local end_chr = '';
	local trim;
	for _, value in ipairs( tbl ) do
		if value == nil then value = ''; end
		
		if str == '' then														-- if output string is empty
			str = value;														-- assign value to it (first time through the loop)
		elseif value ~= '' then
			if value:sub(1,1) == '&lt;' then										-- Special case of values enclosed in spans and other markup.
				comp = value:gsub( &quot;%b&lt;&gt;&quot;, &quot;&quot; );								-- remove html markup (&lt;span&gt;string&lt;/span&gt; -&gt; string)
			else
				comp = value;
			end
																				-- typically duplicate_char is sepc
			if comp:sub(1,1) == duplicate_char then								-- is first charactier same as duplicate_char? why test first character?
																				--   Because individual string segments often (always?) begin with terminal punct for th
																				--   preceding segment: 'First element' .. 'sepc next element' .. etc?
				trim = false;
				end_chr = str:sub(-1,-1);										-- get the last character of the output string
				-- str = str .. &quot;&lt;HERE(enchr=&quot; .. end_chr.. &quot;)&quot;					-- debug stuff?
				if end_chr == duplicate_char then								-- if same as separator
					str = str:sub(1,-2);										-- remove it
				elseif end_chr == &quot;'&quot; then										-- if it might be wikimarkup
					if str:sub(-3,-1) == duplicate_char .. &quot;''&quot; then			-- if last three chars of str are sepc'' 
						str = str:sub(1, -4) .. &quot;''&quot;;							-- remove them and add back ''
					elseif str:sub(-5,-1) == duplicate_char .. &quot;]]''&quot; then		-- if last five chars of str are sepc]]'' 
						trim = true;											-- why? why do this and next differently from previous?
					elseif str:sub(-4,-1) == duplicate_char .. &quot;]''&quot; then		-- if last four chars of str are sepc]'' 
						trim = true;											-- same question
					end
				elseif end_chr == &quot;]&quot; then										-- if it might be wikimarkup
					if str:sub(-3,-1) == duplicate_char .. &quot;]]&quot; then			-- if last three chars of str are sepc]] wikilink 
						trim = true;
					elseif str:sub(-2,-1) == duplicate_char .. &quot;]&quot; then			-- if last two chars of str are sepc] external link
						trim = true;
					elseif str:sub(-4,-1) == duplicate_char .. &quot;'']&quot; then		-- normal case when |url=something &amp; |title=Title.
						trim = true;
					end
				elseif end_chr == &quot; &quot; then										-- if last char of output string is a space
					if str:sub(-2,-1) == duplicate_char .. &quot; &quot; then				-- if last two chars of str are &lt;sepc&gt;&lt;space&gt;
						str = str:sub(1,-3);									-- remove them both
					end
				end

				if trim then
					if value ~= comp then 										-- value does not equal comp when value contains html markup
						local dup2 = duplicate_char;
						if dup2:match( &quot;%A&quot; ) then dup2 = &quot;%&quot; .. dup2; end		-- if duplicate_char not a letter then escape it
						
						value = value:gsub( &quot;(%b&lt;&gt;)&quot; .. dup2, &quot;%1&quot;, 1 )			-- remove duplicate_char if it follows html markup
					else
						value = value:sub( 2, -1 );								-- remove duplicate_char when it is first character
					end
				end
			end
			str = str .. value;													--add it to the output string
		end
	end
	return str;
end  

--[[--------------------------&lt; I S _ G O O D _ V A N C _ N A M E &gt;--------------------------------------------

For Vancouver Style, author/editor names are supposed to be rendered in Latin (read ASCII) characters.  When a name
uses characters that contain diacritical marks, those characters are to converted to the corresponding Latin character.
When a name is written using a non-Latin alphabet or logogram, that name is to be transliterated into Latin characters.
These things are not currently possible in this module so are left to the editor to do.

This test allows |first= and |last= names to contain any of the letters defined in the four Unicode Latin character sets
	[http://www.unicode.org/charts/PDF/U0000.pdf C0 Controls and Basic Latin] 0041–005A, 0061–007A
	[http://www.unicode.org/charts/PDF/U0080.pdf C1 Controls and Latin-1 Supplement] 00C0–00D6, 00D8–00F6, 00F8–00FF
	[http://www.unicode.org/charts/PDF/U0100.pdf Latin Extended-A] 0100–017F
	[http://www.unicode.org/charts/PDF/U0180.pdf Latin Extended-B] 0180–01BF, 01C4–024F

|lastn= also allowed to contain hyphens, spaces, and apostrophes. (http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35029/)
|firstn= also allowed to contain hyphens, spaces, apostrophes, and periods

At the time of this writing, I had to write the 'if nil == mw.ustring.find ...' test ouside of the code editor and paste it here
because the code editor gets confused between character insertion point and cursor position.

]]

local function is_good_vanc_name (last, first)
	if nil == mw.ustring.find (last, &quot;^[A-Za-zÀ-ÖØ-öø-ƿǄ-ɏ%-%s%']*$&quot;) or nil == mw.ustring.find (first, &quot;^[A-Za-zÀ-ÖØ-öø-ƿǄ-ɏ%-%s%'%.]*$&quot;) then
		add_vanc_error ();
		return false;															-- not a string of latin characters; Vancouver required Romanization
	end;
	return true;
end

--[[--------------------------&lt; R E D U C E _ T O _ I N I T I A L S &gt;------------------------------------------

Attempts to convert names to initials in support of |name-list-format=vanc.  

Names in |firstn= may be separated by spaces or hyphens, or for initials, a period. See http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35062/.

Vancouver style requires family rank designations (Jr, II, III, etc) to be rendered as Jr, 2nd, 3rd, etc.  This form is not
currently supported by this code so correctly formed names like Smith JL 2nd are converted to Smith J2. See http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35085/.

This function uses ustring functions because firstname initials may be any of the unicode Latin characters accepted by is_good_vanc_name ().

]]

local function reduce_to_initials(first)
	if mw.ustring.match(first, &quot;^%u%u$&quot;) then return first end;					-- when first contains just two upper-case letters, nothing to do
	local initials = {}
	local i = 0;																-- counter for number of initials
	for word in mw.ustring.gmatch(first, &quot;[^%s%.%-]+&quot;) do						-- names separated by spaces, hyphens, or periods
		table.insert(initials, mw.ustring.sub(word,1,1))						-- Vancouver format does not include full stops.
		i = i + 1;																-- bump the counter 
		if 2 &lt;= i then break; end												-- only two initials allowed in Vancouver system; if 2, quit
	end
	return table.concat(initials)												-- Vancouver format does not include spaces.
end

--[[--------------------------&lt; L I S T  _ P E O P L E &gt;-------------------------------------------------------

Formats a list of people (e.g. authors / editors) 

]]

local function list_people(control, people, etal)
	local sep;
	local namesep;
	local format = control.format
	local maximum = control.maximum
	local lastauthoramp = control.lastauthoramp;
	local text = {}

	if 'vanc' == format then													-- Vancouver-like author/editor name styling?
		sep = ',';																-- name-list separator between authors is a comma
		namesep = ' ';															-- last/first separator is a space
	else
		sep = ';'																-- name-list separator between authors is a semicolon
		namesep = ', '															-- last/first separator is &lt;comma&gt;&lt;space&gt;
	end
	
	if sep:sub(-1,-1) ~= &quot; &quot; then sep = sep .. &quot; &quot; end
	if is_set (maximum) and maximum &lt; 1 then return &quot;&quot;, 0; end					-- returned 0 is for EditorCount; not used for authors
	
	for i,person in ipairs(people) do
		if is_set(person.last) then
			local mask = person.mask
			local one
			local sep_one = sep;
			if is_set (maximum) and i &gt; maximum then
				etal = true;
				break;
			elseif (mask ~= nil) then
				local n = tonumber(mask)
				if (n ~= nil) then
					one = string.rep(&quot;&amp;mdash;&quot;,n)
				else
					one = mask;
					sep_one = &quot; &quot;;
				end
			else
				one = person.last
				local first = person.first
				if is_set(first) then 
					if ( &quot;vanc&quot; == format ) then								-- if vancouver format
						one = one:gsub ('%.', '');								-- remove periods from surnames (http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35029/)
						if not person.corporate and is_good_vanc_name (one, first) then					-- and name is all Latin characters; corporate authors not tested
							first = reduce_to_initials(first)					-- attempt to convert first name(s) to initials
						end
					end
					one = one .. namesep .. first 
				end
				if is_set(person.link) and person.link ~= control.page_name then
					one = &quot;[[&quot; .. person.link .. &quot;|&quot; .. one .. &quot;]]&quot;				-- link author/editor if this page is not the author's/editor's page
				end

				if is_set(person.link) and ((nil ~= person.link:find(&quot;//&quot;)) or (nil ~= person.link:find(&quot;[%[%]]&quot;))) then
					one = one .. &quot; &quot; .. set_error( 'bad_authorlink' ) end		-- url or wikilink in author link;
			end
			table.insert( text, one )
			table.insert( text, sep_one )
		end
	end

	local count = #text / 2;													-- (number of names + number of separators) divided by 2
	if count &gt; 0 then 
		if count &gt; 1 and is_set(lastauthoramp) and not etal then
			text[#text-2] = &quot; &amp; &quot;;												-- replace last separator with ampersand text
		end
		text[#text] = nil;														-- erase the last separator
	end
	
	local result = table.concat(text)											-- construct list
	if etal and is_set (result) then											-- etal may be set by |display-authors=etal but we might not have a last-first list
		result = result .. ' ' .. cfg.messages['et al'];						-- we've go a last-first list and etal so add et al.
	end
	
	return result, count
end

--[[--------------------------&lt; A N C H O R _ I D &gt;------------------------------------------------------------

Generates a CITEREF anchor ID if we have at least one name or a date.  Otherwise returns an empty string.

]]

local function anchor_id( options )
	local id = table.concat( options );											-- concatenate names and year for CITEREF id
	if is_set (id) then															-- if concatenation is not an empty string
		return &quot;CITEREF&quot; .. id;													-- add the CITEREF portion
	else
		return '';																-- return an empty string; no reason to include CITEREF id in this citation
	end
end

--[[--------------------------&lt; N A M E _ H A S _ E T A L &gt;----------------------------------------------------

Evaluates the content of author and editor name parameters for variations on the theme eof et al.  If found,
the et al. is removed, a flag is set to true and the function returns the modified name and the flag.

This function never sets the flag to false but returns it's previous state because it may have been set by
previous passes through this function or by the parameters |display-authors=etal or |displayeditors=etal

]]

local function name_has_etal (name, etal, nocat)

	if is_set (name) then														-- name can be nil in which case just return
		local pattern = &quot;[;,]? *[\&quot;']*%f[Ee][Ee][Tt] *[Aa][Ll][%.\&quot;']*$&quot;		-- variations on the 'et al' theme
		
		if name:match (pattern) then											-- variants on et al.
			name = name:gsub (pattern, '');										-- if found, remove
			etal = true;														-- set flag (may have been set previously here or by |display-authors=etal)
			if not nocat then													-- no categorization for |vauthors=
				add_maint_cat ('etal');											-- and add a category if not already added
			end
		end
	end
	return name, etal;															-- 
end

--[[--------------------------&lt; E X T R A C T _ N A M E S &gt;----------------------------------------------------
Gets name list from the input arguments

Searches through args in sequential order to find |lastn= and |firstn= parameters (or their aliases), and their matching link and mask parameters.
Stops searching when both |lastn= and |firstn= are not found in args after two sequential attempts: found |last1=, |last2=, and |last3= but doesn't
find |last4= and |last5= then the search is done.

This function emits an error message when there is a |firstn= without a matching |lastn=.  When there are 'holes' in the list of last names, |last1= and |last3=
are present but |last2= is missing, an error message is emitted. |lastn= is not required to have a matching |firstn=.

When an author or editor parameter contains some form of 'et al.', the 'et al.' is stripped from the parameter and a flag (etal) returned
that will cause list_people() to add the static 'et al.' text from Module:Citation/CS1/Configuration.  This keeps 'et al.' out of the 
template's metadata.  When this occurs, the page is added to a maintenance category.

]]

local function extract_names(args, list_name)
	local names = {};			-- table of names
	local last;					-- individual name components
	local first;
	local link;
	local mask;
	local i = 1;				-- loop counter/indexer
	local n = 1;				-- output table indexer
	local count = 0;			-- used to count the number of times we haven't found a |last= (or alias for authors, |editor-last or alias for editors)
	local etal=false;			-- return value set to true when we find some form of et al. in an author parameter

	local err_msg_list_name = list_name:match (&quot;(%w+)List&quot;) .. 's list';		-- modify AuthorList or EditorList for use in error messages if necessary

	while true do
		last = select_one( args, cfg.aliases[list_name .. '-Last'], 'redundant_parameters', i );		-- search through args for name components beginning at 1
		first = select_one( args, cfg.aliases[list_name .. '-First'], 'redundant_parameters', i );
		link = select_one( args, cfg.aliases[list_name .. '-Link'], 'redundant_parameters', i );
		mask = select_one( args, cfg.aliases[list_name .. '-Mask'], 'redundant_parameters', i );

		last, etal = name_has_etal (last, etal, false);								-- find and remove variations on et al.
		first, etal = name_has_etal (first, etal, false);								-- find and remove variations on et al.

		if first and not last then												-- if there is a firstn without a matching lastn
			table.insert( z.message_tail, { set_error( 'first_missing_last', {err_msg_list_name, i}, true ) } );	-- add this error message
		elseif not first and not last then										-- if both firstn and lastn aren't found, are we done?
			count = count + 1;													-- number of times we haven't found last and first
			if 2 &lt;= count then													-- two missing names and we give up
				break;															-- normal exit or there is a two-name hole in the list; can't tell which
			end
		else																	-- we have last with or without a first
			names[n] = {last = last, first = first, link = link, mask = mask, corporate=false};	-- add this name to our names list (corporate for |vauthors= only)
			n = n + 1;															-- point to next location in the names table
			if 1 == count then													-- if the previous name was missing
				table.insert( z.message_tail, { set_error( 'missing_name', {err_msg_list_name, i-1}, true ) } );		-- add this error message
			end
			count = 0;															-- reset the counter, we're looking for two consecutive missing names
		end
		i = i + 1;																-- point to next args location
	end
	
	return names, etal;															-- all done, return our list of names
end

-- Populates ID table from arguments using configuration settings
local function extract_ids( args )
	local id_list = {};
	for k, v in pairs( cfg.id_handlers ) do	
		v = select_one( args, v.parameters, 'redundant_parameters' );
		if is_set(v) then id_list[k] = v; end
	end
	return id_list;
end

--[[--------------------------&lt; B U I L D _ I D _ L I S T &gt;--------------------------------------------------------

Takes a table of IDs and turns it into a table of formatted ID outputs.

]]

local function build_id_list( id_list, options )
	local new_list, handler = {};

	function fallback(k) return { __index = function(t,i) return cfg.id_handlers[k][i] end } end;
	
	for k, v in pairs( id_list ) do
		-- fallback to read-only cfg
		handler = setmetatable( { ['id'] = v }, fallback(k) );
		
		if handler.mode == 'external' then
			table.insert( new_list, {handler.label, external_link_id( handler ) } );
		elseif handler.mode == 'internal' then
			table.insert( new_list, {handler.label, internal_link_id( handler ) } );
		elseif handler.mode ~= 'manual' then
			error( cfg.messages['unknown_ID_mode'] );
		elseif k == 'DOI' then
			table.insert( new_list, {handler.label, doi( v, options.DoiBroken ) } );
		elseif k == 'ARXIV' then
			table.insert( new_list, {handler.label, arxiv( v, options.Class ) } ); 
		elseif k == 'ASIN' then
			table.insert( new_list, {handler.label, amazon( v, options.ASINTLD ) } ); 
		elseif k == 'LCCN' then
			table.insert( new_list, {handler.label, lccn( v ) } );
		elseif k == 'OL' then
			table.insert( new_list, {handler.label, openlibrary( v ) } );
		elseif k == 'PMC' then
			table.insert( new_list, {handler.label, pmc( v, options.Embargo ) } );
		elseif k == 'PMID' then
			table.insert( new_list, {handler.label, pmid( v ) } );
		elseif k == 'ISMN' then
			table.insert( new_list, {handler.label, ismn( v ) } );
		elseif k == 'ISSN' then
			table.insert( new_list, {handler.label, issn( v ) } );
		elseif k == 'ISBN' then
			local ISBN = internal_link_id( handler );
			if not check_isbn( v ) and not is_set(options.IgnoreISBN) then
				ISBN = ISBN .. set_error( 'bad_isbn', {}, false, &quot; &quot;, &quot;&quot; );
			end
			table.insert( new_list, {handler.label, ISBN } );				
		elseif k == 'USENETID' then
			table.insert( new_list, {handler.label, message_id( v ) } );
		else
			error( cfg.messages['unknown_manual_ID'] );
		end
	end
	
	function comp( a, b )	-- used in following table.sort()
		return a[1] &lt; b[1];
	end
	
	table.sort( new_list, comp );
	for k, v in ipairs( new_list ) do
		new_list[k] = v[2];
	end
	
	return new_list;
end
  

-- COinS metadata (see &lt;http://ocoins.info/&gt;) allows automated tools to parse
-- the citation information.
local function COinS(data, class)
	if 'table' ~= type(data) or nil == next(data) then
		return '';
	end
	
	local ctx_ver = &quot;Z39.88-2004&quot;;
	
	-- treat table strictly as an array with only set values.
	local OCinSoutput = setmetatable( {}, {
		__newindex = function(self, key, value)
			if is_set(value) then
				rawset( self, #self+1, table.concat{ key, '=', mw.uri.encode( remove_wiki_link( value ) ) } );
			end
		end
	});
	
	if is_set(data.Chapter) then
		OCinSoutput.rft_val_fmt = &quot;info:ofi/fmt:kev:mtx:book&quot;;
		OCinSoutput[&quot;rft.genre&quot;] = &quot;bookitem&quot;;
		OCinSoutput[&quot;rft.atitle&quot;] = data.Chapter;
		OCinSoutput[&quot;rft.btitle&quot;] = data.Title;
	elseif is_set(data.Periodical) then
		OCinSoutput.rft_val_fmt = &quot;info:ofi/fmt:kev:mtx:journal&quot;;
		if 'arxiv' == class then
			OCinSoutput[&quot;rft.genre&quot;] = &quot;preprint&quot;;								-- cite arxiv
		else
			OCinSoutput[&quot;rft.genre&quot;] = &quot;article&quot;;
		end
		OCinSoutput[&quot;rft.jtitle&quot;] = data.Periodical;
		OCinSoutput[&quot;rft.atitle&quot;] = data.Title;
	else
		OCinSoutput.rft_val_fmt = &quot;info:ofi/fmt:kev:mtx:book&quot;;
		OCinSoutput[&quot;rft.genre&quot;] = &quot;book&quot;
		OCinSoutput[&quot;rft.btitle&quot;] = data.Title;
	end
	
	OCinSoutput[&quot;rft.place&quot;] = data.PublicationPlace;
	OCinSoutput[&quot;rft.date&quot;] = data.Date;
	OCinSoutput[&quot;rft.series&quot;] = data.Series;
	OCinSoutput[&quot;rft.volume&quot;] = data.Volume;
	OCinSoutput[&quot;rft.issue&quot;] = data.Issue;
	OCinSoutput[&quot;rft.pages&quot;] = data.Pages;
	OCinSoutput[&quot;rft.edition&quot;] = data.Edition;
	OCinSoutput[&quot;rft.pub&quot;] = data.PublisherName;
	
	for k, v in pairs( data.ID_list ) do
		local id, value = cfg.id_handlers[k].COinS;
		if k == 'ISBN' then value = clean_isbn( v ); else value = v; end
		if string.sub( id or &quot;&quot;, 1, 4 ) == 'info' then
			OCinSoutput[&quot;rft_id&quot;] = table.concat{ id, &quot;/&quot;, v };
		else
			OCinSoutput[ id ] = value;
		end
	end
	
	local last, first;
	for k, v in ipairs( data.Authors ) do
		last, first = v.last, v.first;
		if k == 1 then
			if is_set(last) then
				OCinSoutput[&quot;rft.aulast&quot;] = last;
			end
			if is_set(first) then 
				OCinSoutput[&quot;rft.aufirst&quot;] = first;
			end
		end
		if is_set(last) and is_set(first) then
			OCinSoutput[&quot;rft.au&quot;] = table.concat{ last, &quot;, &quot;, first };
		elseif is_set(last) then
			OCinSoutput[&quot;rft.au&quot;] = last;
		end
	end
	
	OCinSoutput.rft_id = data.URL;
	OCinSoutput.rfr_id = table.concat{ &quot;info:sid/&quot;, mw.site.server:match( &quot;[^/]*$&quot; ), &quot;:&quot;, data.RawPage };
	OCinSoutput = setmetatable( OCinSoutput, nil );
	
	-- sort with version string always first, and combine.
	table.sort( OCinSoutput );
	table.insert( OCinSoutput, 1, &quot;ctx_ver=&quot; .. ctx_ver );  -- such as &quot;Z39.88-2004&quot;
	return table.concat(OCinSoutput, &quot;&amp;&quot;);
end


--[[--------------------------&lt; G E T _ I S O 6 3 9 _ C O D E &gt;------------------------------------------------

Validates language names provided in |language= parameter if not an ISO639-1 code.  Handles the special case that is Norwegian where
ISO639-1 code 'no' is mapped to language name 'Norwegian Bokmål' by Extention:CLDR.

Returns the language name and associated ISO639-1 code.  Because case of the source may be incorrect or different from the case that Wikimedia
uses, the name comparisons are done in lower case and when a match is found, the Wikimedia version (assumed to be correct) is returned along
with the code.  When there is no match, we return the original language name string.

mw.language.fetchLanguageNames() will return a list of languages that aren't part of ISO639-1. Names that aren't ISO639-1 but that are included
in the list will be found if that name is provided in the |language= parameter.  For example, if |language=Samaritan Aramaic, that name will be
found with the associated code 'sam', not an ISO639-1 code.  When names are found and the associated code is not two characters, this function
returns only the Wikimedia language name.

Adapted from code taken from Module:Check ISO 639-1.

]]

local function get_iso639_code (lang)
	if 'norwegian' == lang:lower() then											-- special case related to Wikimedia remap of code 'no' at Extension:CLDR
		return 'Norwegian', 'no';												-- Make sure rendered version is properly capitalized
	end
	
	local languages = mw.language.fetchLanguageNames('en', 'all')				-- get a list of language names known to Wikimedia
																				-- ('all' is required for North Ndebele, South Ndebele, and Ojibwa)
	local langlc = mw.ustring.lower(lang);										-- lower case version for comparisons
	
	for code, name in pairs(languages) do										-- scan the list to see if we can find our language
		if langlc == mw.ustring.lower(name) then
			if 2 ~= code:len() then												-- ISO639-1 codes only
				return name;													-- so return the name but not the code
			end
			return name, code;													-- found it, return name to ensure proper capitalization and the ISO639-1 code
		end
	end
	return lang;																-- not valid language; return language in original case and nil for ISO639-1 code
end

--[[--------------------------&lt; L A N G U A G E _ P A R A M E T E R &gt;------------------------------------------

Get language name from ISO639-1 code value provided.  If a code is valid use the returned name; if not, then use the value that was provided with the language parameter.

There is an exception.  There are three ISO639-1 codes for Norewegian language variants.  There are two official variants: Norwegian Bokmål (code 'nb') and
Norwegian Nynorsk (code 'nn').  The third, code 'no',  is defined by ISO639-1 as 'Norwegian' though in Norway this is pretty much meaningless.  However, it appears
that on enwiki, editors are for the most part unaware of the nb and nn variants (compare page counts for these variants at Category:Articles with non-English-language external links.

Because Norwegian Bokmål is the most common language variant, Media wiki has been modified to return Norwegian Bokmål for ISO639-1 code 'no'. Here we undo that and
return 'Norwegian' when editors use |language=no.  We presume that editors don't know about the variants or can't descriminate between them.

See Help talk:Citation Style_1#An ISO 639-1 language name test

When |language= contains a valid ISO639-1 code, the page is assigned to the category for that code: Category:Norwegian-language sources (no) if
the page is a mainspace page and the ISO639-1 code is not 'en'.  Similarly, if the  parameter is |language=Norwegian, it will be categorized in the same way.

This function supports multiple languages in the form |language=nb, French, th where the language names or codes are separated from each other by commas.

]]

local function language_parameter (lang)
	local code;																	-- the ISO639-1 two character code
	local name;																	-- the language name
	local language_list = {};													-- table of language names to be rendered
	local names_table = {};														-- table made from the value assigned to |language=

	names_table = mw.text.split (lang, '%s*,%s*');								-- names should be a comma separated list

	for _, lang in ipairs (names_table) do										-- reuse lang

		if 2 == lang:len() then													-- ISO639-1 language code are 2 characters (fetchLanguageName also supports 3 character codes)
			name = mw.language.fetchLanguageName( lang:lower(), &quot;en&quot; );			-- get ISO 639-1 language name if Language is a proper code
		end
	
		if is_set (name) then													-- if Language specified a valid ISO639-1 code
			code = lang:lower();												-- save it
		else
			name, code = get_iso639_code (lang);								-- attempt to get code from name (assign name here so that we are sure of proper capitalization)
		end
	
		if is_set (code) then
			if 'no' == code then name = 'Norwegian' end;						-- override wikimedia when code is 'no'
			if 'en' ~= code then												-- English not the language
				add_prop_cat ('foreign_lang_source', {name, code})
			end
		else
			add_maint_cat ('unknown_lang');										-- add maint category if not already added
		end
		
		table.insert (language_list, name);
		name = '';																-- so we can reuse it
	end
	
	code = #language_list														-- reuse code as number of languages in the list
	if 2 &gt;= code then
		name = table.concat (language_list, ' and ')							-- insert '&lt;space&gt;and&lt;space&gt;' between two language names
	elseif 2 &lt; code then
		language_list[code] = 'and ' .. language_list[code];					-- prepend last name with 'and&lt;space&gt;'
		name = table.concat (language_list, ', ')								-- and concatenate with '&lt;comma&gt;&lt;space&gt;' separators
	end
	if 'English' == name then
		return '';																-- if one language and that language is English return an enpty string (no annotation)
	end
	return (&quot; &quot; .. wrap_msg ('language', name));								-- otherwise wrap with '(in ...)'
end

--[[--------------------------&lt; S E T _ C S 1 _ S T Y L E &gt;----------------------------------------------------

Set style settings for CS1 citation templates. Returns separator and postscript settings

]]

local function set_cs1_style (ps)
	if not is_set (ps) then														-- unless explicitely set to something
		ps = '.';																-- terminate the rendered citation with a period
	end
	return '.', ps;																-- separator is a full stop
end

--[[--------------------------&lt; S E T _ C S 2 _ S T Y L E &gt;----------------------------------------------------

Set style settings for CS2 citation templates. Returns separator, postscript, ref settings

]]

local function set_cs2_style (ps, ref)
	if not is_set (ps) then														-- if |postscript= has not been set, set cs2 default
		ps = '';																-- make sure it isn't nil
	end
	if not is_set (ref) then													-- if |ref= is not set
		ref = &quot;harv&quot;;															-- set default |ref=harv
	end
	return ',', ps, ref;														-- separator is a comma
end

--[[--------------------------&lt; G E T _ S E T T I N G S _ F R O M _ C I T E _ C L A S S &gt;----------------------

When |mode= is not set or when its value is invalid, use config.CitationClass and parameter values to establish
rendered style.

]]

local function get_settings_from_cite_class (ps, ref, cite_class)
	local sep;
	if (cite_class == &quot;citation&quot;) then											-- for citation templates (CS2)
		sep, ps, ref = set_cs2_style (ps, ref);
	else																		-- not a citation template so CS1
		sep, ps = set_cs1_style (ps);
	end

	return sep, ps, ref															-- return them all
end

--[[--------------------------&lt; S E T _ S T Y L E &gt;------------------------------------------------------------

Establish basic style settings to be used when rendering the citation.  Uses |mode= if set and valid or uses
config.CitationClass from the template's #invoke: to establish style.

]]

local function set_style (mode, ps, ref, cite_class)
	local sep;
	if 'cs2' == mode then														-- if this template is to be rendered in CS2 (citation) style
		sep, ps, ref = set_cs2_style (ps, ref);
	elseif 'cs1' == mode then													-- if this template is to be rendered in CS1 (cite xxx) style
		sep, ps = set_cs1_style (ps);
	else																		-- anything but cs1 or cs2
		if is_set (mode) then
			table.insert( z.message_tail, { set_error( 'invalid_param_val', {'mode', mode}, true ) } );		-- add error message
		end
		sep, ps, ref = get_settings_from_cite_class (ps, ref, cite_class);		-- get settings based on the template's CitationClass
	end
	if 'none' == ps:lower() then												-- if assigned value is 'none' then
		ps = '';																-- set to empty string
	end
	
	return sep, ps, ref
end

--[=[-------------------------&lt; I S _ P D F &gt;------------------------------------------------------------------

Determines if a url has the file extension is one of the pdf file extensions used by [[MediaWiki:Common.css]] when
applying the pdf icon to external links.

returns true if file extension is one of the recognized extension, else false

]=]

local function is_pdf (url)
	return url:match ('%.pdf[%?#]?') or url:match ('%.PDF[%?#]?');
end

--[[--------------------------&lt; S T Y L E _ F O R M A T &gt;------------------------------------------------------

Applies css style to |format=, |chapter-format=, etc.  Also emits an error message if the format parameter does
not have a matching url parameter.  If the format parameter is not set and the url contains a file extension that
is recognized as a pdf document by MediaWiki's commons.css, this code will set the format parameter to (PDF) with
the appropriate styling.

]]

local function style_format (format, url, fmt_param, url_param)
	if is_set (format) then
		format = wrap_style ('format', format);									-- add leading space, parenthases, resize
		if not is_set (url) then
			format = format .. set_error( 'format_missing_url', {fmt_param, url_param} );	-- add an error message
		end
	elseif is_pdf (url) then													-- format is not set so if url is a pdf file then
		format = wrap_style ('format', 'PDF');									-- set format to pdf
	else
		format = '';															-- empty string for concatenation
	end
	return format;
end

--[[--------------------------&lt; G E T _ D I S P L A Y _ A U T H O R S _ E D I T O R S &gt;------------------------

Returns a number that may or may not limit the length of the author or editor name lists.

When the value assigned to |display-authors= is a number greater than or equal to zero, return the number and
the previous state of the 'etal' flag (false by default but may have been set to true if the name list contains
some variant of the text 'et al.').

When the value assigned to |display-authors= is the keyword 'etal', return a number that is one greater than the
number of authors in the list and set the 'etal' flag true.  This will cause the list_people() to display all of
the names in the name list followed by 'et al.'

In all other cases, returns nil and the previous state of the 'etal' flag.

]]

local function get_display_authors_editors (max, count, list_name, etal)
	if is_set (max) then
		if 'etal' == max:lower():gsub(&quot;[ '%.]&quot;, '') then						-- the :gsub() portion makes 'etal' from a variety of 'et al.' spellings and stylings
			max = count + 1;													-- number of authors + 1 so display all author name plus et al.
			etal = true;														-- overrides value set by extract_names()
		elseif max:match ('^%d+$') then											-- if is a string of numbers
			max = tonumber (max);												-- make it a number
			if max &gt;= count and 'authors' == list_name then	-- AUTHORS ONLY		-- if |display-xxxxors= value greater than or equal to number of authors/editors
				add_maint_cat ('disp_auth_ed', list_name);
			end
		else																	-- not a valid keyword or number
			table.insert( z.message_tail, { set_error( 'invalid_param_val', {'display-' .. list_name, max}, true ) } );		-- add error message
			max = nil;															-- unset
		end
	elseif 'authors' == list_name then		-- AUTHORS ONLY	need to clear implicit et al category
		max = count + 1;														-- number of authors + 1
	end
	
	return max, etal;
end

--[[--------------------------&lt; E X T R A _ T E X T _ I N _ P A G E _ C H E C K &gt;------------------------------

Adds page to Category:CS1 maint: extra text if |page= or |pages= has what appears to be some form of p. or pp. 
abbreviation in the first characters of the parameter content.

check Page and Pages for extraneous p, p., pp, and pp. at start of parameter value:
	good pattern: '^P[^%.P%l]' matches when |page(s)= begins PX or P# but not Px where x and X are letters and # is a dgiit
	bad pattern: '^[Pp][Pp]' matches matches when |page(s)= begins pp or pP or Pp or PP

]]

local function extra_text_in_page_check (page, nopp)
--	local good_pattern = '^P[^%.P%l]';
	local good_pattern = '^P[^%.Pp]';										-- ok to begin with uppercase P: P7 (pg 7 of section P) but not p123 (page 123) TODO: add Gg for PG or Pg?
--	local bad_pattern = '^[Pp][Pp]';
	local bad_pattern = '^[Pp]?[Pp]%.?[ %d]';

	if is_set (nopp) then													-- don't bother checking if |nopp= is set
		return;
	end

	if not page:match (good_pattern) and (page:match (bad_pattern) or  page:match ('^[Pp]ages?')) then
		add_maint_cat ('extra_text');
	end
--		if Page:match ('^[Pp]?[Pp]%.?[ %d]') or  Page:match ('^[Pp]ages?[ %d]') or
--			Pages:match ('^[Pp]?[Pp]%.?[ %d]') or  Pages:match ('^[Pp]ages?[ %d]') then
--				add_maint_cat ('extra_text');
--		end
end


--[[--------------------------&lt; P A R S E _ V A U T H O R S _ V E D I T O R S &gt;--------------------------------

This function extracts author / editor names from |vauthors= or |veditors= and finds matching |xxxxor-maskn= and
|xxxxor-linkn= in args.  It then returns a table of assembled names just as extract_names() does.

Author / editor names in |vauthors= or |veditors= must be in Vancouver system style. Corporate or institutional names
may sometimes be required and because such names will often fail the is_good_vanc_name() and other format compliance
tests, are wrapped in doubled paranethese ((corporate name)) to suppress the format tests.

]]

local function parse_vauthors_veditors (args, vparam, list_name)
	local names = {};															-- table of names assembled from |vauthors=, |author-maskn=, |author-linkn=
	local v_name_table = {};
	local etal = false;															-- return value set to true when we find some form of et al. vauthors parameter
	local last, first, link, mask;
	local corporate = false;

	vparam, etal = name_has_etal (vparam, etal, true);							-- find and remove variations on et al. do not categorize (do it here because et al. might have a period)
	if vparam:find ('%[%[') or vparam:find ('%]%]')	then						-- no wikilinking vauthors names
		add_vanc_error ();
	end
	v_name_table = mw.text.split(vparam, &quot;%s*,%s*&quot;)								-- names are separated by commas

	for i, v_name in ipairs(v_name_table) do
		if v_name:match ('^%(%(.+%)%)$') then									-- corporate authors are wrapped in doubled parenthese to supress vanc formatting and error detection
			first = '';															-- set to empty string for concatenation and because it may have been set for previous author/editor
			last = v_name:match ('^%(%((.+)%)%)$')
			corporate = true;
		elseif string.find(v_name, &quot;%s&quot;) then
		    lastfirstTable = {}
		    lastfirstTable = mw.text.split(v_name, &quot;%s&quot;)
		    first = table.remove(lastfirstTable);								-- removes and returns value of last element in table which should be author intials
		    last  = table.concat(lastfirstTable, &quot; &quot;)							-- returns a string that is the concatenation of all other names that are not initials
		else
			first = '';															-- set to empty string for concatenation and because it may have been set for previous author/editor
			last = v_name;														-- last name or single corporate name?  Doesn't support multiword corporate names? do we need this?
		end
																
		if is_set (first) and not mw.ustring.match (first, &quot;^%u?%u$&quot;) then		-- first shall contain one or two upper-case letters, nothing else
			add_vanc_error ();
		end
																				-- this from extract_names ()
		link = select_one( args, cfg.aliases[list_name .. '-Link'], 'redundant_parameters', i );
		mask = select_one( args, cfg.aliases[list_name .. '-Mask'], 'redundant_parameters', i );
		names[i] = {last = last, first = first, link = link, mask = mask, corporate=corporate};		-- add this assembled name to our names list
	end
	return names, etal;															-- all done, return our list of names
end

--[[--------------------------&lt; S E L E C T _ A U T H O R _ E D I T O R _ S O U R C E &gt;------------------------

Select one of |authors=, |authorn= / |lastn / firstn=, or |vauthors= as the source of the author name list or
select one of |editors=, |editorn= / editor-lastn= / |editor-firstn= or |veditors= as the source of the editor name list.

Only one of these appropriate three will be used.  The hierarchy is: |authorn= (and aliases) highest and |authors= lowest and
similarly, |editorn= (and aliases) highest and |editors= lowest

When looking for |authorn= / |editorn= parameters, test |xxxxor1= and |xxxxor2= (and all of their aliases); stops after the second
test which mimicks the test used in extract_names() when looking for a hole in the author name list.  There may be a better
way to do this, I just haven't discovered what that way is.

Emits an error message when more than one xxxxor name source is provided.

In this function, vxxxxors = vauthors or veditors; xxxxors = authors or editors as appropriate.

]]

local function select_author_editor_source (vxxxxors, xxxxors, args, list_name)
local lastfirst = false;
	if select_one( args, cfg.aliases[list_name .. '-Last'], 'redundant_parameters', 1 ) or		-- do this twice incase we have a first 1 without a last1
		select_one( args, cfg.aliases[list_name .. '-Last'], 'redundant_parameters', 2 ) then
			lastfirst=true;
	end

	if (is_set (vxxxxors) and true == lastfirst) or								-- these are the three error conditions
		(is_set (vxxxxors) and is_set (xxxxors)) or
		(true == lastfirst and is_set (xxxxors)) then
			local err_name;
			if 'AuthorList' == list_name then									-- figure out which name should be used in error message
				err_name = 'author';
			else
				err_name = 'editor';
			end
			table.insert( z.message_tail, { set_error( 'redundant_parameters',
				{err_name .. '-name-list parameters'}, true ) } );				-- add error message
	end

	if true == lastfirst then return 1 end;										-- return a number indicating which author name source to use
	if is_set (vxxxxors) then return 2 end;
	if is_set (xxxxors) then return 3 end;
	return 0;																	-- no authors so return 0 
end

--[[--------------------------&lt; C I T A T I O N 0 &gt;------------------------------------------------------------

This is the main function doing the majority of the citation formatting.

]]

local function citation0( config, args)
	--[[ 
	Load Input Parameters
	The argument_wrapper facilitates the mapping of multiple aliases to single internal variable.
	]]
	local A = argument_wrapper( args );

	local i 
	local PPrefix = A['PPrefix']
	local PPPrefix = A['PPPrefix']
	local NoPP = A['NoPP'] 
	if in_array(NoPP:lower(), {'yes', 'true', 'y'}) then
		PPPrefix = '';															-- unset these, prefix if used is in |page= or |pages=
		PPrefix = '';
	else
		NoPP = nil;																-- unset, used as a flag later
	end

	-- Pick out the relevant fields from the arguments.  Different citation templates
	-- define different field names for the same underlying things.	
	local author_etal;
	local a	= {};																-- authors list from |lastn= / |firstn= pairs or |vauthors=
	local Authors;
	local NameListFormat = A['NameListFormat'];									-- replaces |author-format= and |editor-format=

	do																			-- to limit scope of selected
		local selected = select_author_editor_source (A['Vauthors'], A['Authors'], args, 'AuthorList');
		if 1 == selected then
			a, author_etal = extract_names (args, 'AuthorList');				-- fetch author list from |authorn= / |lastn= / |firstn=, |author-linkn=, and |author-maskn=
		elseif 2 == selected then
			NameListFormat = 'vanc';											-- override whatever |name-list-format= might be
			a, author_etal = parse_vauthors_veditors (args, args.vauthors, 'AuthorList');	-- fetch author list from |vauthors=, |author-linkn=, and |author-maskn=
		elseif 3 == selected then
			Authors = A['Authors'];												-- use content of |authors=
		end
	end

	local Coauthors = A['Coauthors'];
	local Others = A['Others'];

	local editor_etal;
	local e	= {};																-- editors list from |editor-lastn= / |editor-firstn= pairs or |veditors=
	local Editors;

	do																			-- to limit scope of selected
		local selected = select_author_editor_source (A['Veditors'], A['Editors'], args, 'EditorList');
		if 1 == selected then
			e, editor_etal = extract_names (args, 'EditorList');				-- fetch editor list from |editorn= / |editor-lastn= / |editor-firstn=, |editor-linkn=, and |editor-maskn=
		elseif 2 == selected then
			NameListFormat = 'vanc';											-- override whatever |name-list-format= might be
			e, editor_etal = parse_vauthors_veditors (args, args.veditors, 'EditorList');	-- fetch editor list from |veditors=, |editor-linkn=, and |editor-maskn=
		elseif 3 == selected then
			Editors = A['Editors'];												-- use content of |editors=
		end
	end

	if is_set (NameListFormat) and ('vanc' ~= NameListFormat) then											-- only accepted value for this parameter is 'vanc'
		table.insert( z.message_tail, { set_error( 'invalid_param_val', {'name-list-format', NameListFormat}, true ) } );	-- not vanc so add error message
		NameListFormat = '';													-- set to empty string
	end

	local Year = A['Year'];
	local PublicationDate = A['PublicationDate'];
	local OrigYear = A['OrigYear'];
	local Date = A['Date'];
	local LayDate = A['LayDate'];
	------------------------------------------------- Get title data
	local Title = A['Title'];
	local ScriptTitle = A['ScriptTitle'];
	local BookTitle = A['BookTitle'];
	local Conference = A['Conference'];
	local TransTitle = A['TransTitle'];
	local TitleNote = A['TitleNote'];
	local TitleLink = A['TitleLink'];
	local Chapter = A['Chapter'];
	local ChapterLink = A['ChapterLink'];										-- deprecated but used internally by cite episode
	local TransChapter = A['TransChapter'];
	local TitleType = A['TitleType'];
	local Degree = A['Degree'];
	local Docket = A['Docket'];
	local ArchiveFormat = A['ArchiveFormat'];
	local ArchiveURL = A['ArchiveURL'];
	local URL = A['URL']
	local URLorigin = A:ORIGIN('URL');											-- get name of parameter that holds URL
	local ChapterURL = A['ChapterURL'];
	local ChapterURLorigin = A:ORIGIN('ChapterURL');							-- get name of parameter that holds ChapterURL
	local ConferenceFormat = A['ConferenceFormat'];
	local ConferenceURL = A['ConferenceURL'];
	local ConferenceURLorigin = A:ORIGIN('ConferenceURL');						-- get name of parameter that holds ConferenceURL
	local Periodical = A['Periodical'];

	local Series = A['Series'];
	local Volume = A['Volume'];
	local Issue = A['Issue'];
	local Position = '';
	local Page = A['Page'];
	local Pages = hyphen_to_dash( A['Pages'] );	
	local At = A['At'];

	local Edition = A['Edition'];
	local PublicationPlace = A['PublicationPlace']
	local Place = A['Place'];
	
	local PublisherName = A['PublisherName'];
	local RegistrationRequired = A['RegistrationRequired'];
	local SubscriptionRequired = A['SubscriptionRequired'];
	local Via = A['Via'];
	local AccessDate = A['AccessDate'];
	local ArchiveDate = A['ArchiveDate'];
	local Agency = A['Agency'];
	local DeadURL = A['DeadURL']
	local Language = A['Language'];
	local Format = A['Format'];
	local ChapterFormat = A['ChapterFormat'];
	local DoiBroken = A['DoiBroken'];
	local ID = A['ID'];
	local ASINTLD = A['ASINTLD'];
	local IgnoreISBN = A['IgnoreISBN'];
	local Embargo = A['Embargo'];
	local Class = A['Class'];													-- arxiv class identifier

	local ID_list = extract_ids( args );

	local Quote = A['Quote'];

	local LayFormat = A['LayFormat'];
	local LayURL = A['LayURL'];
	local LaySource = A['LaySource'];
	local Transcript = A['Transcript'];
	local TranscriptFormat = A['TranscriptFormat'];
	local TranscriptURL = A['TranscriptURL'] 
	local TranscriptURLorigin = A:ORIGIN('TranscriptURL');						-- get name of parameter that holds TranscriptURL

	local LastAuthorAmp = A['LastAuthorAmp'];
	local no_tracking_cats = A['NoTracking'];

--these are used by cite interview
	local Callsign = A['Callsign'];
	local City = A['City'];
	local Program = A['Program'];

--local variables that are not cs1 parameters
	local use_lowercase;								-- controls capitalization of certain static text
	local this_page = mw.title.getCurrentTitle();		-- also used for COinS and for language
	local anchor_year;									-- used in the CITEREF identifier
	local COinS_date;									-- used in the COinS metadata

-- set default parameter values defined by |mode= parameter.  If |mode= is empty or omitted, use CitationClass to set these values
	local sepc;											-- separator between citation elements for CS1 a period, for CS2, a comma
	local PostScript;
	local Ref;
	sepc, PostScript, Ref = set_style (A['Mode']:lower(), A['PostScript'], A['Ref'], config.CitationClass);
	use_lowercase = ( sepc == ',' );					-- used to control capitalization for certain static text

--check this page to see if it is in one of the namespaces that cs1 is not supposed to add to the error categories
	if not is_set (no_tracking_cats) then										-- ignore if we are already not going to categorize this page
		if in_array (this_page.nsText, cfg.uncategorized_namespaces) then
			no_tracking_cats = &quot;true&quot;;											-- set no_tracking_cats
		end
		for _,v in ipairs (cfg.uncategorized_subpages) do						-- cycle through page name patterns
			if this_page.text:match (v) then									-- test page name against each pattern
				no_tracking_cats = &quot;true&quot;;										-- set no_tracking_cats
				break;															-- bail out if one is found
			end
		end
	end

-- check for extra |page=, |pages= or |at= parameters. 
	if is_set(Page) then
		if is_set(Pages) or is_set(At) then
			Page = Page .. &quot; &quot; .. set_error('extra_pages');						-- add error message
			Pages = '';															-- unset the others
			At = '';
		end
		extra_text_in_page_check (Page, NoPP);									-- add this page to maint cat if |page= value begins with what looks like p. or pp.
	elseif is_set(Pages) then
		if is_set(At) then
			Pages = Pages .. &quot; &quot; .. set_error('extra_pages');					-- add error messages
			At = '';															-- unset
		end
		extra_text_in_page_check (Pages, NoPP);									-- add this page to maint cat if |page= value begins with what looks like p. or pp.
	end	

-- both |publication-place= and |place= (|location=) allowed if different
	if not is_set(PublicationPlace) and is_set(Place) then
		PublicationPlace = Place;							-- promote |place= (|location=) to |publication-place
	end
	
	if PublicationPlace == Place then Place = ''; end		-- don't need both if they are the same
	
--[[
Parameter remapping for cite encyclopedia:
When the citation has these parameters:
	|encyclopedia and |title then map |title to |article and |encyclopedia to |title
	|encyclopedia and |article then map |encyclopedia to |title
	|encyclopedia then map |encyclopedia to |title

	|trans_title maps to |trans_chapter when |title is re-mapped
	|url maps to |chapterurl when |title is remapped

All other combinations of |encyclopedia, |title, and |article are not modified
TODO: script-title to script-chapter if and when we support script-chapter
]]

local Encyclopedia = A['Encyclopedia'];

	if ( config.CitationClass == &quot;encyclopaedia&quot; ) or ( config.CitationClass == &quot;citation&quot; and is_set (Encyclopedia)) then	-- test code for citation
		if is_set(Periodical) then					-- Periodical is set when |encyclopedia is set
			if is_set(Title) then
				if not is_set(Chapter) then
					Chapter = Title;				-- |encyclopedia and |title are set so map |title to |article and |encyclopedia to |title
					TransChapter = TransTitle;
					ChapterURL = URL;
					if not is_set (ChapterURL) and is_set (TitleLink) then
						Chapter= '[[' .. TitleLink .. '|' .. Chapter .. ']]';
					end
					Title = Periodical;
					ChapterFormat = Format;
					Periodical = '';				-- redundant so unset
					TransTitle = '';				-- redundant so unset
					URL = '';						-- redundant so unset
					Format = '';					-- redundant so unset
					TitleLink = '';					-- redundant so unset
				end
			else									-- |title not set
				Title = Periodical;					-- |encyclopedia set and |article set or not set so map |encyclopedia to |title
				Periodical = '';					-- redundant so unset
			end
		end
	end

-- Special case for cite techreport.
	if (config.CitationClass == &quot;techreport&quot;) then	-- special case for cite techreport
		if is_set(Issue) then						-- cite techreport uses 'number', which other citations aliase to 'issue'
			if not is_set(ID) then					-- can we use ID for the &quot;number&quot;?
				ID = Issue;							-- yes, use it
				Issue = &quot;&quot;;							-- unset Issue so that &quot;number&quot; isn't duplicated in the rendered citation or COinS metadata
			else									-- can't use ID so emit error message
				ID = ID .. &quot; &quot; .. set_error('redundant_parameters', '&lt;code&gt;&amp;#124;id=&lt;/code&gt; and &lt;code&gt;&amp;#124;number=&lt;/code&gt;');
			end
		end	
	end

-- special case for cite interview
	if (config.CitationClass == &quot;interview&quot;) then
		if is_set(Program) then
			ID = ' ' .. Program;
		end
		if is_set(Callsign) then
			if is_set(ID) then
				ID = ID .. sepc .. ' ' .. Callsign;
			else
				ID = ' ' .. Callsign;
			end
		end
		if is_set(City) then
			if is_set(ID) then
				ID = ID .. sepc .. ' ' .. City;
			else
				ID = ' ' .. City;
			end
		end

		if is_set(Others) then
			if is_set(TitleType) then
				Others = ' ' .. TitleType .. ' with ' .. Others;
				TitleType = '';
			else
				Others = ' ' .. 'Interview with ' .. Others;
			end
		else
			Others = '(Interview)';
		end
	end

-- special case for cite mailing list
	if (config.CitationClass == &quot;mailinglist&quot;) then
		Periodical = A ['MailingList'];
	end

-- Account for the oddity that is {{cite conference}}, before generation of COinS data.
	if 'conference' == config.CitationClass then
		if is_set(BookTitle) then
			Chapter = Title;
--			ChapterLink = TitleLink;											-- |chapterlink= is deprecated
			ChapterURL = URL;
			ChapterURLorigin = URLorigin;
			URLorigin = '';
			ChapterFormat = Format;
			TransChapter = TransTitle;
			Title = BookTitle;
			Format = '';
--			TitleLink = '';
			TransTitle = '';
			URL = '';
		end
	elseif 'speech' ~= config.CitationClass then
		Conference = '';														-- not cite conference or cite speech so make sure this is empty string
	end

-- cite map oddities
	local Cartography = &quot;&quot;;
	local Scale = &quot;&quot;;
	local Sheet = A['Sheet'] or '';
	local Sheets = A['Sheets'] or '';
	if config.CitationClass == &quot;map&quot; then
		Chapter = A['Map'];
		ChapterURL = A['MapURL'];
		TransChapter = A['TransMap'];
		ChapterURLorigin = A:ORIGIN('MapURL');
		ChapterFormat = A['MapFormat'];
		
		Cartography = A['Cartography'];
		if is_set( Cartography ) then
			Cartography = sepc .. &quot; &quot; .. wrap_msg ('cartography', Cartography, use_lowercase);
		end		
		Scale = A['Scale'];
		if is_set( Scale ) then
			Scale = sepc .. &quot; &quot; .. Scale;
		end
	end

-- Account for the oddities that are {{cite episode}} and {{cite serial}}, before generation of COinS data.
	if 'episode' == config.CitationClass or 'serial' == config.CitationClass then
		local AirDate = A['AirDate'];
		local Began = A['Began'];												-- these two are deprecated because the module understands date ranges
		local Ended = A['Ended'];
		local SeriesLink = A['SeriesLink'];
		local Network = A['Network'];
		local Station = A['Station'];
		local s, n = {}, {};

																				-- do common parameters first
		if is_set(Network) then table.insert(n, Network); end
		if is_set(Station) then table.insert(n, Station); end
		ID = table.concat(n, sepc .. ' ');
		
		if not is_set (Date) then												-- promote airdate or Began/Ended to date
			if is_set (AirDate) then
				Date = AirDate;
			elseif is_set (Began) then											-- deprecated
				if Began:match('%s') or Ended:match('%s') then					-- so we don't create errors: if either has spaces then
					Date = Began .. ' – ' .. Ended;								-- use spaced ndash as separator
				else
					Date = Began .. '–' .. Ended;								-- elsewise no spaces
				end
			end
		end

		if 'episode' == config.CitationClass then								-- handle the oddities that are strictly {{cite episode}}
			local Season = A['Season'];
			local SeriesNumber = A['SeriesNumber'];

			if is_set (Season) and is_set (SeriesNumber) then					-- these are mutually exclusive so if both are set
				table.insert( z.message_tail, { set_error( 'redundant_parameters', {wrap_style ('parameter', 'season') .. ' and ' .. wrap_style ('parameter', 'seriesno')}, true ) } );		-- add error message
				SeriesNumber = '';												-- unset; prefer |season= over |seriesno=
			end
																				-- assemble a table of parts concatenated later into Series
			if is_set(Season) then table.insert(s, wrap_msg ('season', Season, use_lowercase)); end
			if is_set(SeriesNumber) then table.insert(s, wrap_msg ('series', SeriesNumber, use_lowercase)); end
			if is_set(Issue) then table.insert(s, wrap_msg ('episode', Issue, use_lowercase)); end
			Issue = '';															-- unset because this is not a unique parameter
	
			Chapter = Title;													-- promote title parameters to chapter
			ChapterLink = TitleLink;											-- alias episodelink
			TransChapter = TransTitle;
			ChapterURL = URL;
			ChapterURLorigin = A:ORIGIN('URL');
			
			Title = Series;														-- promote series to title
			TitleLink = SeriesLink;
			Series = table.concat(s, sepc .. ' ');								-- this is concatenation of season, seriesno, episode number

			if is_set (ChapterLink) and not is_set (ChapterURL) then			-- link but not URL
				Chapter = '[[' .. ChapterLink .. '|' .. Chapter .. ']]';		-- ok to wikilink
			elseif is_set (ChapterLink) and is_set (ChapterURL) then			-- if both are set, URL links episode;
				Series = '[[' .. ChapterLink .. '|' .. Series .. ']]';			-- series links with ChapterLink (episodelink -&gt; TitleLink -&gt; ChapterLink) ugly
			end
			URL = '';															-- unset
			TransTitle = '';													-- unset
			
		else																	-- now oddities that are cite serial
			Issue = '';														-- unset because this parameter no longer supported by the citation/core version of cite serial
			Chapter = A['Episode'];												-- TODO: make |episode= available to cite episode someday?
			if is_set (Series) and is_set (SeriesLink) then
				Series = '[[' .. SeriesLink .. '|' .. Series .. ']]';
			end
			Series = wrap_style ('italic-title', Series);						-- series is italicized
		end	
	end
-- end of {{cite episode}} stuff

-- Account for the oddities that are {{cite arxiv}}, before generation of COinS data.
	if 'arxiv' == config.CitationClass then
		if not is_set (ID_list['ARXIV']) then									-- |arxiv= or |eprint= required for cite arxiv
			table.insert( z.message_tail, { set_error( 'arxiv_missing', {}, true ) } );		-- add error message
		elseif is_set (Series) then												-- series is an alias of version
			ID_list['ARXIV'] = ID_list['ARXIV'] .. Series;						-- concatenate version onto the end of the arxiv identifier
			Series = '';														-- unset
			deprecated_parameter ('version');									-- deprecated parameter but only for cite arxiv
		end
		
		if first_set (AccessDate, At, Chapter, Format, Page, Pages, Periodical, PublisherName, URL,	-- a crude list of parameters that are not supported by cite arxiv
			ID_list['ASIN'], ID_list['BIBCODE'], ID_list['DOI'], ID_list['ISBN'], ID_list['ISSN'],
			ID_list['JFM'], ID_list['JSTOR'], ID_list['LCCN'], ID_list['MR'], ID_list['OCLC'], ID_list['OL'],
			ID_list['OSTI'], ID_list['PMC'], ID_list['PMID'], ID_list['RFC'], ID_list['SSRN'], ID_list['USENETID'], ID_list['ZBL']) then
				table.insert( z.message_tail, { set_error( 'arxiv_params_not_supported', {}, true ) } );		-- add error message

				AccessDate= '';													-- set these to empty string; not supported in cite arXiv
				PublisherName = '';												-- (if the article has been published, use cite journal, or other)
				Chapter = '';
				URL = '';
				Format = '';
				Page = ''; Pages = ''; At = '';
		end
		Periodical = 'arXiv';													-- set to arXiv for COinS; after that, must be set to empty string
	end

-- handle type parameter for those CS1 citations that have default values

	if in_array(config.CitationClass, {&quot;AV-media-notes&quot;, &quot;DVD-notes&quot;, &quot;mailinglist&quot;, &quot;map&quot;, &quot;podcast&quot;, &quot;pressrelease&quot;, &quot;report&quot;, &quot;techreport&quot;, &quot;thesis&quot;}) then
		TitleType = set_titletype (config.CitationClass, TitleType);
		if is_set(Degree) and &quot;Thesis&quot; == TitleType then						-- special case for cite thesis
			TitleType = Degree .. &quot; thesis&quot;;
		end
	end

	if is_set(TitleType) then													-- if type parameter is specified
		TitleType = &quot; (&quot; .. TitleType .. &quot;)&quot;;									-- display it in parentheses
	end

-- legacy: promote concatenation of |month=, and |year= to Date if Date not set; or, promote PublicationDate to Date if neither Date nor Year are set.
	if not is_set (Date) then
		Date = Year;						-- promote Year to Date
		Year = nil;							-- make nil so Year as empty string isn't used for CITEREF
		if is_set(Date) then
			local Month = A['Month'];
			if is_set(Month) then
				Date = Month .. &quot; &quot; .. Date;
			end
		elseif is_set(PublicationDate) then	-- use PublicationDate when |date= and |year= are not set
			Date = PublicationDate;			-- promote PublicationDate to Date
			PublicationDate = '';			-- unset, no longer needed
		end
	end

	if PublicationDate == Date then PublicationDate = ''; end	-- if PublicationDate is same as Date, don't display in rendered citation

--[[
Go test all of the date-holding parameters for valid MOS:DATE format and make sure that dates are real dates. This must be done before we do COinS because here is where
we get the date used in the metadata.

Date validation supporting code is in Module:Citation/CS1/Date_validation
]]
	do	-- create defined block to contain local variables error_message and mismatch
		local error_message = '';
																				-- AirDate has been promoted to Date so not necessary to check it
		anchor_year, COinS_date, error_message = dates({['accessdate']=AccessDate, ['archivedate']=ArchiveDate, ['date']=Date, ['doi_brokendate']=DoiBroken,
			['embargo']=Embargo, ['laydate']=LayDate, ['publicationdate']=PublicationDate, ['year']=Year});

		if is_set (Year) and is_set (Date) then									-- both |date= and |year= not normally needed; 
			local mismatch = year_date_check (Year, Date)
			if 0 == mismatch then												-- |year= does not match a year-value in |date=
				if is_set (error_message) then									-- if there is already an error message
					error_message = error_message .. ', ';						-- tack on this additional message
				end
				error_message = error_message .. '&amp;#124;year= / &amp;#124;date= mismatch';
			elseif 1 == mismatch then											-- |year= matches year-value in |date=
				add_maint_cat ('date_year');
			end
		end

		if is_set(error_message) then
			table.insert( z.message_tail, { set_error( 'bad_date', {error_message}, true ) } );	-- add this error message
		end
	end	-- end of do

-- Account for the oddity that is {{cite journal}} with |pmc= set and |url= not set.  Do this after date check but before COInS.
-- Here we unset Embargo if PMC not embargoed (|embargo= not set in the citation) or if the embargo time has expired. Otherwise, holds embargo date
	Embargo = is_embargoed (Embargo);											-- 

	if config.CitationClass == &quot;journal&quot; and not is_set(URL) and is_set(ID_list['PMC']) then
		if not is_set (Embargo) then											-- if not embargoed or embargo has expired
			URL=cfg.id_handlers['PMC'].prefix .. ID_list['PMC'];				-- set url to be the same as the PMC external link if not embargoed
			URLorigin = cfg.id_handlers['PMC'].parameters[1];					-- set URLorigin to parameter name for use in error message if citation is missing a |title=
		end
	end

-- At this point fields may be nil if they weren't specified in the template use.  We can use that fact.
	-- Test if citation has no title
	if	not is_set(Title) and
		not is_set(TransTitle) and
		not is_set(ScriptTitle) then
		table.insert( z.message_tail, { set_error( 'citation_missing_title', {}, true ) } );
	end
	
	if 'none' == Title and is_set(Periodical) and not (( config.CitationClass == &quot;encyclopaedia&quot; ) or ( config.CitationClass == &quot;citation&quot; and is_set (Encyclopedia))) then								-- special case
		Title = '';																-- set title to empty string
		add_maint_cat ('untitled');
	end

	-- COinS metadata (see &lt;http://ocoins.info/&gt;) for automated parsing of citation information.
	-- handle the oddity that is cite encyclopedia and {{citation |encyclopedia=something}}. Here we presume that
	-- when Periodical, Title, and Chapter are all set, then Periodical is the book (encyclopedia) title, Title
	-- is the article title, and Chapter is a section within the article.  So, we remap 
	
	local coins_chapter = Chapter;												-- default assuming that remapping not required
	local coins_title = Title;													-- et tu
	if 'encyclopaedia' == config.CitationClass or ('citation' == config.CitationClass and is_set (Encyclopedia)) then
		if is_set (Chapter) and is_set (Title) and is_set (Periodical) then		-- if all are used then
			coins_chapter = Title;												-- remap
			coins_title = Periodical;
		end
	end
	
	-- this is the function call to COinS()
	local OCinSoutput = COinS({
		['Periodical'] = Periodical,
		['Chapter'] = strip_apostrophe_markup (coins_chapter),					-- Chapter stripped of bold / italic wikimarkup
		['Title'] = make_coins_title (coins_title, ScriptTitle),				-- Title and ScriptTitle stripped of bold / italic wikimarkup
		['PublicationPlace'] = PublicationPlace,
		['Date'] = first_set(COinS_date, Date),		-- COinS_date has correctly formatted date if Date is valid; any reason to keep Date here?  Should we be including invalid dates in metadata?
		['Series'] = Series,
		['Volume'] = Volume,
		['Issue'] = Issue,
		['Pages'] = get_coins_pages (first_set(Sheet, Sheets, Page, Pages, At)),				-- pages stripped of external links
		['Edition'] = Edition,
		['PublisherName'] = PublisherName,
		['URL'] = first_set( URL, ChapterURL ),
		['Authors'] = a,
		['ID_list'] = ID_list,
		['RawPage'] = this_page.prefixedText,
	}, config.CitationClass);

-- Account for the oddities that are {{cite arxiv}}, AFTER generation of COinS data.
	if 'arxiv' == config.CitationClass then										-- we have set rft.jtitle in COinS to arXiv, now unset so it isn't displayed
		Periodical = '';														-- periodical not allowed in cite arxiv; if article has been published, use cite journal
	end

-- special case for cite newsgroup.  Do this after COinS because we are modifying Publishername to include some static text
	if 'newsgroup' == config.CitationClass then
		if is_set (PublisherName) then
			PublisherName = '[[Usenet newsgroup|Newsgroup]]:&amp;nbsp;' ..  external_link( 'news:' .. PublisherName, PublisherName );
		end
	end



	-- Now perform various field substitutions.
	-- We also add leading spaces and surrounding markup and punctuation to the
	-- various parts of the citation, but only when they are non-nil.
	do																			-- do-block to limit scope of last_first_list
		local last_first_list;
		local maximum = A['DisplayAuthors'];

		maximum , author_etal = get_display_authors_editors (maximum, #a, 'authors', author_etal);

		local control = { 
			format = NameListFormat,											-- empty string or 'vanc'
			maximum = maximum,
			lastauthoramp = LastAuthorAmp,
			page_name = this_page.text											-- get current page name so that we don't wikilink to it via authorlinkn
			};
		
		if is_set(Coauthors) then												-- if the coauthor field is also used, prevent ampersand and et al. formatting.
			control.lastauthoramp = nil;
			control.maximum = #a + 1;
		end
		
		last_first_list = list_people(control, a, author_etal);

		if is_set (Authors) then
			Authors, author_etal = name_has_etal (Authors, author_etal, false);	-- find and remove variations on et al.
			if author_etal then
				Authors = Authors .. ' ' .. cfg.messages['et al'];				-- add et al. to authors parameter
			end
		else
			Authors = last_first_list;											-- either an author name list or an empty string
		end

	end																			-- end of do

	if not is_set(Authors) and is_set(Coauthors) then	-- coauthors aren't displayed if one of authors=, authorn=, or lastn= isn't specified
		table.insert( z.message_tail, { set_error('coauthors_missing_author', {}, true) } );	-- emit error message
	end

	local EditorCount;															-- used only for choosing {ed.) or (eds.) annotation at end of editor name-list
	do
		local last_first_list;
		local maximum = A['DisplayEditors'];

		maximum , editor_etal = get_display_authors_editors (maximum, #e, 'editors', editor_etal);
		-- Preserve old-style implicit et al.
		if not is_set(maximum) and #e == 4 then 
			maximum = 3;
			table.insert( z.message_tail, { set_error('implict_etal_editor', {}, true) } );
		end

		local control = { 
			format = NameListFormat,											-- empty string or 'vanc'
			maximum = maximum,
			lastauthoramp = LastAuthorAmp,
			page_name = this_page.text											-- get current page name so that we don't wikilink to it via editorlinkn
		};

		last_first_list, EditorCount = list_people(control, e, editor_etal);

		if is_set (Editors) then
			if editor_etal then
				Editors = Editors .. ' ' .. cfg.messages['et al'];				-- add et al. to editors parameter beause |display-editors=etal
				EditorCount = 2;												-- with et al., |editors= is multiple names; spoof to display (eds.) annotation
			else
				EditorCount = 2;												-- we don't know but assume |editors= is multiple names; spoof to display (eds.) annotation
			end
		else
			Editors = last_first_list;											-- either an author name list or an empty string
		end

		if 1 == EditorCount and (true == editor_etal or 1 &lt; #e) then			-- only one editor displayed but includes etal then 
			EditorCount = 2;													-- spoof to display (eds.) annotation
		end
	end


-- apply |[xx-]format= styling; at the end, these parameters hold correctly styled format annotation,
-- an error message if the associated url is not set, or an empty string for concatenation
	ArchiveFormat = style_format (ArchiveFormat, ArchiveURL, 'archive-format', 'archive-url');
	ChapterFormat = style_format (ChapterFormat, ChapterURL, 'chapter-format', 'chapter-url');
	ConferenceFormat = style_format (ConferenceFormat, ConferenceURL, 'conference-format', 'conference-url');
	Format = style_format (Format, URL, 'format', 'url');
	LayFormat = style_format (LayFormat, LayURL, 'lay-format', 'lay-url');
	TranscriptFormat = style_format (TranscriptFormat, TranscriptURL, 'transcript-format', 'transcripturl');

	if  not is_set(URL) then --and
--		not is_set(ArchiveURL) then --and										-- prevents format_missing_url error from registering
--		not is_set(ConferenceURL) and											-- TODO: keep this here? conference as part of cite web or cite podcast?
--		not is_set(TranscriptURL) then											-- TODO: remove? |transcript-url= and |transcript= has separate test
		
		-- Test if cite web or cite podcast |url= is missing or empty 
		if in_array(config.CitationClass, {&quot;web&quot;,&quot;podcast&quot;, &quot;mailinglist&quot;}) then	
			table.insert( z.message_tail, { set_error( 'cite_web_url', {}, true ) } );
		end
		
		-- Test if accessdate is given without giving a URL
		if is_set(AccessDate) and not is_set(ChapterURL)then					-- ChapterURL may be set when the others are not set; TODO: move this to a separate test?
			table.insert( z.message_tail, { set_error( 'accessdate_missing_url', {}, true ) } );
			AccessDate = '';
		end
	end

	local OriginalURL, OriginalFormat;											-- TODO: swap chapter and title here so that archive applies to most specific if both are set?
	DeadURL = DeadURL:lower();													-- used later when assembling archived text
	if is_set( ArchiveURL ) then
		if is_set (URL) then
			OriginalURL = URL;													-- save copy of original source URL
			OriginalFormat = Format;											-- and original |format=
			if 'no' ~= DeadURL then												-- if URL set then archive-url applies to it
				URL = ArchiveURL												-- swap-in the archive's url
				URLorigin = A:ORIGIN('ArchiveURL')								-- name of archive url parameter for error messages
				Format = ArchiveFormat or '';									-- swap in archive's format
			end
		elseif is_set (ChapterURL) then 										-- URL not set so if chapter-url is set apply archive url to it
			OriginalURL = ChapterURL;											-- save copy of source chapter's url for archive text
			OriginalFormat = ChapterFormat;										-- and original |format=
			if 'no' ~= DeadURL then
				ChapterURL = ArchiveURL											-- swap-in the archive's url
				URLorigin = A:ORIGIN('ArchiveURL')								-- name of archive url parameter for error messages
				ChapterFormat = ArchiveFormat or '';							-- swap in archive's format
			end
		end
	end

	if in_array(config.CitationClass, {&quot;web&quot;,&quot;news&quot;,&quot;journal&quot;,&quot;pressrelease&quot;,&quot;podcast&quot;, &quot;newsgroup&quot;, 'arxiv'}) or
		('citation' == config.CitationClass and is_set (Periodical) and not is_set (Encyclopedia)) then
			if is_set (Chapter) or is_set (TransChapter) or is_set (ChapterURL)then	-- chapter parameters not supported for these citation types
				table.insert( z.message_tail, { set_error( 'chapter_ignored', {}, true ) } );		-- add error message
				Chapter = '';														-- set to empty string to be safe with concatenation
				TransChapter = '';
				ChapterURL = '';
			end
	else																		-- otherwise, format chapter / article title
		Chapter = format_chapter_title (Chapter, TransChapter, ChapterURL, ChapterURLorigin);
		if is_set (Chapter) then
			if 'map' == config.CitationClass and is_set (TitleType) then
				Chapter = Chapter .. ' ' .. TitleType;
			end
			Chapter = Chapter .. ChapterFormat .. sepc .. ' ';
		end
	end

	-- Format main title.
	if is_set(TitleLink) and is_set(Title) then
		Title = &quot;[[&quot; .. TitleLink .. &quot;|&quot; .. Title .. &quot;]]&quot;
	end

	if in_array(config.CitationClass, {&quot;web&quot;,&quot;news&quot;,&quot;journal&quot;,&quot;pressrelease&quot;,&quot;podcast&quot;, &quot;newsgroup&quot;, &quot;mailinglist&quot;, 'arxiv'}) or
		('citation' == config.CitationClass and is_set (Periodical) and not is_set (Encyclopedia)) or
		('map' == config.CitationClass and is_set (Periodical)) then			-- special case for cite map when the map is in a periodical treat as an article
			Title = kern_quotes (Title);										-- if necessary, separate title's leading and trailing quote marks from Module provided quote marks
			Title = wrap_style ('quoted-title', Title);
	
			Title = script_concatenate (Title, ScriptTitle);					-- &lt;bdi&gt; tags, lang atribute, categorization, etc; must be done after title is wrapped
			TransTitle= wrap_style ('trans-quoted-title', TransTitle );
	elseif 'report' == config.CitationClass then								-- no styling for cite report
		Title = script_concatenate (Title, ScriptTitle);						-- &lt;bdi&gt; tags, lang atribute, categorization, etc; must be done after title is wrapped
		TransTitle= wrap_style ('trans-quoted-title', TransTitle );				-- for cite report, use this form for trans-title
	else
		Title = wrap_style ('italic-title', Title);
		Title = script_concatenate (Title, ScriptTitle);						-- &lt;bdi&gt; tags, lang atribute, categorization, etc; must be done after title is wrapped
		TransTitle = wrap_style ('trans-italic-title', TransTitle);
	end

	TransError = &quot;&quot;;
	if is_set(TransTitle) then
		if is_set(Title) then
			TransTitle = &quot; &quot; .. TransTitle;
		else
			TransError = &quot; &quot; .. set_error( 'trans_missing_title' );
		end
	end
	
	Title = Title .. TransTitle;
	
	if is_set(Title) then
		if not is_set(TitleLink) and is_set(URL) then 
			Title = external_link( URL, Title ) .. TransError .. Format;
			URL = &quot;&quot;;
			Format = &quot;&quot;;
		else
			Title = Title .. TransError;
		end
	end

	if is_set(Place) then
		Place = &quot; &quot; .. wrap_msg ('written', Place, use_lowercase) .. sepc .. &quot; &quot;;
	end

	if is_set (Conference) then
		if is_set (ConferenceURL) then
			Conference = external_link( ConferenceURL, Conference );
		end
		Conference = sepc .. &quot; &quot; .. Conference .. ConferenceFormat;
	elseif is_set(ConferenceURL) then
		Conference = sepc .. &quot; &quot; .. external_link( ConferenceURL, nil, ConferenceURLorigin );
	end

	if not is_set(Position) then
		local Minutes = A['Minutes'];
		if is_set(Minutes) then
			Position = &quot; &quot; .. Minutes .. &quot; &quot; .. cfg.messages['minutes'];
		else
			local Time = A['Time'];
			if is_set(Time) then
				local TimeCaption = A['TimeCaption']
				if not is_set(TimeCaption) then
					TimeCaption = cfg.messages['event'];
					if sepc ~= '.' then
						TimeCaption = TimeCaption:lower();
					end
				end
				Position = &quot; &quot; .. TimeCaption .. &quot; &quot; .. Time;
			end
		end
	else
		Position = &quot; &quot; .. Position;
		At = '';
	end
	
	if not is_set(Page) then
		if is_set(Pages) then
			if is_set(Periodical) and
				not in_array(config.CitationClass, {&quot;encyclopaedia&quot;,&quot;web&quot;,&quot;book&quot;,&quot;news&quot;,&quot;podcast&quot;}) then
				Pages = &quot;: &quot; .. Pages;
			elseif tonumber(Pages) ~= nil then
				Pages = sepc ..&quot; &quot; .. PPrefix .. Pages;
			else
				Pages = sepc ..&quot; &quot; .. PPPrefix .. Pages;
			end
		end
	else
		if is_set(Periodical) and
			not in_array(config.CitationClass, {&quot;encyclopaedia&quot;,&quot;web&quot;,&quot;book&quot;,&quot;news&quot;,&quot;podcast&quot;}) then
			Page = &quot;: &quot; .. Page;
		else
			Page = sepc ..&quot; &quot; .. PPrefix .. Page;
		end
	end

	if 'map' == config.CitationClass then										-- cite map oddity done after COinS call (and with other in-source locators)
		if is_set (Sheet) or is_set (Sheets) then
			local err_msg1 = 'sheet=, &amp;#124;sheets';							-- default error message in case any of page pages or at are set
			local err_msg2;
			if is_set (Page) or is_set (Pages) or is_set (At) then				-- are any set?
				err_msg2 = 'page=, &amp;#124;pages=, &amp;#124;at';						-- a generic error message
				Page = ''; Pages = ''; At = '';
			elseif is_set (Sheet) and is_set (Sheets) then						-- if both are set make error message
				err_msg1 = 'sheet';
				err_msg2 = 'sheets';
			end
			if is_set (err_msg2) then
				table.insert( z.message_tail, { set_error( 'redundant_parameters', {wrap_style ('parameter', err_msg1) .. ' and ' .. wrap_style ('parameter', err_msg2)}, true ) } );		-- add error message
			end
			if not is_set (Sheet) then											-- do sheet static text and formatting; Sheet has priority over Sheets if both provided
				if is_set (Sheets) then
					if is_set (Periodical) then
						Sheet = &quot;: Sheets &quot; .. Sheets;							-- because Sheet has priority, no need to support both later on
					else
						Sheet = sepc .. &quot; Sheets &quot; .. Sheets;
					end
				end
			else
				if is_set (Periodical) then
					Sheet = &quot;: Sheet &quot; .. Sheet;
				else
					Sheet = sepc .. &quot; Sheet &quot; .. Sheet;
				end
			end
		end
	end

	At = is_set(At) and (sepc .. &quot; &quot; .. At) or &quot;&quot;;
	Position = is_set(Position) and (sepc .. &quot; &quot; .. Position) or &quot;&quot;;
	if config.CitationClass == 'map' then
		local Section = A['Section'];
		local Sections = A['Sections'];
		local Inset = A['Inset'];
		
		if is_set( Inset ) then
			Inset = sepc .. &quot; &quot; .. wrap_msg ('inset', Inset, use_lowercase);
		end			

		if is_set( Sections ) then
			Section = sepc .. &quot; &quot; .. wrap_msg ('sections', Sections, use_lowercase);
		elseif is_set( Section ) then
			Section = sepc .. &quot; &quot; .. wrap_msg ('section', Section, use_lowercase);
		end
		At = At .. Inset .. Section;		
	end	

	if is_set (Language) then
		Language = language_parameter (Language);								-- format, categories, name from ISO639-1, etc
	else
		Language=&quot;&quot;;															-- language not specified so make sure this is an empty string;
	end

	Others = is_set(Others) and (sepc .. &quot; &quot; .. Others) or &quot;&quot;;

	TitleNote = is_set(TitleNote) and (sepc .. &quot; &quot; .. TitleNote) or &quot;&quot;;
	if is_set (Edition) then
		if Edition:match ('[Ee]d%.?$') or Edition:match ('[Ee]dition$') then
			add_maint_cat ('extra_text', 'edition');
		end
		Edition = &quot; &quot; .. wrap_msg ('edition', Edition);
	else
		Edition = '';
	end
	Issue = is_set(Issue) and (&quot; (&quot; .. Issue .. &quot;)&quot;) or &quot;&quot;;
	Series = is_set(Series) and (sepc .. &quot; &quot; .. Series) or &quot;&quot;;
	OrigYear = is_set(OrigYear) and (&quot; [&quot; .. OrigYear .. &quot;]&quot;) or &quot;&quot;;
	Agency = is_set(Agency) and (sepc .. &quot; &quot; .. Agency) or &quot;&quot;;

	if is_set(Volume) then
		if ( mw.ustring.len(Volume) &gt; 4 )
		  then Volume = sepc ..&quot; &quot; .. Volume;
		  else Volume = &quot; &lt;b&gt;&quot; .. hyphen_to_dash(Volume) .. &quot;&lt;/b&gt;&quot;;
		end
	end

	------------------------------------ totally unrelated data
	if is_set(Via) then
		Via = &quot; &quot; .. wrap_msg ('via', Via);
	end

--[[
Subscription implies paywall; Registration does not.  If both are used in a citation, the subscription required link
note is displayed. There are no error messages for this condition.

]]
	if in_array(SubscriptionRequired:lower(), {'yes', 'true', 'y'}) then
		SubscriptionRequired = sepc .. &quot; &quot; .. cfg.messages['subscription'];		-- subscription required message
	elseif in_array(RegistrationRequired:lower(), {'yes', 'true', 'y'}) then
		SubscriptionRequired = sepc .. &quot; &quot; .. cfg.messages['registration'];		-- registration required message
	else
		SubscriptionRequired = '';												-- either or both might be set to something other than yes true y
	end

	if is_set(AccessDate) then
		local retrv_text = &quot; &quot; .. cfg.messages['retrieved']

		AccessDate = nowrap_date (AccessDate);									-- wrap in nowrap span if date in appropriate format
		if (sepc ~= &quot;.&quot;) then retrv_text = retrv_text:lower() end				-- if 'citation', lower case
		AccessDate = substitute (retrv_text, AccessDate);						-- add retrieved text
																				-- neither of these work; don't know why; it seems that substitute() isn't being called	
		AccessDate = substitute (cfg.presentation['accessdate'], {sepc, AccessDate});	-- allow editors to hide accessdates
	end
	
	if is_set(ID) then ID = sepc ..&quot; &quot;.. ID; end
   	if &quot;thesis&quot; == config.CitationClass and is_set(Docket) then
		ID = sepc ..&quot; Docket &quot;.. Docket .. ID;
	end
   	if &quot;report&quot; == config.CitationClass and is_set(Docket) then					-- for cite report when |docket= is set
		ID = sepc .. ' ' .. Docket;												-- overwrite ID even if |id= is set
	end

	ID_list = build_id_list( ID_list, {DoiBroken = DoiBroken, ASINTLD = ASINTLD, IgnoreISBN = IgnoreISBN, Embargo=Embargo, Class = Class} );

	if is_set(URL) then
		URL = &quot; &quot; .. external_link( URL, nil, URLorigin );
	end

	if is_set(Quote) then
		if Quote:sub(1,1) == '&quot;' and Quote:sub(-1,-1) == '&quot;' then
			Quote = Quote:sub(2,-2);
		end
		Quote = sepc ..&quot; &quot; .. wrap_style ('quoted-text', Quote ); 				-- wrap in &lt;q&gt;...&lt;/q&gt; tags
		PostScript = &quot;&quot;;														-- CS1 does not supply terminal punctuation when |quote= is set
	end
	
	local Archived
	if is_set(ArchiveURL) then
		if not is_set(ArchiveDate) then
			ArchiveDate = set_error('archive_missing_date');
		end
		if &quot;no&quot; == DeadURL then
			local arch_text = cfg.messages['archived'];
			if sepc ~= &quot;.&quot; then arch_text = arch_text:lower() end
			Archived = sepc .. &quot; &quot; .. substitute( cfg.messages['archived-not-dead'],
				{ external_link( ArchiveURL, arch_text ) .. ArchiveFormat, ArchiveDate } );
			if not is_set(OriginalURL) then
				Archived = Archived .. &quot; &quot; .. set_error('archive_missing_url');							   
			end
		elseif is_set(OriginalURL) then
			local arch_text = cfg.messages['archived-dead'];
			if sepc ~= &quot;.&quot; then arch_text = arch_text:lower() end
			Archived = sepc .. &quot; &quot; .. substitute( arch_text,
				{ external_link( OriginalURL, cfg.messages['original'] ) .. OriginalFormat, ArchiveDate } );	-- format already styled
		else
			local arch_text = cfg.messages['archived-missing'];
			if sepc ~= &quot;.&quot; then arch_text = arch_text:lower() end
			Archived = sepc .. &quot; &quot; .. substitute( arch_text, 
				{ set_error('archive_missing_url'), ArchiveDate } );
		end
	elseif is_set (ArchiveFormat) then
		Archived = ArchiveFormat;												-- if set and ArchiveURL not set ArchiveFormat has error message
	else
		Archived = &quot;&quot;
	end
	
	local Lay = '';
	if is_set(LayURL) then
		if is_set(LayDate) then LayDate = &quot; (&quot; .. LayDate .. &quot;)&quot; end
		if is_set(LaySource) then 
			LaySource = &quot; &amp;ndash; ''&quot; .. safe_for_italics(LaySource) .. &quot;''&quot;;
		else
			LaySource = &quot;&quot;;
		end
		if sepc == '.' then
			Lay = sepc .. &quot; &quot; .. external_link( LayURL, cfg.messages['lay summary'] ) .. LayFormat .. LaySource .. LayDate
		else
			Lay = sepc .. &quot; &quot; .. external_link( LayURL, cfg.messages['lay summary']:lower() ) .. LayFormat .. LaySource .. LayDate
		end			
	elseif is_set (LayFormat) then												-- Test if |lay-format= is given without giving a |lay-url=
		Lay = sepc .. LayFormat;												-- if set and LayURL not set, then LayFormat has error message
	end

	if is_set(Transcript) then
		if is_set(TranscriptURL) then
			Transcript = external_link( TranscriptURL, Transcript );
		end
		Transcript = sepc .. ' ' .. Transcript .. TranscriptFormat;
	elseif is_set(TranscriptURL) then
		Transcript = external_link( TranscriptURL, nil, TranscriptURLorigin );
	end

	local Publisher;
	if is_set(Periodical) and
		not in_array(config.CitationClass, {&quot;encyclopaedia&quot;,&quot;web&quot;,&quot;pressrelease&quot;,&quot;podcast&quot;}) then
		if is_set(PublisherName) then
			if is_set(PublicationPlace) then
				Publisher = PublicationPlace .. &quot;: &quot; .. PublisherName;
			else
				Publisher = PublisherName;  
			end
		elseif is_set(PublicationPlace) then
			Publisher= PublicationPlace;
		else 
			Publisher = &quot;&quot;;
		end
		if is_set(PublicationDate) then
			if is_set(Publisher) then
				Publisher = Publisher .. &quot;, &quot; .. wrap_msg ('published', PublicationDate);
			else
				Publisher = PublicationDate;
			end
		end
		if is_set(Publisher) then
			Publisher = &quot; (&quot; .. Publisher .. &quot;)&quot;;
		end
	else
		if is_set(PublicationDate) then
			PublicationDate = &quot; (&quot; .. wrap_msg ('published', PublicationDate) .. &quot;)&quot;;
		end
		if is_set(PublisherName) then
			if is_set(PublicationPlace) then
				Publisher = sepc .. &quot; &quot; .. PublicationPlace .. &quot;: &quot; .. PublisherName .. PublicationDate;
			else
				Publisher = sepc .. &quot; &quot; .. PublisherName .. PublicationDate;  
			end			
		elseif is_set(PublicationPlace) then 
			Publisher= sepc .. &quot; &quot; .. PublicationPlace .. PublicationDate;
		else 
			Publisher = PublicationDate;
		end
	end
	
	-- Several of the above rely upon detecting this as nil, so do it last.
	if is_set(Periodical) then
		if is_set(Title) or is_set(TitleNote) then 
			Periodical = sepc .. &quot; &quot; .. wrap_style ('italic-title', Periodical) 
		else 
			Periodical = wrap_style ('italic-title', Periodical)
		end
	end

--[[
Handle the oddity that is cite speech.  This code overrides whatever may be the value assigned to TitleNote (through |department=) and forces it to be &quot; (Speech)&quot; so that
the annotation directly follows the |title= parameter value in the citation rather than the |event= parameter value (if provided).
]]
	if &quot;speech&quot; == config.CitationClass then				-- cite speech only
		TitleNote = &quot; (Speech)&quot;;							-- annotate the citation
		if is_set (Periodical) then							-- if Periodical, perhaps because of an included |website= or |journal= parameter 
			if is_set (Conference) then						-- and if |event= is set
				Conference = Conference .. sepc .. &quot; &quot;;		-- then add appropriate punctuation to the end of the Conference variable before rendering
			end
		end
	end

	-- Piece all bits together at last.  Here, all should be non-nil.
	-- We build things this way because it is more efficient in LUA
	-- not to keep reassigning to the same string variable over and over.

	local tcommon
	if in_array(config.CitationClass, {&quot;journal&quot;,&quot;citation&quot;}) and is_set(Periodical) then
		if is_set(Others) then Others = Others .. sepc .. &quot; &quot; end
		tcommon = safe_join( {Others, Title, TitleNote, Conference, Periodical, Format, TitleType, Series, 
			Language, Edition, Publisher, Agency, Volume, Issue}, sepc );
		
	elseif 'map' == config.CitationClass then									-- special cases for cite map
		if is_set (Chapter) then												-- map in a book; TitleType is part of Chapter
			tcommon = safe_join( {Title, Format, Edition, Scale, Series, Language, Cartography, Others, Publisher, Volume}, sepc );
		elseif is_set (Periodical) then											-- map in a periodical
			tcommon = safe_join( {Title, TitleType, Format, Periodical, Scale, Series, Language, Cartography, Others, Publisher, Volume, Issue}, sepc );
		else																	-- a sheet or stand-alone map
			tcommon = safe_join( {Title, TitleType, Format, Edition, Scale, Series, Language, Cartography, Others, Publisher}, sepc );
		end
		
	elseif 'episode' == config.CitationClass then								-- special case for cite episode
		tcommon = safe_join( {Title, TitleNote, TitleType, Series, Transcript, Language, Edition, Publisher}, sepc );
	else																		-- all other CS1 templates
		tcommon = safe_join( {Title, TitleNote, Conference, Periodical, Format, TitleType, Series, Language, 
			Volume, Issue, Others, Edition, Publisher, Agency}, sepc );
	end
	
	if #ID_list &gt; 0 then
		ID_list = safe_join( { sepc .. &quot; &quot;,  table.concat( ID_list, sepc .. &quot; &quot; ), ID }, sepc );
	else
		ID_list = ID;
	end
	
	local idcommon = safe_join( { ID_list, URL, Archived, AccessDate, Via, SubscriptionRequired, Lay, Quote }, sepc );
	local text;
	local pgtext = Position .. Sheet .. Page .. Pages .. At;
	
	if is_set(Authors) then
		if is_set(Coauthors) then
			local sep = '; ';
			if 'vanc' == NameListFormat then
				sep = ', ';
			end
			Authors = Authors .. sep .. Coauthors;
		end
		if is_set(Date) then
			Date = &quot; (&quot;..Date..&quot;)&quot; .. OrigYear .. sepc .. &quot; &quot;
		elseif string.sub(Authors,-1,-1) == sepc then
			Authors = Authors .. &quot; &quot;
		else
			Authors = Authors .. sepc .. &quot; &quot;
		end
		if is_set(Editors) then
			local in_text = &quot; &quot;;
			local post_text = &quot;&quot;;
			if is_set(Chapter) then
				in_text = in_text .. cfg.messages['in'] .. &quot; &quot;
			else
				if EditorCount &lt;= 1 then
					post_text = &quot;, &quot; .. cfg.messages['editor'];
				else
					post_text = &quot;, &quot; .. cfg.messages['editors'];
				end
			end 
			if (sepc ~= '.') then in_text = in_text:lower() end
			Editors = in_text .. Editors .. post_text;
			if (string.sub(Editors,-1,-1) == sepc) or (string.sub(Editors,-3,-1) == sepc .. ']]') then	-- if last editor name ends with sepc char
				Editors = Editors .. &quot; &quot;;										-- don't add another
			else
				Editors = Editors .. sepc .. &quot; &quot;								-- otherwise terninate the editor list
			end
		end
		text = safe_join( {Authors, Date, Chapter, Place, Editors, tcommon }, sepc );
		text = safe_join( {text, pgtext, idcommon}, sepc );
	elseif is_set(Editors) then
		if is_set(Date) then
			if EditorCount &lt;= 1 then
				Editors = Editors .. &quot;, &quot; .. cfg.messages['editor'];
			else
				Editors = Editors .. &quot;, &quot; .. cfg.messages['editors'];
			end
			Date = &quot; (&quot; .. Date ..&quot;)&quot; .. OrigYear .. sepc .. &quot; &quot;
		else
			if EditorCount &lt;= 1 then
				Editors = Editors .. &quot; (&quot; .. cfg.messages['editor'] .. &quot;)&quot; .. sepc .. &quot; &quot;
			else
				Editors = Editors .. &quot; (&quot; .. cfg.messages['editors'] .. &quot;)&quot; .. sepc .. &quot; &quot;
			end
		end
		text = safe_join( {Editors, Date, Chapter, Place, tcommon}, sepc );
		text = safe_join( {text, pgtext, idcommon}, sepc );
	else
		if is_set(Date) then
			if ( string.sub(tcommon,-1,-1) ~= sepc )
			  then Date = sepc ..&quot; &quot; .. Date .. OrigYear
			  else Date = &quot; &quot; .. Date .. OrigYear
			end
		end
		if config.CitationClass==&quot;journal&quot; and is_set(Periodical) then
			text = safe_join( {Chapter, Place, tcommon}, sepc );
			text = safe_join( {text, pgtext, Date, idcommon}, sepc );
		else
			text = safe_join( {Chapter, Place, tcommon, Date}, sepc );
			text = safe_join( {text, pgtext, idcommon}, sepc );
		end
	end
	
	if is_set(PostScript) and PostScript ~= sepc then
		text = safe_join( {text, sepc}, sepc );  --Deals with italics, spaces, etc.
		text = text:sub(1,-sepc:len()-1);
	end	
	
	text = safe_join( {text, PostScript}, sepc );

	-- Now enclose the whole thing in a &lt;span/&gt; element
	local options = {};
	
	if is_set(config.CitationClass) and config.CitationClass ~= &quot;citation&quot; then
		options.class = &quot;citation &quot; .. config.CitationClass;
	else
		options.class = &quot;citation&quot;;
	end
	
	if is_set(Ref) and Ref:lower() ~= &quot;none&quot; then
		local id = Ref
		if ( &quot;harv&quot; == Ref ) then
			local names = {} --table of last names &amp; year
			if #a &gt; 0 then
				for i,v in ipairs(a) do 
					names[i] = v.last 
					if i == 4 then break end
				end
			elseif #e &gt; 0 then
				for i,v in ipairs(e) do 
					names[i] = v.last 
					if i == 4 then break end				
				end
			end
			names[ #names + 1 ] = first_set(Year, anchor_year);	-- Year first for legacy citations and for YMD dates that require disambiguation
			id = anchor_id(names)
		end
		options.id = id;
	end
	
	if string.len(text:gsub(&quot;&lt;span[^&gt;/]*&gt;.-&lt;/span&gt;&quot;, &quot;&quot;):gsub(&quot;%b&lt;&gt;&quot;,&quot;&quot;)) &lt;= 2 then
		z.error_categories = {};
		text = set_error('empty_citation');
		z.message_tail = {};
	end
	
	if is_set(options.id) then 
		text = '&lt;span id=&quot;' .. mw.uri.anchorEncode(options.id) ..'&quot; class=&quot;' .. mw.text.nowiki(options.class) .. '&quot;&gt;' .. text .. &quot;&lt;/span&gt;&quot;;
	else
		text = '&lt;span class=&quot;' .. mw.text.nowiki(options.class) .. '&quot;&gt;' .. text .. &quot;&lt;/span&gt;&quot;;
	end		

	local empty_span = '&lt;span style=&quot;display:none;&quot;&gt;&amp;nbsp;&lt;/span&gt;';
	
	-- Note: Using display: none on then COinS span breaks some clients.
	local OCinS = '&lt;span title=&quot;' .. OCinSoutput .. '&quot; class=&quot;Z3988&quot;&gt;' .. empty_span .. '&lt;/span&gt;';
	text = text .. OCinS;
	
	if #z.message_tail ~= 0 then
		text = text .. &quot; &quot;;
		for i,v in ipairs( z.message_tail ) do
			if is_set(v[1]) then
				if i == #z.message_tail then
					text = text .. error_comment( v[1], v[2] );
				else
					text = text .. error_comment( v[1] .. &quot;; &quot;, v[2] );
				end
			end
		end
	end

	if #z.maintenance_cats ~= 0 then
		text = text .. '&lt;span class=&quot;citation-comment&quot; style=&quot;display:none; color:#33aa33&quot;&gt;';
		for _, v in ipairs( z.maintenance_cats ) do								-- append maintenance categories
			text = text .. ' ' .. v .. ' ([[:Category:' .. v ..'|link]])';
		end
		text = text .. '&lt;/span&gt;';	-- maintenance mesages (realy just the names of the categories for now)
	end
	
	no_tracking_cats = no_tracking_cats:lower();
	if in_array(no_tracking_cats, {&quot;&quot;, &quot;no&quot;, &quot;false&quot;, &quot;n&quot;}) then
		for _, v in ipairs( z.error_categories ) do
			text = text .. '[[Category:' .. v ..']]';
		end
		for _, v in ipairs( z.maintenance_cats ) do								-- append maintenance categories
			text = text .. '[[Category:' .. v ..']]';
		end
		for _, v in ipairs( z.properties_cats ) do								-- append maintenance categories
			text = text .. '[[Category:' .. v ..']]';
		end
	end
	
	return text
end

-- This is used by templates such as {{cite book}} to create the actual citation text.
function z.citation(frame)
	local pframe = frame:getParent()
	local validation;
	
	if nil ~= string.find (frame:getTitle(), 'sandbox', 1, true) then			-- did the {{#invoke:}} use sandbox version?
		cfg = mw.loadData ('Module:Citation/CS1/Configuration/sandbox');		-- load sandbox versions of Configuration and Whitelist and ...
		whitelist = mw.loadData ('Module:Citation/CS1/Whitelist/sandbox');
		validation = require ('Module:Citation/CS1/Date_validation/sandbox');	-- ... sandbox version of date validation code

	else																		-- otherwise
		cfg = mw.loadData ('Module:Citation/CS1/Configuration');				-- load live versions of Configuration and Whitelist and ...
		whitelist = mw.loadData ('Module:Citation/CS1/Whitelist');
		validation = require ('Module:Citation/CS1/Date_validation');			-- ... live version of date validation code
	end

	dates = validation.dates;													-- imported functions
	year_date_check = validation.year_date_check;

	local args = {};
	local suggestions = {};
	local error_text, error_state;

	local config = {};
	for k, v in pairs( frame.args ) do
		config[k] = v;
		args[k] = v;	   
	end	

	for k, v in pairs( pframe.args ) do
		if v ~= '' then
			if not validate( k ) then			
				error_text = &quot;&quot;;
				if type( k ) ~= 'string' then
					-- Exclude empty numbered parameters
					if v:match(&quot;%S+&quot;) ~= nil then
						error_text, error_state = set_error( 'text_ignored', {v}, true );
					end
				elseif validate( k:lower() ) then 
					error_text, error_state = set_error( 'parameter_ignored_suggest', {k, k:lower()}, true );
				else
					if #suggestions == 0 then
						suggestions = mw.loadData( 'Module:Citation/CS1/Suggestions' );
					end
					if suggestions[ k:lower() ] ~= nil then
						error_text, error_state = set_error( 'parameter_ignored_suggest', {k, suggestions[ k:lower() ]}, true );
					else
						error_text, error_state = set_error( 'parameter_ignored', {k}, true );
					end
				end				  
				if error_text ~= '' then
					table.insert( z.message_tail, {error_text, error_state} );
				end				
			end
			args[k] = v;
		elseif args[k] ~= nil or (k == 'postscript') then
			args[k] = v;
		end		
	end	
	
	return citation0( config, args)
end

return z</text>
      <sha1>6i2ehmhjtybprdyct0atqe1o869u02e</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Configuration</title>
    <ns>828</ns>
    <id>39043527</id>
    <revision>
      <id>673001031</id>
      <parentid>657017662</parentid>
      <timestamp>2015-07-25T10:24:15Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>Synch from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="29507">
local citation_config = {};

-- override &lt;code&gt;...&lt;/code&gt; styling to remove color, border, and padding.  &lt;code&gt; css is specified here:
-- https://git.wikimedia.org/blob/mediawiki%2Fcore.git/69cd73811f7aadd093050dbf20ed70ef0b42a713/skins%2Fcommon%2FcommonElements.css#L199
local code_style=&quot;color:inherit; border:inherit; padding:inherit;&quot;;

--[[--------------------------&lt; U N C A T E G O R I Z E D _ N A M E S P A C E S &gt;------------------------------

List of namespaces that should not be included in citation error categories.  Same as setting notracking = true by default

Note: Namespace names should use underscores instead of spaces.

]]
local uncategorized_namespaces = { 'User', 'Talk', 'User_talk', 'Wikipedia_talk', 'File_talk', 'Template_talk',
	'Help_talk', 'Category_talk', 'Portal_talk', 'Book_talk', 'Draft', 'Draft_talk', 'Education_Program_talk', 
	'Module_talk', 'MediaWiki_talk' };

local uncategorized_subpages = {'/[Ss]andbox', '/[Tt]estcases'};		-- list of Lua patterns found in page names of pages we should not categorize

--[[--------------------------&lt; M E S S A G E S &gt;--------------------------------------------------------------

Translation table

The following contains fixed text that may be output as part of a citation.
This is separated from the main body to aid in future translations of this
module.

]]

local messages = {
  ['published'] = 'published $1',
  ['lay summary'] = 'Lay summary',
  ['retrieved'] = 'Retrieved $1',
  ['inactive'] = 'inactive',
  ['archived-dead'] = 'Archived from $1 on $2',
  ['archived-not-dead'] = '$1 from the original on $2',
  ['archived-missing'] = 'Archived from the original$1 on $2',
  ['archived'] = 'Archived',
  ['original'] = 'the original',
  ['editor'] = 'ed.',
  ['editors'] = 'eds.', 
  ['edition'] = '($1 ed.)', 
  ['episode'] = 'Episode $1',
  ['season'] = 'Season $1', 
  ['series'] = 'Series $1',
  ['cartography'] = 'Cartography by $1',
  ['section'] = '§ $1',
  ['sections'] = '§§ $1',
  ['inset'] = '$1 inset',
  ['written'] = 'Written at $1',
  ['in'] = 'In',
  ['et al'] = 'et al.', 
  
  ['subscription'] = '&lt;span style=&quot;font-size:0.95em; font-size:90%; color:#555&quot;&gt;(subscription required (&lt;span title=&quot;Sources are not required to be available online. Online sources do not have to be freely available. The site may require a paid subscription.&quot; style=&quot;border-bottom:1px dotted;cursor:help&quot;&gt;help&lt;/span&gt;))&lt;/span&gt;' ..
  	'[[Category:Pages containing links to subscription-only content]]', 

  ['registration']='&lt;span style=&quot;font-size:0.95em; font-size:90%; color:#555&quot;&gt;(registration required (&lt;span title=&quot;Sources are not required to be available online. Online sources do not have to be freely available. The site may require registration.&quot; style=&quot;border-bottom:1px dotted;cursor:help&quot;&gt;help&lt;/span&gt;))&lt;/span&gt;' ..
  	'[[Category:Pages with login required references or sources]]',
  
  ['language'] = '(in $1)', 
  ['via'] = &quot; &amp;ndash; via $1&quot;,
  ['event'] = 'Event occurs at',
  ['minutes'] = 'minutes in', 

  ['parameter-separator'] = ', ',
  ['parameter-final-separator'] = ', and ',
  ['parameter-pair-separator'] = ' and ',

  -- Determines the location of the help page
  ['help page link'] = 'Help:CS1 errors',
  ['help page label'] = 'help',
  
  -- Internal errors (should only occur if configuration is bad)
  ['undefined_error'] = 'Called with an undefined error condition',
  ['unknown_manual_ID'] = 'Unrecognized manual ID mode',
  ['unknown_ID_mode'] = 'Unrecognized ID mode',
  ['unknown_argument_map'] = 'Argument map not defined for this variable',
  ['bare_url_no_origin'] = 'Bare url found but origin indicator is nil or empty',
}

--[[--------------------------&lt; P R E S E N T A T I O N &gt;------------------------------------------------------

Fixed presentation markup.  Originally part of citation_config.messages it has been moved into its own, more semantically
correct place.

]]
local presentation = 
	{
	-- Error output
	-- .error class is specified at https://git.wikimedia.org/blob/mediawiki%2Fcore.git/9553bd02a5595da05c184f7521721fb1b79b3935/skins%2Fcommon%2Fshared.css#L538
	-- .citation-comment class is specified at Help:CS1_errors#Controlling_error_message_display
	['hidden-error'] = '&lt;span style=&quot;display:none;font-size:100%&quot; class=&quot;error citation-comment&quot;&gt;$1&lt;/span&gt;',
	['visible-error'] = '&lt;span style=&quot;font-size:100%&quot; class=&quot;error citation-comment&quot;&gt;$1&lt;/span&gt;',

	['accessdate'] = '&lt;span class=&quot;reference-accessdate&quot;&gt;$1$2&lt;/span&gt;',			-- to allow editors to hide accessdate using personal css

	['bdi'] = '&lt;bdi$1&gt;$2&lt;/bdi&gt;',												-- bidirectional isolation used with |script-title= and the like

	['format'] = ' &lt;span style=&quot;font-size:85%;&quot;&gt;($1)&lt;/span&gt;',					-- for |format=, |chapter-format=, etc

	['italic-title'] = &quot;''$1''&quot;,

	['kern-left'] = '&lt;span style=&quot;padding-left:0.2em;&quot;&gt;$1&lt;/span&gt;$2',			-- spacing to use when title contains leading single or double quote mark
	['kern-right'] = '$1&lt;span style=&quot;padding-right:0.2em;&quot;&gt;$2&lt;/span&gt;',			-- spacing to use when title contains trailing single or double quote mark

	['nowrap1'] = '&lt;span class=&quot;nowrap&quot;&gt;$1&lt;/span&gt;',								-- for nowrapping an item: &lt;span ...&gt;yyyy-mm-dd&lt;/span&gt;
	['nowrap2'] = '&lt;span class=&quot;nowrap&quot;&gt;$1&lt;/span&gt; $2',							-- for nowrapping portions of an item: &lt;span ...&gt;dd mmmm&lt;/span&gt; yyyy (note white space)
	
	['parameter'] = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;$1=&lt;/code&gt;',

	['quoted-text'] = '&lt;q&gt;$1&lt;/q&gt;',												-- for wrapping |quote= content
	['quoted-title'] = '&quot;$1&quot;',

	['trans-italic-title'] = &quot;&amp;#91;''$1''&amp;#93;&quot;,
	['trans-quoted-title'] = &quot;&amp;#91;$1&amp;#93;&quot;,
	}

--[[--------------------------&lt; A L I A S E S &gt;----------------------------------------------------------------

Aliases table for commonly passed parameters

]]

local aliases = {
	['AccessDate'] = {'access-date', 'accessdate'},
	['Agency'] = 'agency',
	['AirDate'] = {'air-date', 'airdate'},
	['ArchiveDate'] = {'archive-date', 'archivedate'},
	['ArchiveFormat'] = 'archive-format',
	['ArchiveURL'] = {'archive-url', 'archiveurl'},
	['ASINTLD'] = {'ASIN-TLD', 'asin-tld'},
	['At'] = 'at',
	['Authors'] = {'authors', 'people', 'host', 'credits'},
	['AuthorFormat'] = {'author-format', 'authorformat'},						-- deprecated in favor of NameListFormat;
	['AuthorSeparator'] = 'author-separator',									-- deprecated
	['AuthorNameSeparator'] = 'author-name-separator',							-- deprecated
	['Began'] = 'began',														-- cite episode and cite series
	['BookTitle'] = {'book-title', 'booktitle'},
	['Callsign'] = {'call-sign', 'callsign'},									-- cite interview
	['Cartography'] = 'cartography',
	['Chapter'] = {'chapter', 'contribution', 'entry', 'article', 'section'},
	['ChapterFormat'] = {'chapter-format', 'contribution-format', 'section-format'};
	['ChapterLink'] = {'chapter-link', 'chapterlink'},							-- deprecated; remove after 1 January 2015?
	['ChapterURL'] = {'chapter-url', 'chapterurl', 'contribution-url', 'contributionurl', 'section-url', 'sectionurl'},
	['City'] = 'city',															-- cite interview
	['Class'] = 'class',														-- cite arxiv and arxiv identifiers
	['Coauthors'] = {'coauthors', 'coauthor'},									-- coauthor and coauthors are deprecated; remove after 1 January 2015?
	['Conference'] = {'conference', 'event'},
	['ConferenceFormat'] = {'conference-format', 'event-format'},
	['ConferenceURL'] = {'conference-url', 'conferenceurl', 'event-url', 'eventurl'},
	['Date'] = {'date', 'air-date', 'airdate'},
	['DeadURL'] = {'dead-url', 'deadurl'},
	['Degree'] = 'degree',
	['DisplayAuthors'] = {'display-authors', 'displayauthors'},
	['DisplayEditors'] = {'display-editors', 'displayeditors'},
	['Docket'] = 'docket',
	['DoiBroken'] = {'doi-broken', 'doi-broken-date', 'doi-inactive-date', 'doi_brokendate', 'doi_inactivedate'},
	['Edition'] = 'edition',
	['Editors'] = 'editors',
	['EditorFormat'] = {'editor-format', 'editorformat'},						-- deprecated in favor of NameListFormat;
	['EditorSeparator'] = 'editor-separator',									-- deprecated
	['EditorNameSeparator'] = 'editor-name-separator',							-- deprecated
	['Embargo'] = 'embargo',
	['Encyclopedia'] = {'encyclopedia', 'encyclopaedia'},						-- this one only used by citation
	['Ended'] = 'ended',														-- cite episode and cite series
	['Episode'] = 'episode',													-- cite serial only TODO: make available to cite episode?
	['Format'] = 'format',
	['ID'] = {'id', 'ID'},
	['IgnoreISBN'] = {'ignore-isbn-error', 'ignoreisbnerror'},
	['Inset'] = 'inset',
	['Issue'] = {'issue', 'number'},
	['Language'] = {'language', 'in'},
	['LastAuthorAmp'] = {'last-author-amp', 'lastauthoramp'},
	['LayDate'] = {'lay-date', 'laydate'},
	['LayFormat'] = 'lay-format',
	['LaySource'] = {'lay-source', 'laysource'},
	['LayURL'] = {'lay-url', 'lay-summary', 'layurl', 'laysummary'},
	['MailingList'] = {'mailinglist', 'mailing-list'},							-- cite mailing list only
	['Map'] = 'map',															-- cite map only
	['MapFormat'] = 'map-format',												-- cite map only
	['MapURL'] = {'mapurl', 'map-url'},											-- cite map only
	['MessageID'] = 'message-id',
	['Minutes'] = 'minutes',
	['Mode'] = 'mode',
	['Month'] = 'month',														-- deprecated; remove after 1 January 2015?
	['NameListFormat'] = {'name-list-format', 'author-format', 'authorformat', 'editor-format', 'editorformat'},
	['NameSeparator'] = 'name-separator',										-- deprecated
	['Network'] = 'network',
	['NoPP'] = {'no-pp', 'nopp'},
	['NoTracking'] = {'template-doc-demo', 'template doc demo', 'no-cat', 'nocat', 
		'no-tracking', 'notracking'},
	['OrigYear'] = {'orig-year', 'origyear'},
	['Others'] = {'others', 'interviewer', 'interviewers'},
	['Page'] = {'p', 'page'},
	['Pages'] = {'pp', 'pages'},
	['Periodical'] = {'journal', 'newspaper', 'magazine', 'work',
		'website',  'periodical', 'encyclopedia', 'encyclopaedia', 'dictionary'},
	['Place'] = {'place', 'location'},
	['PPrefix'] = {'p-prefix', 'PPrefix'},
	['PPPrefix'] = 'pp-prefix',
	['Program'] = 'program',													-- cite interview
	['PostScript'] = 'postscript',
	['PublicationDate'] = {'publicationdate', 'publication-date'},
	['PublicationPlace'] = {'publication-place', 'publicationplace'},
	['PublisherName'] = {'publisher', 'distributor', 'institution', 'newsgroup'},
	['Quote'] = {'quote', 'quotation'},
	['Ref'] = {'ref', 'Ref'},
	['RegistrationRequired'] = 'registration',
	['Scale'] = 'scale',
	['ScriptTitle'] = 'script-title',
	['Section'] = 'section',
	['Season'] = 'season',
	['Sections'] = 'sections',													-- cite map only
	['Separator'] = 'separator',												-- deprecated in favor of Mode
	['Series'] = {'series', 'version'},
	['SeriesSeparator'] = 'series-separator',
	['SeriesLink'] = {'series-link', 'serieslink'},
	['SeriesNumber'] = {'series-number', 'series-no', 'seriesnumber', 'seriesno'},
	['Sheet'] = 'sheet',														-- cite map only
	['Sheets'] = 'sheets',														-- cite map only
	['Station'] = 'station',
	['SubscriptionRequired'] = 'subscription',
	['Time'] = 'time',
	['TimeCaption'] = {'time-caption', 'timecaption'},
	['Title'] = 'title',
	['TitleLink'] = {'title-link', 'episode-link', 'titlelink', 'episodelink'},
	['TitleNote'] = 'department',
	['TitleType'] = {'type', 'medium'},
	['TransChapter'] = {'trans-chapter', 'trans_chapter'},
	['TransMap'] = 'trans-map',													-- cite map only
	['Transcript'] = 'transcript',
	['TranscriptFormat'] = 'transcript-format',
	['TranscriptURL'] = {'transcript-url', 'transcripturl'},
	['TransTitle'] = {'trans-title', 'trans_title'},
	['URL'] = {'url', 'URL'},
	['Vauthors'] = 'vauthors',
	['Veditors'] = 'veditors',
	['Via'] = 'via',
	['Volume'] = 'volume',
	['Year'] = 'year',

	['AuthorList-First'] = {&quot;first#&quot;, &quot;given#&quot;, &quot;author-first#&quot;, &quot;author#-first&quot;},
	['AuthorList-Last'] = {&quot;last#&quot;, &quot;author#&quot;, &quot;surname#&quot;, &quot;author-last#&quot;, &quot;author#-last&quot;, &quot;subject#&quot;, &quot;Author#&quot;},
	['AuthorList-Link'] = {&quot;authorlink#&quot;, &quot;author-link#&quot;, &quot;author#-link&quot;, &quot;subjectlink#&quot;, &quot;author#link&quot;, &quot;subject-link#&quot;, &quot;subject#-link&quot;, &quot;subject#link&quot;},
	['AuthorList-Mask'] = {&quot;author-mask#&quot;, &quot;authormask#&quot;, &quot;author#mask&quot;, &quot;author#-mask&quot;},
	
	['EditorList-First'] = {&quot;editor-first#&quot;, &quot;editor#-first&quot;, &quot;editor-given#&quot;, &quot;editor#-given&quot;, &quot;EditorGiven#&quot;},
	['EditorList-Last'] = {&quot;editor#&quot;, &quot;editor-last#&quot;, &quot;editor#-last&quot;, &quot;editor-surname#&quot;, &quot;editor#-surname&quot;, &quot;EditorSurname#&quot;, &quot;Editor#&quot;},
	['EditorList-Link'] = {&quot;editor-link#&quot;, &quot;editor#-link&quot;, &quot;editorlink#&quot;, &quot;editor#link&quot;},
	['EditorList-Mask'] = {&quot;editor-mask#&quot;, &quot;editor#-mask&quot;, &quot;editormask#&quot;, &quot;editor#mask&quot;},
}

--[[--------------------------&lt; D E F A U L T S &gt;--------------------------------------------------------------

-- Default parameter values

]]

local defaults = {
	['DeadURL'] = 'yes',
	['PPrefix'] = &quot;p.&amp;nbsp;&quot;,
	['PPPrefix'] = &quot;pp.&amp;nbsp;&quot;,	
}

--[[--------------------------&lt; M A I N T E N A N C E _ C A T E G O R I E S &gt;----------------------------------

Here we name maintenance categories to be used in maintenance messages.

]]

local maint_cats = {
	['ASIN'] = 'CS1 maint: ASIN uses ISBN',
	['date_year'] = 'CS1 maint: Date and year',
	['disp_auth_ed'] = 'CS1 maint: display-$1',									-- $1 is authors or editors
	['embargo'] = 'CS1 maint: PMC embargo expired',
	['english'] = 'CS1 maint: English language specified',
	['etal'] = 'CS1 maint: Explicit use of et al.',
	['extra_text'] = 'CS1 maint: Extra text',
	['unknown_lang'] = 'CS1 maint: Unrecognized language',
	['untitled'] = 'CS1 maint: Untitled periodical',
	}

--[[--------------------------&lt; P R O P E R T I E S _ C A T E G O R I E S &gt;------------------------------------

Here we name properties categories

]]

local prop_cats = {
	['foreign_lang_source'] = 'CS1 $1-language sources ($2)',					-- |language= categories; $1 is language name, $2 is ISO639-1 code
	['script'] = 'CS1 uses foreign language script',							-- when language specified by |script-title=xx: doesn't have its own category
	['script_with_name'] = 'CS1 uses $1-language script ($2)',					-- |script-title=xx: has matching category; $1 is language name, $2 is ISO639-1 code
	}



--[[--------------------------&lt; T I T L E _ T Y P E S &gt;--------------------------------------------------------

Here we map a template's CitationClass to TitleType

]]

local title_types = {
	['AV-media-notes'] = 'Media notes',
	['DVD-notes'] = 'Media notes',
	['mailinglist'] = 'Mailing list',
	['map'] = 'Map',
	['podcast'] = 'Podcast',
	['pressrelease'] = 'Press release',
	['report'] = 'Report',
	['techreport'] = 'Technical report',
	['thesis'] = 'Thesis',
	}

--[[--------------------------&lt; E R R O R _ C O N D I T I O N S &gt;----------------------------------------------

Error condition table

The following contains a list of IDs for various error conditions defined in the 
code.  For each ID, we specify a text message to display, an error category to
include, and whether the error message should be wrapped as a hidden comment.

Anchor changes require identical changes to matching anchor in Help:CS1 errors

]]

local error_conditions = {
	accessdate_missing_url = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;accessdate=&lt;/code&gt; requires &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'accessdate_missing_url',
		category = 'Pages using citations with accessdate and no URL',
		hidden = true },
	archive_missing_date = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;archiveurl=&lt;/code&gt; requires &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;archivedate=&lt;/code&gt;',
		anchor = 'archive_missing_date',
		category = 'Pages with archiveurl citation errors',
		hidden = false },
	archive_missing_url = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;archiveurl=&lt;/code&gt; requires &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'archive_missing_url',
		category = 'Pages with archiveurl citation errors',
		hidden = false },
	arxiv_missing = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;arxiv=&lt;/code&gt; required',
		anchor = 'arxiv_missing',
		category = 'CS1 errors: arXiv',											-- same as bad arxiv
		hidden = false },
	arxiv_params_not_supported = {
		message = 'Unsupported parameter(s) in cite arXiv',
		anchor = 'arxiv_params_not_supported',
		category = 'CS1 errors: arXiv',											-- same as bad arxiv
		hidden = false },
	bad_arxiv = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;arxiv=&lt;/code&gt; value',
		anchor = 'bad_arxiv',
		category = 'CS1 errors: arXiv',
		hidden = false },
	bad_asin = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;asin=&lt;/code&gt; value',
		anchor = 'bad_asin',
		category ='CS1 errors: ASIN',
		hidden = false },
	bad_authorlink = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;authorlink=&lt;/code&gt; value',
		anchor = 'bad_authorlink',
		category = 'CS1 errors: authorlink',
		hidden = false },
	bad_date = {
		message = 'Check date values in: &lt;code style=&quot;'..code_style..'&quot;&gt;$1&lt;/code&gt;',
		anchor = 'bad_date',
		category = 'CS1 errors: dates',
		hidden = false },
	bad_doi = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;doi=&lt;/code&gt; value',
		anchor = 'bad_doi',
		category = 'CS1 errors: DOI',
		hidden = false },
	bad_isbn = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;isbn=&lt;/code&gt; value',
		anchor = 'bad_isbn',
		category = 'Pages with ISBN errors',
		hidden = false },
	bad_ismn = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;ismn=&lt;/code&gt; value',
		anchor = 'bad_ismn',
		category = 'CS1 errors: ISMN',
		hidden = false },
	bad_issn = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;issn=&lt;/code&gt; value',
		anchor = 'bad_issn',
		category = 'CS1 errors: ISSN',
		hidden = false },
	bad_lccn = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;lccn=&lt;/code&gt; value',
		anchor = 'bad_lccn',
		category = 'CS1 errors: LCCN',
		hidden = false },
	bad_message_id = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;message-id=&lt;/code&gt; value',
		anchor = 'bad_message_id',
		category = 'CS1 errors: message-id',
		hidden = false },
	bad_ol = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;ol=&lt;/code&gt; value',
		anchor = 'bad_ol',
		category = 'CS1 errors: OL',
		hidden = false },
	bad_pmc = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;pmc=&lt;/code&gt; value',
		anchor = 'bad_pmc',
		category = 'CS1 errors: PMC',
		hidden = false },
	bad_pmid = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;pmid=&lt;/code&gt; value',
		anchor = 'bad_pmid',
		category = 'CS1 errors: PMID',
		hidden = false },
	bad_url = {
		message = 'Check &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;url=&lt;/code&gt; scheme',
		anchor = 'bad_url',
		category = 'Pages with URL errors',
		hidden = false },
	bare_url_missing_title = {
		message = '$1 missing title',
		anchor = 'bare_url_missing_title',
		category = 'Pages with citations having bare URLs',
		hidden = false },
	chapter_ignored = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;chapter=&lt;/code&gt; ignored',
		anchor = 'chapter_ignored',
		category = 'CS1 errors: chapter ignored',
		hidden = false },
	citation_missing_title = {
		message = 'Missing or empty &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;title=&lt;/code&gt;',
		anchor = 'citation_missing_title',
		category = 'Pages with citations lacking titles',
		hidden = false },
	cite_web_url = {															-- this error applies to cite web and to cite podcast
		message = 'Missing or empty &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'cite_web_url',
		category = 'Pages using web citations with no URL',
		hidden = true },
	coauthors_missing_author = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;coauthors=&lt;/code&gt; requires &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;author=&lt;/code&gt;',
		anchor = 'coauthors_missing_author',
		category = 'CS1 errors: coauthors without author',
		hidden = false },
	deprecated_params = {
		message = 'Cite uses deprecated parameter &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;$1=&lt;/code&gt;',
		anchor = 'deprecated_params',
		category = 'Pages containing cite templates with deprecated parameters',
		hidden = true },
	empty_citation = {
		message = 'Empty citation',
		anchor = 'empty_citation',
		category = 'Pages with empty citations',
		hidden = false },
	extra_pages = {
		message = 'Extra &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;pages=&lt;/code&gt; or &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;at=&lt;/code&gt;',
		anchor = 'extra_pages',
		category = 'Pages with citations using conflicting page specifications',
		hidden = false },
	first_missing_last = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;first$2=&lt;/code&gt; missing &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;last$2=&lt;/code&gt; in $1',
		anchor = 'first_missing_last',
		category = 'CS1 errors: missing author or editor',
		hidden = false },
	format_missing_url = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;$2=&lt;/code&gt;',
		anchor = 'format_missing_url',
		category = 'Pages using citations with format and no URL',
		hidden = true },
	implict_etal_editor = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;displayeditors=&lt;/code&gt; suggested',
		anchor = 'displayeditors',
		category = 'Pages using citations with old-style implicit et al. in editors',
		hidden = true },
	invalid_param_val = {
		message = 'Invalid &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;$1=$2&lt;/code&gt;',
		anchor = 'invalid_param_val',
		category = 'CS1 errors: invalid parameter value',
		hidden = false },
	missing_name = {
		message = 'Missing &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;last$2=&lt;/code&gt; in $1',
		anchor = 'missing_name',
		category = 'CS1 errors: missing author or editor',
		hidden = false },
	parameter_ignored = {
		message = 'Unknown parameter &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;$1=&lt;/code&gt; ignored',
		anchor = 'parameter_ignored',
		category = 'Pages with citations using unsupported parameters',
		hidden = false },
	parameter_ignored_suggest = {
		message = 'Unknown parameter &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;$1=&lt;/code&gt; ignored (&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;$2=&lt;/code&gt; suggested)',
		anchor = 'parameter_ignored_suggest',
		category = 'Pages with citations using unsupported parameters',
		hidden = false },
	redundant_parameters = {
		message = 'More than one of $1 specified',
		anchor = 'redundant_parameters',
		category = 'Pages with citations having redundant parameters',
		hidden = false },
	text_ignored = {
		message = 'Text &quot;$1&quot; ignored',
		anchor = 'text_ignored',
		category = 'Pages with citations using unnamed parameters',
		hidden = false },
	trans_missing_chapter = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;trans-chapter=&lt;/code&gt; requires &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;chapter=&lt;/code&gt;',
		anchor = 'trans_missing_chapter',
		category = 'Pages with citations using translated terms without the original',
		hidden = false },
	trans_missing_title = {
		message = '&lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;trans-title=&lt;/code&gt; requires &lt;code style=&quot;'..code_style..'&quot;&gt;&amp;#124;title=&lt;/code&gt;',
		anchor = 'trans_missing_title',
		category = 'Pages with citations using translated terms without the original',
		hidden = false },
	vancouver = {
		message = 'Vancouver style error',
		anchor = 'vancouver',
		category = 'CS1 errors: Vancouver style',
		hidden = false },
	wikilink_in_url = {
		message = 'Wikilink embedded in URL title',
		anchor = 'wikilink_in_url',
		category = 'Pages with citations having wikilinks embedded in URL titles',
		hidden = false },
}

--[[--------------------------&lt; I D _ H A N D L E R S &gt;--------------------------------------------------------

The following contains a list of values for various defined identifiers.  For each identifier we specify a
variety of information necessary to properly render the identifier in the citation.

	parameters: a list of parameter aliases for this identifier
	link: Wikipedia article name
	label: the alternate name to apply to link
	mode: 	'manual' when there is a specific function in the code to handle the identifier;
			'external' for identifiers that link outside of Wikipedia;
	prefix: the first part of a url that will be concatenated with a second part which usually contains the identifier
	encode: true if uri should be percent encoded; otherwise false
	COinS: into rft.id
	separator: character or text between label and the identifier in the rendered citation
]]

local id_handlers = {
	['ARXIV'] = {
		parameters = {'arxiv', 'ARXIV', 'eprint'}, 
		link = 'wikipedia:arXiv',
		label = 'arXiv',
		mode = 'manual',
		prefix = '//arxiv.org/abs/', 						-- protocol relative tested 2013-09-04
		encode = false,
		COinS = 'info:arxiv',
		separator = ':',
	},
	['ASIN'] = {
		parameters = { 'asin', 'ASIN' },	   
		link = 'wikipedia:Amazon Standard Identification Number',
		label = 'ASIN',
		mode = 'manual',
		COinS = 'info:asin',
		separator = '&amp;nbsp;',
		encode = false;
	},
	['BIBCODE'] = {
		parameters = {'bibcode', 'BIBCODE'}, 
		link = 'wikipedia:Bibcode',
		label = 'Bibcode',
		mode = 'external',
		prefix = 'http://adsabs.harvard.edu/abs/',
		encode = false,
		COinS = 'info:bibcode',
		separator = ':',
	},
	['DOI'] = {
		parameters = { 'doi', 'DOI' },
		link = 'wikipedia:Digital object identifier',
		label = 'doi',
		mode = 'manual',
		prefix = '//dx.doi.org/',
		COinS = 'info:doi',
		separator = ':',
		encode = true,
	},
	['ISBN'] = {
		parameters = {'isbn', 'ISBN', 'isbn13', 'ISBN13'}, 
		link = 'wikipedia:International Standard Book Number',
		label = 'ISBN',
		mode = 'manual',
		prefix = 'Special:BookSources/',
		COinS = 'rft.isbn',
		separator = '&amp;nbsp;',
	},
	['ISMN'] = {
		parameters = {'ismn', 'ISMN'}, 
		link = 'wikipedia:International Standard Music Number',
		label = 'ISMN',
		mode = 'manual',
		prefix = '',															-- not currently used; 
		COinS = 'info:ismn',
		separator = '&amp;nbsp;',
	},
	['ISSN'] = {
		parameters = {'issn', 'ISSN'}, 
		link = 'wikipedia:International Standard Serial Number',
		label = 'ISSN',
		mode = 'manual',
		prefix = '//www.worldcat.org/issn/',
		COinS = 'rft.issn',
		encode = false,
		separator = '&amp;nbsp;',
	},
	['JFM'] = {
		parameters = {'jfm', 'JFM'}, 
		link = 'wikipedia:Jahrbuch über die Fortschritte der Mathematik',
		label = 'JFM',
		mode = 'external',
		prefix = '//zbmath.org/?format=complete&amp;q=an:',
		COinS = 'rft.jfm',
		encode = true,
		separator = '&amp;nbsp;',
	},
	['JSTOR'] = {
		parameters = {'jstor', 'JSTOR'}, 
		link = 'wikipedia:JSTOR',
		label = 'JSTOR',
		mode = 'external',
		prefix = '//www.jstor.org/stable/', 				-- protocol relative tested 2013-09-04
		COinS = 'rft.jstor',
		encode = false,
		separator = '&amp;nbsp;',
	},
	['LCCN'] = {
		parameters = {'LCCN', 'lccn'}, 
		link = 'wikipedia:Library of Congress Control Number',
		label = 'LCCN',
		mode = 'manual',
		prefix = 'http://lccn.loc.gov/',
		COinS = 'rft.lccn',
		encode = false,
		separator = '&amp;nbsp;',
	},
	['MR'] = {
		parameters = {'MR', 'mr'}, 
		link = 'wikipedia:Mathematical Reviews',
		label = 'MR',
		mode = 'external',
		prefix = '//www.ams.org/mathscinet-getitem?mr=', 	-- protocol relative tested 2013-09-04
		COinS = 'rft.mr',
		encode = true,
		separator = '&amp;nbsp;',
	},
	['OCLC'] = {
		parameters = {'OCLC', 'oclc'}, 
		link = 'wikipedia:OCLC',
		label = 'OCLC',
		mode = 'external',
		prefix = '//www.worldcat.org/oclc/',
		COinS = 'info:oclcnum',
		encode = true,
		separator = '&amp;nbsp;',
	},
	['OL'] = {
		parameters = { 'ol', 'OL' },
		link = 'wikipedia:Open Library',
		label = 'OL',
		mode = 'manual',
		COinS = 'info:olnum',
		separator = '&amp;nbsp;',
		endode = true,
	},
	['OSTI'] = {
		parameters = {'OSTI', 'osti'}, 
		link = 'wikipedia:Office of Scientific and Technical Information',
		label = 'OSTI',
		mode = 'external',
		prefix = '//www.osti.gov/energycitations/product.biblio.jsp?osti_id=',	-- protocol relative tested 2013-09-04
		COinS = 'info:osti',
		encode = true,
		separator = '&amp;nbsp;',
	},
	['PMC'] = {
		parameters = {'PMC', 'pmc'}, 
		link = 'wikipedia:PubMed Central',
		label = 'PMC',
		mode = 'manual',									-- changed to support unlinking of PMC identifier when article is embargoed
		prefix = '//www.ncbi.nlm.nih.gov/pmc/articles/PMC', 
		suffix = &quot; &quot;,
		COinS = 'info:pmc',
		encode = true,
		separator = '&amp;nbsp;',
	},
	['PMID'] = {
		parameters = {'PMID', 'pmid'}, 
		link = 'wikipedia:PubMed Identifier',
		label = 'PMID',
		mode = 'manual',									-- changed from external manual to support PMID validation
		prefix = '//www.ncbi.nlm.nih.gov/pubmed/',
		COinS = 'info:pmid',
		encode = false,
		separator = '&amp;nbsp;',
	},
	['RFC'] = {
		parameters = {'RFC', 'rfc'}, 
		link = 'wikipedia:Request for Comments',
		label = 'RFC',
		mode = 'external',
		prefix = '//tools.ietf.org/html/rfc',
		COinS = 'info:rfc',
		encode = false,
		separator = '&amp;nbsp;',
	},
	['SSRN'] = {
		parameters = {'SSRN', 'ssrn'}, 
		link = 'wikipedia:Social Science Research Network',
		label = 'SSRN',
		mode = 'external',
		prefix = '//ssrn.com/abstract=', 					-- protocol relative tested 2013-09-04
		COinS = 'info:ssrn',
		encode = true,
		separator = '&amp;nbsp;',
	},
	['USENETID'] = {
		parameters = {'message-id'},
		link = 'wikipedia:Usenet',
		label = 'Usenet:',
		mode = 'manual',
		prefix = 'news:',
		encode = false,
		COinS = 'info:usenet',
		separator = '&amp;nbsp;',
	},
	['ZBL'] = {
		parameters = {'ZBL', 'zbl'}, 
		link = 'wikipedia:Zentralblatt MATH',
		label = 'Zbl',
		mode = 'external',
		prefix = '//zbmath.org/?format=complete&amp;q=an:',
		COinS = 'info:zbl',
		encode = true,
		separator = '&amp;nbsp;',
	},
}

return 	{
	aliases = aliases,
	defaults = defaults,
	error_conditions = error_conditions,
	id_handlers = id_handlers,
	maint_cats = maint_cats,
	messages = messages,
	presentation = presentation,
	prop_cats = prop_cats,
	title_types = title_types,
	uncategorized_namespaces = uncategorized_namespaces,
	uncategorized_subpages = uncategorized_subpages,
	}</text>
      <sha1>jpsx4xn8kmvsdtruc0z5gg4r01npyxr</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Date validation</title>
    <ns>828</ns>
    <id>42164542</id>
    <revision>
      <id>657017655</id>
      <parentid>652868337</parentid>
      <timestamp>2015-04-18T09:53:26Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>Synch from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="26501">
local p = {}

--[[--------------------------&lt; I S _ V A L I D _ A C C E S S D A T E &gt;----------------------------------------

returns true if:
	Wikipedia start date &lt;= accessdate &lt; today + 2 days

Wikipedia start date is 2001-01-15T00:00:00 UTC which is 979516800 seconds after 1970-01-01T00:00:00 UTC (the start of Unix time)
accessdate is the date provided in |accessdate= at time 00:00:00 UTC
today is the current date at time 00:00:00 UTC plus 48 hours
	if today is 2015-01-01T00:00:00 then
		adding 24 hours gives 2015-01-02T00:00:00 – one second more than today
		adding 24 hours gives 2015-01-03T00:00:00 – one second more than tomorrow

]]

local function is_valid_accessdate (accessdate)
	local lang = mw.getContentLanguage();
	local good1, good2;
	local access_ts, tomorrow_ts;												-- to hold unix time stamps representing the dates
		
	good1, access_ts = pcall( lang.formatDate, lang, 'U', accessdate );			-- convert accessdate value to unix timesatmp 
	good2, tomorrow_ts = pcall( lang.formatDate, lang, 'U', 'today + 2 days' );	-- today midnight + 2 days is one second more than all day tomorrow
	
	if good1 and good2 then
		access_ts = tonumber (access_ts);										-- convert to numbers for the comparison
		tomorrow_ts = tonumber (tomorrow_ts);
	else
		return false;															-- one or both failed to convert to unix time stamp
	end
	
	if 979516800 &lt;= access_ts and access_ts &lt; tomorrow_ts then					-- Wikipedia start date &lt;= accessdate &lt; tomorrow's date
		return true;
	else
		return false;															-- accessdate out of range
	end
end

--[[--------------------------&lt; G E T _ M O N T H _ N U M B E R &gt;----------------------------------------------

returns a number according to the month in a date: 1 for January, etc.  Capitalization and spelling must be correct. If not a valid month, returns 0

]]

local function get_month_number (month)
local long_months = {['January']=1, ['February']=2, ['March']=3, ['April']=4, ['May']=5, ['June']=6, ['July']=7, ['August']=8, ['September']=9, ['October']=10, ['November']=11, ['December']=12};
local short_months = {['Jan']=1, ['Feb']=2, ['Mar']=3, ['Apr']=4, ['May']=5, ['Jun']=6, ['Jul']=7, ['Aug']=8, ['Sep']=9, ['Oct']=10, ['Nov']=11, ['Dec']=12};
local temp;
	temp=long_months[month];
	if temp then return temp; end				-- if month is the long-form name
	temp=short_months[month];
	if temp then return temp; end				-- if month is the short-form name
	return 0;									-- misspelled, improper case, or not a month name
end

--[[--------------------------&lt; G E T _ S E A S O N _ N U M B E R &gt;--------------------------------------------

returns a number according to the sequence of seasons in a year: 1 for Winter, etc.  Capitalization and spelling must be correct. If not a valid season, returns 0

]]

local function get_season_number (season)
local season_list = {['Winter']=1, ['Spring']=2, ['Summer']=3, ['Fall']=4, ['Autumn']=4}
local temp;
	temp=season_list[season];
	if temp then return temp; end				-- if season is a valid name return its number
	return 0;									-- misspelled, improper case, or not a season name
end

--[[--------------------------&lt; I S _ P R O P E R _ N A M E &gt;--------------------------------------------------

returns a non-zero number if date contains a recognized proper name.  Capitalization and spelling must be correct.

]]

local function is_proper_name (name)
local name_list = {['Christmas']=1}
local temp;
	temp=name_list[name];
	if temp then return temp; end				-- if name is a valid name return its number
	return 0;									-- misspelled, improper case, or not a proper name
end

--[[--------------------------&lt; I S _ V A L I D _ M O N T H _ O R _ S E A S O N &gt;------------------------------

--returns true if month or season is valid (properly spelled, capitalized, abbreviated)

]]

local function is_valid_month_or_season (month_season)
	if 0 == get_month_number (month_season) then		-- if month text isn't one of the twelve months, might be a season
		if 0 == get_season_number (month_season) then	-- not a month, is it a season?
			return false;								-- return false not a month or one of the five seasons
		end
	end
	return true;
end


--[[--------------------------&lt; I S _ V A L I D _ Y E A R &gt;----------------------------------------------------

Function gets current year from the server and compares it to year from a citation parameter.  Years more than one year in the future are not acceptable.

]]

local function is_valid_year(year)
	if not is_set(year_limit) then
		year_limit = tonumber(os.date(&quot;%Y&quot;))+1;			-- global variable so we only have to fetch it once
	end
	return tonumber(year) &lt;= year_limit;				-- false if year is in the future more than one year
end

--[[
Returns true if day is less than or equal to the number of days in month and year is no farther into the future than next year; else returns false.

Assumes Julian calendar prior to year 1582 and Gregorian calendar thereafter. Accounts for Julian calendar leap years before 1582 and Gregorian leap years after 1582.
Where the two calendars overlap (1582 to approximately 1923) dates are assumed to be Gregorian.
]]
local function is_valid_date (year, month, day)
local days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
local month_length;
	if not is_valid_year(year) then	-- no farther into the future than next year
		return false;
	end
	
	if (2==month) then							-- if February
		month_length = 28;						-- then 28 days unless
		if 1582 &gt; tonumber(year) then			-- Julian calendar
			if 0==(year%4) then
				month_length = 29;
			end
		else									-- Gregorian calendar
			if (0==(year%4) and (0~=(year%100) or 0==(year%400))) then	-- is a leap year?
				month_length = 29;				-- if leap year then 29 days in February
			end
		end
	else
		month_length=days_in_month[month];
	end

	if tonumber (day) &gt; month_length then
		return false;
	end
	return true;
end

--[[--------------------------&lt; I S _ V A L I D _ M O N T H _ R A N G E _ S T Y L E &gt;--------------------------

Months in a range are expected to have the same style: Jan–Mar or October–December but not February–Mar or Jul–August. 
There is a special test for May because it can be either short or long form.

Returns true when style for both months is the same

]]

local function is_valid_month_range_style (month1, month2)
local len1 = month1:len();
local len2 = month2:len();
	if len1 == len2 then
		return true;															-- both months are short form so return true
	elseif 'May' == month1 or 'May'== month2 then
		return true;															-- both months are long form so return true
	elseif 3 == len1 or 3 == len2 then
		return false;															-- months are mixed form so return false
	else
		return true;															-- both months are long form so return true
	end
end


--[[--------------------------&lt; I S _ V A L I D _ M O N T H _ S E A S O N _ R A N G E &gt;------------------------

Check a pair of months or seasons to see if both are valid members of a month or season pair.

Month pairs are expected to be left to right, earliest to latest in time.

Similarly, seasons are also left to right, earliest to latest in time.  There is an oddity with seasons: winter is assigned a value of 1, spring 2, ...,
fall and autumn 4.  Because winter can follow fall/autumn at the end of a calender year, a special test is made to see if |date=Fall-Winter yyyy (4-1) is the date.

]]

local function is_valid_month_season_range(range_start, range_end)
	local range_start_number = get_month_number (range_start);
	
	if 0 == range_start_number then								-- is this a month range?
		local range_start_number = get_season_number (range_start);		-- not a month; is it a season? get start season number
		local range_end_number = get_season_number (range_end);			-- get end season number

		if 0 ~= range_start_number then							-- is start of range a season?
			if range_start_number &lt; range_end_number then		-- range_start is a season
				return true;									-- return true when range_end is also a season and follows start season; else false
			end
			if 4 == range_start_number and 1 == range_end_number then	-- special case when range is Fall-Winter or Autumn-Winter
				return true;
			end
		end
		return false;		-- range_start is not a month or a season; or range_start is a season and range_end is not; or improper season sequence
	end

	local range_end_number = get_month_number (range_end);		-- get end month number
	if range_start_number &lt; range_end_number then				-- range_start is a month; does range_start precede range_end?
		if is_valid_month_range_style (range_start, range_end) then				-- do months have the same style?
			return true;														-- proper order and same style
		end
	end
	return false;												-- range_start month number is greater than or equal to range end number; or range end isn't a month
end

--[[--------------------------&lt; C H E C K _ D A T E &gt;----------------------------------------------------------

Check date format to see that it is one of the formats approved by WP:DATESNO or WP:DATERANGE. Exception: only allowed range separator is endash.
Additionally, check the date to see that it is a real date: no 31 in 30-day months; no 29 February when not a leap year.  Months, both long-form and three
character abbreviations, and seasons must be spelled correctly. Future years beyond next year are not allowed.

If the date fails the format tests, this function returns false and does not return values for anchor_year and COinS_date.  When this happens, the date parameter is
used in the COinS metadata and the CITEREF identifier gets its year from the year parameter if present otherwise CITEREF does not get a date value.

Inputs:
	date_string - date string from date-holding parameters (date, year, accessdate, embargo, archivedate, etc.)

Returns:
	false if date string is not a real date; else
	true, anchor_year, COinS_date
		anchor_year can be used in CITEREF anchors
		COinS_date is date_string without anchor_year disambiguator if any
]]
local function check_date (date_string)
	local year;			-- assume that year2, months, and days are not used;
	local year2=0;		-- second year in a year range
	local month=0;
	local month2=0;		-- second month in a month range
	local day=0;
	local day2=0;		-- second day in a day range
	local anchor_year;
	local coins_date;

	if date_string:match(&quot;^%d%d%d%d%-%d%d%-%d%d$&quot;) then										-- year-initial numerical year month day format
		year, month, day=string.match(date_string, &quot;(%d%d%d%d)%-(%d%d)%-(%d%d)&quot;);
		month=tonumber(month);
		if 12 &lt; month or 1 &gt; month or 1583 &gt; tonumber(year) then return false; end			-- month number not valid or not Gregorian calendar
		anchor_year = year;

	elseif date_string:match(&quot;^%a+ +[1-9]%d?, +[1-9]%d%d%d%a?$&quot;) then						-- month-initial: month day, year
		month, day, anchor_year, year=string.match(date_string, &quot;(%a+)%s*(%d%d?),%s*((%d%d%d%d)%a?)&quot;);
		month = get_month_number (month);
		if 0 == month then return false; end												-- return false if month text isn't one of the twelve months
				
	elseif date_string:match(&quot;^%a+ +[1-9]%d?–[1-9]%d?, +[1-9]%d%d%d%a?$&quot;) then				-- month-initial day range: month day–day, year; days are separated by endash
		month, day, day2, anchor_year, year=string.match(date_string, &quot;(%a+) +(%d%d?)–(%d%d?), +((%d%d%d%d)%a?)&quot;);
		if tonumber(day) &gt;= tonumber(day2) then return false; end							-- date range order is left to right: earlier to later; dates may not be the same;
		month = get_month_number (month);
		if 0 == month then return false; end												-- return false if month text isn't one of the twelve months

	elseif date_string:match(&quot;^[1-9]%d? +%a+ +[1-9]%d%d%d%a?$&quot;) then						-- day-initial: day month year
		day, month, anchor_year, year=string.match(date_string, &quot;(%d%d*)%s*(%a+)%s*((%d%d%d%d)%a?)&quot;);
		month = get_month_number (month);
		if 0 == month then return false; end												-- return false if month text isn't one of the twelve months

	elseif date_string:match(&quot;^[1-9]%d?–[1-9]%d? +%a+ +[1-9]%d%d%d%a?$&quot;) then				-- day-range-initial: day–day month year; days are separated by endash
		day, day2, month, anchor_year, year=string.match(date_string, &quot;(%d%d?)–(%d%d?) +(%a+) +((%d%d%d%d)%a?)&quot;);
		if tonumber(day) &gt;= tonumber(day2) then return false; end							-- date range order is left to right: earlier to later; dates may not be the same;
		month = get_month_number (month);
		if 0 == month then return false; end												-- return false if month text isn't one of the twelve months

	elseif date_string:match(&quot;^[1-9]%d? +%a+ – [1-9]%d? +%a+ +[1-9]%d%d%d%a?$&quot;) then		-- day initial month-day-range: day month - day month year; uses spaced endash
		day, month, day2, month2, anchor_year, year=date_string:match(&quot;(%d%d?) +(%a+) – (%d%d?) +(%a+) +((%d%d%d%d)%a?)&quot;);
		if (not is_valid_month_season_range(month, month2)) or not is_valid_year(year) then return false; end	-- date range order is left to right: earlier to later;
		month = get_month_number (month);
		month2 = get_month_number (month2);

	elseif date_string:match(&quot;^%a+ +[1-9]%d? – %a+ +[1-9]%d?, +[1-9]%d%d%d?%a?$&quot;) then		-- month initial month-day-range: month day – month day, year;  uses spaced endash
		month, day, month2, day2, anchor_year, year=date_string:match(&quot;(%a+) +(%d%d?) – (%a+) +(%d%d?), +((%d%d%d%d)%a?)&quot;);
		if (not is_valid_month_season_range(month, month2)) or not is_valid_year(year) then return false; end
		month = get_month_number (month);
		month2 = get_month_number (month2);

	elseif date_string:match(&quot;^[1-9]%d? +%a+ +[1-9]%d%d%d – [1-9]%d? +%a+ +[1-9]%d%d%d%a?$&quot;) then		-- day initial month-day-year-range: day month year - day month year; uses spaced endash
		day, month, year, day2, month2, anchor_year, year2=date_string:match(&quot;(%d%d?) +(%a+) +(%d%d%d%d?) – (%d%d?) +(%a+) +((%d%d%d%d?)%a?)&quot;);
		if tonumber(year2) &lt;= tonumber(year) then return false; end							-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) or not is_valid_month_range_style(month, month2) then return false; end		-- year2 no more than one year in the future; months same style
		month = get_month_number (month);
		month2 = get_month_number (month2);

	elseif date_string:match(&quot;^%a+ +[1-9]%d?, +[1-9]%d%d%d – %a+ +[1-9]%d?, +[1-9]%d%d%d%a?$&quot;) then		-- month initial month-day-year-range: month day, year – month day, year;  uses spaced endash
		month, day, year, month2, day2, anchor_year, year2=date_string:match(&quot;(%a+) +(%d%d?), +(%d%d%d%d) – (%a+) +(%d%d?), +((%d%d%d%d)%a?)&quot;);
		if tonumber(year2) &lt;= tonumber(year) then return false; end							-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) or not is_valid_month_range_style(month, month2) then return false; end		-- year2 no more than one year in the future; months same style
		month = get_month_number (month);
		month2 = get_month_number (month2);

	elseif date_string:match(&quot;^%a+ +[1-9]%d%d%d–%d%d%a?$&quot;) then								-- special case Winter/Summer year-year (YYYY-YY); year separated with unspaced endash
		if nil == date_string:match(&quot;^Winter&quot;) and nil == date_string:match(&quot;^Summer&quot;) then return false end;	-- 'month' can only be Winter or Summer
		local century;
		year, century, anchor_year, year2=date_string:match(&quot;%a+ +((%d%d)%d%d)–((%d%d)%a?)&quot;);
		anchor_year=year..'–'..anchor_year;													-- assemble anchor_year from both years
		year2 = century..year2;																-- add the century to year2 for comparisons
		if 1 ~= tonumber(year2) - tonumber(year) then return false; end						-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) then return false; end									-- no year farther in the future than next year

	elseif date_string:match(&quot;^%a+ +[1-9]%d%d%d–[1-9]%d%d%d%a?$&quot;) then						-- special case Winter/Summer year-year; year separated with unspaced endash
		if nil == date_string:match(&quot;^Winter&quot;) and nil == date_string:match(&quot;^Summer&quot;) then return false end;	-- 'month' can only be Winter or Summer
		year, anchor_year, year2=date_string:match(&quot;%a+ +(%d%d%d%d)–((%d%d%d%d)%a?)&quot;);
		anchor_year=year..'–'..anchor_year;													-- assemble anchor_year from both years
		if 1 ~= tonumber(year2) - tonumber(year) then return false; end						-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) then return false; end									-- no year farther in the future than next year

	elseif date_string:match(&quot;^%a+ +[1-9]%d%d%d% – %a+ +[1-9]%d%d%d%a?$&quot;) then				-- month/season year - month/season year; separated by spaced endash
		month, year, month2, anchor_year, year2=date_string:match(&quot;(%a+) +(%d%d%d%d) – (%a+) +((%d%d%d%d)%a?)&quot;);
		anchor_year=year..'–'..anchor_year;													-- assemble anchor_year from both years
		if tonumber(year) &gt;= tonumber(year2) then return false; end							-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end									-- no year farther in the future than next year
		if not((0 ~= get_month_number(month) and 0 ~= get_month_number(month2) and is_valid_month_range_style(month, month2)) or 	-- both must be month year, same month style
			(0 ~= get_season_number(month) and 0 ~= get_season_number(month2))) then return false; end								-- or season year, not mixed

	elseif date_string:match (&quot;^%a+–%a+ +[1-9]%d%d%d%a?$&quot;) then								-- month/season range year; months separated by endash 
		month, month2, anchor_year, year=date_string:match (&quot;(%a+)–(%a+)%s*((%d%d%d%d)%a?)&quot;);
		if (not is_valid_month_season_range(month, month2)) or (not is_valid_year(year)) then
			return false;
		end
		
	elseif date_string:match(&quot;^%a+ +%d%d%d%d%a?$&quot;) then							-- month/season year or proper-name year
		month, anchor_year, year=date_string:match(&quot;(%a+)%s*((%d%d%d%d)%a?)&quot;);
		if not is_valid_year(year) then return false; end
		if not is_valid_month_or_season (month) and 0 == is_proper_name (month) then return false; end

	elseif date_string:match(&quot;^[1-9]%d%d%d?–[1-9]%d%d%d?%a?$&quot;) then				-- Year range: YYY-YYY or YYY-YYYY or YYYY–YYYY; separated by unspaced endash; 100-9999
		year, anchor_year, year2=date_string:match(&quot;(%d%d%d%d?)–((%d%d%d%d?)%a?)&quot;);
		anchor_year=year..'–'..anchor_year;										-- assemble anchor year from both years
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year

	elseif date_string:match(&quot;^[1-9]%d%d%d–%d%d%a?$&quot;) then						-- Year range: YYYY–YY; separated by unspaced endash
		local century;
		year, century, anchor_year, year2=date_string:match(&quot;((%d%d)%d%d)–((%d%d)%a?)&quot;);
		anchor_year=year..'–'..anchor_year;										-- assemble anchor year from both years
		if 13 &gt; tonumber(year2) then return false; end							-- don't allow 2003-05 which might be May 2003
		year2 = century..year2;													-- add the century to year2 for comparisons
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year

	elseif date_string:match(&quot;^[1-9]%d%d%d?%a?$&quot;) then							-- year; here accept either YYY or YYYY
		anchor_year, year=date_string:match(&quot;((%d%d%d%d?)%a?)&quot;);
		if false == is_valid_year(year) then
			return false;
		end

	else
		return false;											-- date format not one of the MOS:DATE approved formats
	end

	local result=true;											-- check whole dates for validity; assume true because not all dates will go through this test
	if 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 == month2 and 0 == day2 then		-- YMD (simple whole date)
		result=is_valid_date(year,month,day);

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 == month2 and 0 ~= day2 then	-- YMD-d (day range)
		result=is_valid_date(year,month,day);
		result=result and is_valid_date(year,month,day2);

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 ~= month2 and 0 ~= day2 then	-- YMD-md (day month range)
		result=is_valid_date(year,month,day);
		result=result and is_valid_date(year,month2,day2);

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 ~= year2 and 0 ~= month2 and 0 ~= day2 then	-- YMD-ymd (day month year range)
		result=is_valid_date(year,month,day);
		result=result and is_valid_date(year2,month2,day2);
	end
	
	if false == result then return false; end
																-- if here, then date_string is valid; get coins_date from date_string (leave CITEREF disambiguator) ...
	coins_date=date_string:match(&quot;^(.+%d)%a?$&quot;);				-- last character of valid disambiguatable date is always a digit
	coins_date= mw.ustring.gsub(coins_date, &quot;–&quot;, &quot;-&quot; );			-- ... and replace any ndash with a hyphen
	
	return true, anchor_year, coins_date;						-- format is good and date string represents a real date
end	

--[[--------------------------&lt; D A T E S &gt;--------------------------------------------------------------------

Cycle the date-holding parameters in passed table date_parameters_list through check_date() to check compliance with MOS:DATE. For all valid dates, check_date() returns
true. The |date= parameter test is unique, it is the only date holding parameter from which values for anchor_year (used in CITEREF identifiers) and COinS_date (used in
the COinS metadata) are derived.  The |date= parameter is the only date-holding parameter that is allowed to contain the no-date keywords &quot;n.d.&quot; or &quot;nd&quot; (without quotes).

Unlike most error messages created in this module, only one error message is created by this function. Because all of the date holding parameters are processed serially,
a single error message is created as the dates are tested.

]]

--function p.dates(date_parameters_list)
local function dates(date_parameters_list)
	local anchor_year;		-- will return as nil if the date being tested is not |date=
	local COinS_date;		-- will return as nil if the date being tested is not |date=
	local error_message = &quot;&quot;;
	local mismatch = 0;
	local good_date = false;
	
	for k, v in pairs(date_parameters_list) do										-- for each date-holding parameter in the list
		if is_set(v) then															-- if the parameter has a value
			if v:match(&quot;^c%. [1-9]%d%d%d?%a?$&quot;) then								-- special case for c. year or with or without CITEREF disambiguator - only |date= and |year=
				local year = v:match(&quot;c%. ([1-9]%d%d%d?)%a?&quot;);						-- get the year portion so it can be tested
				if 'date'==k then
					anchor_year, COinS_date = v:match(&quot;((c%. [1-9]%d%d%d?)%a?)&quot;);	-- anchor year and COinS_date only from |date= parameter
					good_date = is_valid_year(year);
				elseif 'year'==k then
					good_date = is_valid_year(year);
				end
			elseif 'date'==k then													-- if the parameter is |date=
				if v:match(&quot;^n%.d%.%a?&quot;) then										-- if |date=n.d. with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v:match(&quot;((n%.d%.)%a?)&quot;);	--&quot;n.d.&quot;; no error when date parameter is set to no date
				elseif v:match(&quot;^nd%a?$&quot;) then										-- if |date=nd with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v:match(&quot;((nd)%a?)&quot;);	--&quot;nd&quot;;	no error when date parameter is set to no date
				else
					good_date, anchor_year, COinS_date = check_date (v);			-- go test the date
				end
			elseif 'accessdate'==k then												-- if the parameter is |date=
				good_date = check_date (v);											-- go test the date
				if true == good_date then											-- if the date is a valid date
					good_date = is_valid_accessdate (v);							-- is Wikipedia start date &lt; accessdate &lt; tomorrow's date?
				end
			else																	-- any other date-holding parameter
				good_date = check_date (v);											-- go test the date
			end
			if false==good_date then												-- assemble one error message so we don't add the tracking category multiple times
				if is_set(error_message) then										-- once we've added the first portion of the error message ...
					error_message=error_message .. &quot;, &quot;;							-- ... add a comma space separator
				end
				error_message=error_message .. &quot;&amp;#124;&quot; .. k .. &quot;=&quot;;				-- add the failed parameter
			end
		end
	end
	return anchor_year, COinS_date, error_message, mismatch;					-- and done
end

--[[--------------------------&lt; Y E A R _ D A T E _ C H E C K &gt;------------------------------------------------

Compare the value provided in |year= with the year value(s) provided in |date=.  This function returns a numeric value:
	0 - year value does not match the year value in date
	1 - (default) year value matches the year value in date or one of the year values when date contains two years
	2 - year value matches the year value in date when date is in the form YYYY-MM-DD and year is disambiguated (|year=YYYYx)

]]

local function year_date_check (year_string, date_string)
	local year;
	local date1;
	local date2;
	local result = 1;															-- result of the test; assume that the test passes
	
	year = year_string:match ('(%d%d%d%d?)');

	if date_string:match ('%d%d%d%d%-%d%d%-%d%d') and year_string:match ('%d%d%d%d%a') then	--special case where date and year required YYYY-MM-DD and YYYYx
		date1 = date_string:match ('(%d%d%d%d)');
		year = year_string:match ('(%d%d%d%d)');
		if year ~= date1 then
			result = 0;															-- years don't match
		else
			result = 2;															-- years match; but because disambiguated, don't add to maint cat
		end
		
	elseif date_string:match (&quot;%d%d%d%d?.-%d%d%d%d?&quot;) then						-- any of the standard formats of date with two three- or four-digit years
		date1, date2 = date_string:match (&quot;(%d%d%d%d?).-(%d%d%d%d?)&quot;);
		if year ~= date1 and year ~= date2 then
			result = 0;
		end

	elseif date_string:match (&quot;%d%d%d%d[%s%-–]+%d%d&quot;) then						-- YYYY-YY date ranges
		local century;
		date1, century, date2 = date_string:match (&quot;((%d%d)%d%d)[%s%-–]+(%d%d)&quot;);
		date2 = century..date2;													-- convert YY to YYYY
		if year ~= date1 and year ~= date2 then
			result = 0;
		end

	elseif date_string:match (&quot;%d%d%d%d?&quot;) then									-- any of the standard formats of date with one year
		date1 = date_string:match (&quot;(%d%d%d%d?)&quot;);
		if year ~= date1 then
			result = 0;
		end
	end
	return result;
end

return {dates = dates, year_date_check = year_date_check}						-- return exported functions</text>
      <sha1>evxcqaduf4fc0hew673fzsesws7jc1s</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Whitelist</title>
    <ns>828</ns>
    <id>39013723</id>
    <revision>
      <id>673001037</id>
      <parentid>657017658</parentid>
      <timestamp>2015-07-25T10:24:18Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>Synch from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text xml:space="preserve" bytes="11624">
--[[--------------------------&lt; P A R A M E T E R S   N O T   S U P P O R T E D &gt;------------------------------

This is a list of parameters that once were but now are no longer supported:

	['albumlink'] = nil,			-- unique alias of titlelink used by old cite AV media notes
	['albumtype'] = nil,			-- controled inappropriate functionality in the old cite AV media notes
	['artist'] = nil,				-- unique alias of others used by old cite AV media notes
	['authors#'] = nil,				-- no need for multiple lists of author names
	['cointerviewers'] = nil,		-- unique alias of others used by old cite interview
	['day'] = nil,					-- deprecated in {{citation/core}} and somehow undeprecated in Module:Citation/CS1 and now finally removed
	['director'] = nil,				-- unique alias of author used by old cite DVD-notes
	['DoiBroken'] = nil,			-- not used, non-standard captialization
	['editors#'] = nil,				-- no need for multiple lists of editor names
	['Embargo'] = nil,				-- not used, non-standard capitalization
	['notestitle'] = nil,			-- unique alias of chapter used by old cite AV media notes
	['PPPrefix'] = nil,				-- not used, non-standard capitalization
	['publisherid'] = nil,			-- unique alias of id used by old cite AV media notes and old cite DVD-notes
	['titleyear'] = nil,			-- unique alias of origyear used by old cite DVD-notes

]]

--[[--------------------------&lt; S U P P O R T E D   P A R A M E T E R S &gt;--------------------------------------

Because a steady-state signal conveys no useful information, whitelist.basic_arguments[] list items can have three values:
	true - these parameters are valid and supported parameters
	false - these parameters are deprecated but still supported
	nil - these parameters are no longer supported (when setting a parameter to nil, leave a comment stating the reasons for invalidating the parameter)
	
]]

local whitelist = {}

local basic_arguments = {
	['accessdate'] = true,
	['access-date'] = true,
	['agency'] = true,
	['airdate'] = true,
	['air-date'] = true,
	['archivedate'] = true,
	['archive-date'] = true,
	['archive-format'] = true,
	['archiveurl'] = true,
	['archive-url'] = true,
	['article'] = true,
	['arxiv'] = true,
	['ARXIV'] = true,
	['asin'] = true,
	['ASIN'] = true,
	['asin-tld'] = true,
	['ASIN-TLD'] = true,
	['at'] = true,
	['author'] = true,
	['Author'] = false,						-- deprecated; non-standard capitalization
	['author-first'] = true,
	['authorformat'] = false,				-- deprecated; primarily used to support Vancouver format which functionality now part of name-list-format
	['author-format'] = false,				-- deprecated; primarily used to support Vancouver format which functionality now part of name-list-format
	['author-last'] = true,
	['authorlink'] = true,
	['author-link'] = true,
	['authormask'] = true,
	['author-mask'] = true,
	['author-name-separator'] = false,		-- deprecated; primarily used to support Vancouver format which functionality now part of name-list-format
	['authors'] = true,
	['author-separator'] = false,			-- deprecated; primarily used to support Vancouver format which functionality now part of name-list-format
	['began'] = false,															-- deprecated because module handles date ranges; cite episode and cite series
	['bibcode'] = true,
	['BIBCODE'] = true,
	['booktitle'] = true,
	['book-title'] = true,
	['callsign']=true,				-- cite interview
	['call-sign']=true,				-- cite interview
	['cartography'] = true,
	['chapter'] = true,
	['chapter-format'] = true,
	['chapterlink'] = false,		-- deprecated
	['chapter-link'] = false,		-- deprecated
	['chapterurl'] = true,
	['chapter-url'] = true,
	['city'] = true,				-- cite interview, cite episode, cite serial
	['class'] = true,				-- cite arxiv and arxiv identifiers
	['coauthor'] = false,			-- deprecated
	['coauthors'] = false,			-- deprecated
	['conference'] = true,
	['conference-format'] = true,
	['conferenceurl'] = true,
	['conference-url'] = true,
	['contribution'] = true,
	['contribution-format'] = true,
	['contributionurl'] = true,
	['contribution-url'] = true,
	['credits'] = true,				-- cite episode, cite serial
	['date'] = true,
	['deadurl'] = true,
	['dead-url'] = true,
	['degree'] = true,
	['department'] = true,
	['dictionary'] = true,
	['displayauthors'] = true,
	['display-authors'] = true,
	['displayeditors'] = true,
	['display-editors'] = true,
	['docket'] = true,
	['doi'] = true,
	['DOI'] = true,
	['doi-broken'] = true,
	['doi_brokendate'] = true,
	['doi-broken-date'] = true,
	['doi_inactivedate'] = true,
	['doi-inactive-date'] = true,
	['edition'] = true,
	['editor'] = true,
	['Editor'] = false,						-- deprecated; non-standard capitalization
	['editor-first'] = true,
	['editorformat'] = false,				-- deprecated; primarily used to support Vancouver format which functionality now part of name-list-format
	['editor-format'] = false,				-- deprecated; primarily used to support Vancouver format which functionality now part of name-list-format
	['EditorGiven'] = false,				-- deprecated; non-standard capitalization
	['editor-given'] = true,
	['editor-last'] = true,
	['editorlink'] = true,
	['editor-link'] = true,
	['editormask'] = true,
	['editor-mask'] = true,
	['editor-name-separator'] = false,		-- deprecated; primarily used to support Vancouver format which functionality now part of name-list-format
	['editors'] = true,
	['editor-separator'] = false,			-- deprecated; primarily used to support Vancouver format which functionality now part of name-list-format
	['EditorSurname'] = false,				-- deprecated; non-standard capitalization
	['editor-surname'] = true,
	['embargo'] = true,
	['encyclopaedia'] = true,
	['encyclopedia'] = true,
	['ended'] = false,															-- deprecated because module handles date ranges; cite episode and cite series
	['entry'] = true,
	['episode'] = true,															-- cite serial only TODO: make available to cite episode?
	['episodelink'] = true,														-- cite episode and cite serial
	['episode-link'] = true,													-- cite episode and cite serial
	['eprint'] = true,															-- cite arxiv and arxiv identifiers
	['event'] = true,
	['event-format'] = true,
	['eventurl'] = true,
	['event-url'] = true,
	['first'] = true,
	['format'] = true,
	['given'] = true,
	['host'] = true,
	['id'] = true,
	['ID'] = true,
	['ignoreisbnerror'] = true,
	['ignore-isbn-error'] = true,
	['in'] = true,
	['inset'] = true,
	['institution'] = true,
	['interviewer'] = true,				--cite interview
	['interviewers'] = true,			--cite interview
	['isbn'] = true,
	['ISBN'] = true,
	['isbn13'] = true,
	['ISBN13'] = true,
	['ismn'] = true,
	['ISMN'] = true,
	['issn'] = true,
	['ISSN'] = true,
	['issue'] = true,
	['jfm'] = true,
	['JFM'] = true,
	['journal'] = true,
	['jstor'] = true,
	['JSTOR'] = true,
	['language'] = true,
	['last'] = true,
	['lastauthoramp'] = true,
	['last-author-amp'] = true,
	['laydate'] = true,
	['lay-date'] = true,
	['laysource'] = true,
	['lay-source'] = true,
	['laysummary'] = true,
	['lay-summary'] = true,
	['lay-format'] = true,
	['layurl'] = true,
	['lay-url'] = true,
	['lccn'] = true,
	['LCCN'] = true,
	['location'] = true,
	['magazine'] = true,
	['mailinglist'] = true,				-- cite mailing list only
	['mailing-list'] = true,			-- cite mailing list only
	['map'] = true,						-- cite map only
	['map-format'] = true,				-- cite map only
	['mapurl'] = true,					-- cite map only
	['map-url'] = true,					-- cite map only
	['medium'] = true,
	['message-id'] = true,			-- cite newsgroup
	['minutes'] = true,
	['mode'] = true,
	['month'] = false,				-- deprecated
	['mr'] = true,
	['MR'] = true,
	['name-list-format'] = true,
	['name-separator'] = false,		-- deprecated;  primarily used to support Vancouver format which functionality now part of name-list-format
	['network'] = true,
	['newsgroup'] = true,
	['newspaper'] = true,
	['nocat'] = true,
	['no-cat'] = true,
	['nopp'] = true,
	['no-pp'] = true,
	['notracking'] = true,
	['no-tracking'] = true,
	['number'] = true,
	['oclc'] = true,
	['OCLC'] = true,
	['ol'] = true,
	['OL'] = true,
	['origyear'] = true,
	['orig-year'] = true,
	['osti'] = true,
	['OSTI'] = true,
	['others'] = true,
	['p'] = true,
	['page'] = true,
	['pages'] = true,
	['people'] = true,
	['periodical'] = true,
	['place'] = true,
	['pmc'] = true,
	['PMC'] = true,
	['pmid'] = true,
	['PMID'] = true,
	['postscript'] = true,
	['pp'] = true,
	['pp-prefix'] = true,
	['PPrefix'] = true,
	['p-prefix'] = true,
	['program']=true,				-- cite interview
	['publicationdate'] = true,
	['publication-date'] = true,
	['publicationplace'] = true,
	['publication-place'] = true,
	['publisher'] = true,
	['quotation'] = true,
	['quote'] = true,
	['ref'] = true,
	['Ref'] = true,
	['registration'] = true,
	['rfc'] = true,
	['RFC'] = true,
	['scale'] = true,
	['script-title'] = true,
	['season'] = true,
	['section'] = true,
	['section-format'] = true,
	['sections'] = true,					-- cite map only
	['sectionurl'] = true,
	['section-url'] = true,
	['separator'] = false,				-- deprecated; this functionality now provided by |mode=
	['series'] = true,
	['serieslink'] = true,
	['series-link'] = true,
	['seriesno'] = true,
	['series-no'] = true,
	['seriesnumber'] = true,
	['series-number'] = true,
	['series-separator'] = true,
	['sheet'] = true,															-- cite map only
	['sheets'] = true,															-- cite map only
	['ssrn'] = true,
	['SSRN'] = true,
	['station'] = true,
	['subject'] = true,
	['subjectlink'] = true,
	['subject-link'] = true,
	['subscription'] = true,
	['surname'] = true,
	['template doc demo'] = true,
	['template-doc-demo'] = true,
	['time'] = true,
	['timecaption'] = true,
	['time-caption'] = true,
	['title'] = true,
	['titlelink'] = true,
	['title-link'] = true,
	['trans_chapter'] = true,
	['trans-chapter'] = true,
	['trans-map'] = true;
	['transcript'] = true,
	['transcript-format'] = true,
	['transcripturl'] = true,
	['transcript-url'] = true,
	['trans_title'] = true,
	['trans-title'] = true,
	['type'] = true,
	['url'] = true,
	['URL'] = true,
	['vauthors'] = true,
	['veditors'] = true,
	['version'] = true,
	['via'] = true,
	['volume'] = true,
	['website'] = true,
	['work'] = true,
	['year'] = true,
	['zbl'] = true,
	['ZBL'] = true,
}

local numbered_arguments = {
	['author#'] = true,
	['Author#'] = false,														-- deprecated; non-standard capitalization
	['author-first#'] = true,
	['author#-first'] = true,
	['author-last#'] = true,
	['author#-last'] = true,
	['author-link#'] = true,
	['author#link'] = true,
	['author#-link'] = true,
	['authorlink#'] = true,
	['author-mask#'] = true,
	['author#mask'] = true,
	['author#-mask'] = true,
	['authormask#'] = true,
	['editor#'] = true,
	['Editor#'] = false,														-- deprecated; non-standard capitalization
	['editor-first#'] = true,
	['editor#-first'] = true,
	['EditorGiven#'] = false,													-- deprecated; non-standard capitalization
	['editor#-given'] = true,
	['editor-given#'] = true,
	['editor-last#'] = true,
	['editor#-last'] = true,
	['editor-link#'] = true,
	['editor#link'] = true,
	['editor#-link'] = true,
	['editorlink#'] = true,
	['editor-mask#'] = true,
	['editor#mask'] = true,
	['editor#-mask'] = true,
	['editormask#'] = true,
	['EditorSurname#'] = false,													-- deprecated; non-standard capitalization
	['editor#-surname'] = true,
	['editor-surname#'] = true,
	['first#'] = true,
	['given#'] = true,
	['last#'] = true,
	['subject#'] = true,
	['subject-link#'] = true,
	['subject#link'] = true,
	['subject#-link'] = true,
	['subjectlink#'] = true,
	['surname#'] = true,
}
--};

--return whitelist;
return {basic_arguments = basic_arguments, numbered_arguments = numbered_arguments};</text>
      <sha1>egi68rlbldwu0hbgktayui6dgsutta3</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite AV media</title>
    <ns>10</ns>
    <id>2327169</id>
    <revision>
      <id>690395471</id>
      <parentid>579832405</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite AV media: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators] (i...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="132">&lt;includeonly&gt;{{#invoke:Citation/CS1 | citation
|CitationClass=audio-visual
}}&lt;/includeonly&gt;&lt;noinclude&gt;{{documentation}} &lt;/noinclude&gt;</text>
      <sha1>5uc4e2t6myaznmqj6pk8sugy3rcqv8a</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite AV media notes</title>
    <ns>10</ns>
    <id>6305183</id>
    <revision>
      <id>622664318</id>
      <parentid>601953350</parentid>
      <timestamp>2014-08-24T22:48:26Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <minor/>
      <comment>Unspaced class name;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="166">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=AV-media-notes
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
[[Category:Lua-based templates]]
&lt;/noinclude&gt;</text>
      <sha1>3g1sj5e9w9e9c7953kmh3q2cnj8qs0x</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite book</title>
    <ns>10</ns>
    <id>4086375</id>
    <revision>
      <id>690395469</id>
      <parentid>579832408</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite book: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators] (indef...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="123">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=book
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>hq4yscm08hccl43rjw83qi7egacgxec</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite conference</title>
    <ns>10</ns>
    <id>4661319</id>
    <revision>
      <id>690395477</id>
      <parentid>579832424</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite conference: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators]...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="129">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=conference
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>72b4nmjtg0tb6m6oofjgdjq9bkhfx1k</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite DVD notes</title>
    <ns>10</ns>
    <id>9564705</id>
    <revision>
      <id>622664251</id>
      <parentid>601952838</parentid>
      <timestamp>2014-08-24T22:47:45Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>Unspaced class name;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="161">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=DVD-notes
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
[[Category:Lua-based templates]]
&lt;/noinclude&gt;</text>
      <sha1>mqifzn04nuajzrpvq3hyf22vhjl1dva</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite encyclopedia</title>
    <ns>10</ns>
    <id>1664277</id>
    <revision>
      <id>690395481</id>
      <parentid>579832446</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite encyclopedia: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="166">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=encyclopaedia
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}

[[Category:Lua-based templates]]
&lt;/noinclude&gt;</text>
      <sha1>jdzpxvlfcwjuua45ovk7i5lcp6qre48</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite episode</title>
    <ns>10</ns>
    <id>4268531</id>
    <revision>
      <id>690395482</id>
      <parentid>657020245</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite episode: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators] (in...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="126">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=episode
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>jvfdi0mqjvckd5aqot5911am34ya3kq</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite interview</title>
    <ns>10</ns>
    <id>6249342</id>
    <revision>
      <id>601954106</id>
      <parentid>579832332</parentid>
      <timestamp>2014-03-30T12:58:43Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <minor/>
      <comment>Migrate cite interview to [[Module:Citation/CS1]];</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="161">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=interview
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
[[Category:Lua-based templates]]
&lt;/noinclude&gt;</text>
      <sha1>fiwdindy6agekhy6sc8j6qye9bqs95a</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite journal</title>
    <ns>10</ns>
    <id>4740319</id>
    <revision>
      <id>690395473</id>
      <parentid>579832342</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite journal: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators] (in...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="126">&lt;includeonly&gt;{{#invoke:Citation/CS1|citation
|CitationClass=journal
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>9fcytsszanq7xbwi3p28zsneear9938</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite mailing list</title>
    <ns>10</ns>
    <id>10796582</id>
    <revision>
      <id>690395484</id>
      <parentid>647388096</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite mailing list: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="130">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=mailinglist
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>s1jzfny0npafa8yrdc9zkqa0ufztzyv</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite map</title>
    <ns>10</ns>
    <id>10381356</id>
    <revision>
      <id>690395478</id>
      <parentid>653005148</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite map: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators] (indefi...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="124">&lt;includeonly&gt;{{#invoke:Citation/CS1 | citation
|CitationClass=map
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>38ke9acao9s2ir80x2omh7pfe6u1rrp</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite news</title>
    <ns>10</ns>
    <id>4321630</id>
    <revision>
      <id>690395488</id>
      <parentid>579832384</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite news: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators] (indef...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="123">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=news
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>pbjnspfej5gxihr9izxrzkow3f1uf3i</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite newsgroup</title>
    <ns>10</ns>
    <id>4915298</id>
    <revision>
      <id>690395480</id>
      <parentid>635890477</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite newsgroup: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators] (...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="128">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=newsgroup
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>d4yhena3hhhu0vqqwb7rpsq8evu8drw</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite podcast</title>
    <ns>10</ns>
    <id>4991349</id>
    <revision>
      <id>672155149</id>
      <parentid>672154970</parentid>
      <timestamp>2015-07-19T17:33:35Z</timestamp>
      <contributor>
        <username>Audriusa</username>
        <id>593610</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="126">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=podcast
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>ctea86ez0h87ayzekjtkrhkf459z99e</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite press release</title>
    <ns>10</ns>
    <id>4821205</id>
    <revision>
      <id>690395487</id>
      <parentid>579832301</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite press release: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrator...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="162">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=pressrelease
|type={{{type|Press release}}}
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>rrr868rn0dee6pi9d99bhza0kd1bh7s</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite report</title>
    <ns>10</ns>
    <id>17977116</id>
    <revision>
      <id>647289185</id>
      <parentid>633946994</parentid>
      <timestamp>2015-02-15T20:28:55Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>Lua;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="125">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=report
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>fs19owa9dz9vn4e3ic0cogi85vev72c</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite serial</title>
    <ns>10</ns>
    <id>12741092</id>
    <revision>
      <id>657020781</id>
      <parentid>511122446</parentid>
      <timestamp>2015-04-18T10:33:32Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>[[WP:AES|←]]Replaced content with '&lt;includeonly&gt;{{#invoke:citation/CS1|citation |CitationClass=serial }}&lt;/includeonly&gt;&lt;noinclude&gt; {{documentation}} &lt;/noinclude&gt;'</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="125">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=serial
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>o5a2kg5nq7xtl1m6i4vj59zomqi7oa3</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite sign</title>
    <ns>10</ns>
    <id>5006670</id>
    <revision>
      <id>570932650</id>
      <parentid>535353666</parentid>
      <timestamp>2013-08-31T11:25:42Z</timestamp>
      <contributor>
        <username>Gadget850</username>
        <id>339034</id>
      </contributor>
      <comment>Lua</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="124">&lt;includeonly&gt;{{#invoke:Citation/CS1 | citation
|CitationClass=sign
}}&lt;/includeonly&gt;&lt;noinclude&gt;{{documentation}} &lt;/noinclude&gt;</text>
      <sha1>fu2faf7a4spn2eha4oy2bk0qb4nkzax</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite speech</title>
    <ns>10</ns>
    <id>7409370</id>
    <revision>
      <id>595573989</id>
      <parentid>587324641</parentid>
      <timestamp>2014-02-15T11:20:29Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>Upgrade to Lua module;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="125">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=speech
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>o91wcrdyx1kn466ph20yj8hjk6040zr</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite techreport</title>
    <ns>10</ns>
    <id>3990290</id>
    <revision>
      <id>580884765</id>
      <parentid>580884572</parentid>
      <timestamp>2013-11-09T11:50:14Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <minor/>
      <comment>Copypasta fail;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="129">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=techreport
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>rvufh285qigolexdffnys6mw4swz06f</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite thesis</title>
    <ns>10</ns>
    <id>24979476</id>
    <revision>
      <id>580884246</id>
      <parentid>511127900</parentid>
      <timestamp>2013-11-09T11:44:17Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>Migrate thesis to [[Module:Citation/CS1]];</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="125">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=thesis
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>56y1ni1s4cj23abrdeq1wiazsceexao</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite web</title>
    <ns>10</ns>
    <id>4148498</id>
    <revision>
      <id>690395489</id>
      <parentid>579832313</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite web: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators] (indefi...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="122">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=web
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>rcgmbcxu7hvs583g1f3rzz4c4dkizda</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Reflist</title>
    <ns>10</ns>
    <id>7585648</id>
    <revision>
      <id>617595037</id>
      <parentid>617584734</parentid>
      <timestamp>2014-07-19T16:16:30Z</timestamp>
      <contributor>
        <username>Edokter</username>
        <id>1624037</id>
      </contributor>
      <comment>Undid revision 617584734 by [[Special:Contributions/Nikkimaria|Nikkimaria]] ([[User talk:Nikkimaria|talk]]) Undo; we know the number (&gt;250,000)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="817">&lt;div class=&quot;reflist &lt;!--
 --&gt;{{#if: {{{1|}}}
    | columns {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }}
      | references-column-width 
      | references-column-count references-column-count-{{#if:1|{{{1}}}}} }}
    | {{#if: {{{colwidth|}}}
      | references-column-width }} }}&quot; style=&quot;&lt;!--
 --&gt;{{#if: {{{1|}}}
    | {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }}
      | {{column-width|{{#if:1|{{{1}}}}}}}
      | {{column-count|{{#if:1|{{{1}}}}}}} }}
    | {{#if: {{{colwidth|}}}
      | {{column-width|{{{colwidth}}}}} }} }} list-style-type: &lt;!--
 --&gt;{{{liststyle|{{#switch: {{{group|}}}
    | upper-alpha
    | upper-roman
    | lower-alpha
    | lower-greek
    | lower-roman = {{{group}}}
    | #default = decimal}}}}};&quot;&gt;
{{#tag:references|{{{refs|}}}|group={{{group|}}}}}&lt;/div&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>4gkyehj7b4opv62ycz6r0hb716dhgog</sha1>
    </revision>
  </page>
</mediawiki>
